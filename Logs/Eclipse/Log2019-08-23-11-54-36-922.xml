<Events startTimestamp="1566575676922" logVersion="1.0.0.1">
  <DocumentChange __id="4251" _type="Delete" date="Sat Aug 24 12:21:57 EDT 2019" docASTNodeCount="189" docActiveCodeLength="1023" docExpressionCount="118" docLength="1023" endLine="16" length="11" offset="438" startLine="15" timestamp="88040362">
    <text><![CDATA[		StringU
]]></text>
  </DocumentChange>
  <Command __id="4252" _type="EclipseCommand" commandID="org.eclipse.ui.edit.delete" date="Sat Aug 24 12:21:57 EDT 2019" timestamp="88040383" />
  <Command __id="4253" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Aug 24 12:21:58 EDT 2019" timestamp="88041444" />
  <Command __id="4254" _type="FileOpenCommand" date="Sat Aug 24 12:22:42 EDT 2019" docASTNodeCount="326" docActiveCodeLength="2859" docExpressionCount="204" docLength="2859" projectName="comp110-grader" timestamp="88085695">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\AnInterpretedRequirements.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter;

import framework.grading.FrameworkProjectRequirements;
import framework.grading.testing.BasicTestCase;
import grader.requirements.interpreter.specification.CSVRequirementsSpecification;

public class AnInterpretedRequirements extends FrameworkProjectRequirements implements InterpretedRequirements  {
	CSVRequirementsSpecification csvRequirementsSpecification;	
	public AnInterpretedRequirements(CSVRequirementsSpecification aCSVRequirementsSpecification) {
		csvRequirementsSpecification = aCSVRequirementsSpecification;
		addRequirements();
	}
	
	public void addRequirements() {
		int aNumRequirements = csvRequirementsSpecification.getNumberOfRequirements();
		for (int i = 0; i < aNumRequirements; i++) {
			addRequirement(i);
		}		
	}
	
	public void addRequirement(int aRequirementNum) {
		String aType = "";
		try {
		 aType = csvRequirementsSpecification.getType(aRequirementNum);
		if (aType == null) return;
		String aTypeLC = aType.toLowerCase();
		if (DUE_DATE.equals(aTypeLC)) {
			 addDueDate(aRequirementNum);
		} else if (FEATURE.equals(aTypeLC)) {
			addFeature(aRequirementNum);
		} else if (RESTRICTION.equals(aTypeLC)) {
			addRestriction(aRequirementNum);
		}
		} catch (Exception e) {
			System.out.println("Could not add requirement#:" + aRequirementNum + " " + aType );
			e.printStackTrace();
		}
	}
	
	public void addDueDate(int aRequirementNum) {
			String aDateTime = csvRequirementsSpecification.getDescription(aRequirementNum);
			Double aPercentage = csvRequirementsSpecification.getMaxScore(aRequirementNum);
			addDueDate(aDateTime, aPercentage);
	}
	
    public void addFeature(int aRequirementNum) {
    	boolean isExtraCredit = csvRequirementsSpecification.isExtraCredit(aRequirementNum);
    	boolean isManual = csvRequirementsSpecification.isManual(aRequirementNum);

    	String aName = csvRequirementsSpecification.getDescription(aRequirementNum);
    	Double aMaxScore =  csvRequirementsSpecification.getMaxScore(aRequirementNum);
    	BasicTestCase aTestCase = new AnInterpretedTestCase(aName, csvRequirementsSpecification, aRequirementNum);
    	addFeature(isManual, aName, aMaxScore, isExtraCredit, aTestCase);		
	}
    
    public void addRestriction(int aRequirementNum) {
    	boolean isExtraCredit = csvRequirementsSpecification.isExtraCredit(aRequirementNum);
    	boolean isManual = csvRequirementsSpecification.isManual(aRequirementNum);
    	String aName = csvRequirementsSpecification.getDescription(aRequirementNum);
    	Double aMaxScore =  csvRequirementsSpecification.getMaxScore(aRequirementNum);
    	BasicTestCase aTestCase = new AnInterpretedTestCase(aName, csvRequirementsSpecification, aRequirementNum);
    	addRestriction(isManual, aName, aMaxScore, isExtraCredit, aTestCase);		
   	}

}
]]></snapshot>
  </Command>
  <Command __id="4255" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 12:22:42 EDT 2019" docOffset="0" timestamp="88085850" />
  <Command __id="4256" _type="MoveCaretCommand" caretOffset="1005" date="Sat Aug 24 12:23:29 EDT 2019" docOffset="1138" timestamp="88132462" />
  <Command __id="4257" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 12:23:30 EDT 2019" timestamp="88133868" />
  <Command __id="4258" _type="MoveCaretCommand" caretOffset="2049" date="Sat Aug 24 12:23:57 EDT 2019" docOffset="2182" timestamp="88160328" />
  <Command __id="4259" _type="FileOpenCommand" date="Sat Aug 24 12:23:58 EDT 2019" docASTNodeCount="1204" docActiveCodeLength="8796" docExpressionCount="713" docLength="13106" projectName="comp110-grader" timestamp="88161504">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\framework\grading\FrameworkProjectRequirements.java]]></filePath>
    <snapshot><![CDATA[package framework.grading;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import util.trace.Tracer;
import wrappers.framework.project.ProjectWrapper;
import framework.execution.ARunningProject;
import framework.grading.testing.CheckResult;
import framework.grading.testing.Checkable;
import framework.grading.testing.Feature;
import framework.grading.testing.Restriction;
import framework.grading.testing.TestCase;
import grader.assignment.shift.AnAssignmentShiftManager;
import grader.basics.execution.BasicProjectExecution;
import grader.basics.project.BasicProjectIntrospection;
import grader.basics.project.CurrentProjectHolder;
import grader.basics.project.Project;
import grader.language.LanguageDependencyManager;
import grader.sakai.project.SakaiProject;
import grader.settings.GraderSettingsModelSelector;

/**
 * This is the fundamental container which holds all the features and
 * restrictions on which programs are graded.
 */
public class FrameworkProjectRequirements implements ProjectRequirements {

    private List<Feature> features;
    private List<Restriction> restrictions;
//    protected Map<Object, Object> userData = new HashMap();
    private List<DueDate> dueDates = new ArrayList<DueDate>();
    

    

	/**
     * It's important that there is a nullary constructor because this needs to
     * be able to be simply instantiated via reflection.
     */
    public FrameworkProjectRequirements() {
        features = new ArrayList<Feature>();
        restrictions = new ArrayList<Restriction>();
    }

    // Feature adding methods
    public void addFeature(Feature feature) {
        features.add(feature);
        feature.initRequirements(this);
    }

    public void addFeature(String name, double points, List<TestCase> testCases) {
        addFeature(new Feature(name, points, testCases));
    }

    public void addFeature(String name, double points, boolean extraCredit, List<TestCase> testCases) {
        addFeature(new Feature(name, points, extraCredit, testCases));
    }

    public void addFeature(String name, double points, TestCase... testCases) {
        addFeature(new Feature(name, points, testCases));
    }

    public void addFeature(String name, double points, boolean extraCredit, TestCase... testCases) {
        addFeature(new Feature(name, points, extraCredit, testCases));
    }

    public void addFeature(boolean anIsManual, String name, double points, boolean extraCredit, TestCase... testCases) {
        addFeature(new Feature(anIsManual, name, points, extraCredit, testCases));
    }

    public void addRestriction(boolean anIsManual, String name, double points, boolean extraCredit, TestCase... testCases) {
        addRestriction(new Restriction(anIsManual, name, points, extraCredit, testCases));
    }

    public void addManualFeature(String name, double points, boolean extraCredit) {
        addFeature(new Feature(true, name, points, extraCredit,  new TestCase[]{}));
    }

    public void addManualFeature(String name, double points, TestCase... testCases) {
        addFeature(new Feature(true, name, points, false, testCases));
    }

    public void addManualFeature(String name, double points, boolean extraCredit, TestCase... testCases) {
        addFeature(new Feature(true, name, points, extraCredit, testCases));
    }
    

    // Restriction adding methods
    public void addRestriction(Restriction restriction) {
        restrictions.add(restriction);
        restriction.initRequirements(this);
    }

    public void addRestriction(String name, double points, TestCase... testCases) {
        addRestriction(new Restriction(name, points, testCases));
    }

    public void addRestriction(String name, double points, List<TestCase> testCases) {
        addRestriction(new Restriction(name, points, testCases));
    }
    public void addManualRestriction(String name, double points, boolean extraCredit, TestCase... testCases) {
        addRestriction(new Restriction(true, name, points, extraCredit, testCases));
    }
    public void addManualRestriction(String name, double points, TestCase... testCases) {
        addRestriction(new Restriction(true, name, points, false, testCases));
    }
    
     

    // Due date adding methods
    public void addDueDate(DateTime dateTime, double percentage) {
        dueDates.add(new DueDate(dateTime, percentage));
    }

    public void addDueDate(String dateTime, double percentage) {
        DateTimeFormatter formatter = DateTimeFormat.forPattern("MM/dd/yyyy HH:mm:ss");
        DateTime dt = formatter.parseDateTime(dateTime);
        addDueDate(dt, percentage);
    }

    // Getters
    public List<Feature> getFeatures() {
        return features;
    }

    public List<Restriction> getRestrictions() {
        return restrictions;
    }

    // Grading methods
    /**
     * Given a project, this checks all the features against it.
     *
     * @param project The project to check, or grade.
     * @return A list of {@link CheckResult} corresponding to the features
     */
    public List<CheckResult> checkFeatures(Project project) {
//    	getUserData().clear();
    	clearUserObjects();
    	// need to do this once for all features and test cases to prserve caches
    	CurrentProjectHolder.setProject(project); // for Junit test cases
//    	BasicProjectIntrospection.clearProjectCaches(); // all th eclasses and methods cached
        List<CheckResult> results = new LinkedList<CheckResult>();
        SakaiProject sakaiProject = null;
        if (project instanceof ProjectWrapper) {
            ProjectWrapper projectWrapper = (ProjectWrapper) project;
            sakaiProject = projectWrapper.getProject();
        }
        for (Feature feature : features) {
//        	if (feature.isManual()) 
//        		continue;
//        	CurrentProjectHolder.setProject(project); // in case some feature reset the project
        	BasicProjectExecution.redirectOutput();
        	if (isInteractiveRun(feature))
        		results.add(feature.check(project, false)); // added again below
            if (sakaiProject != null) { // should we do the check anyway, regardless of whether sakaiProject is null or not
                sakaiProject.setCurrentGradingFeature(feature);
            
            try {
                results.add(feature.check(project)); //so the feature is added twice?
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
            
        			String anOutput = BasicProjectExecution.restoreOutputAndGetRedirectedOutput();
        			 if (anOutput != null && !anOutput.isEmpty()) {
                     	ARunningProject.appendToTranscriptFile(project, feature.getName(), anOutput);
                     }
        			 Tracer.resetNumTraces();
        			
        		
            }
            }
        }
        return results;
    }

    /**
     * Given a project, this checks all the restrictions against it.
     *
     * @param project The project to check, or grade.
     * @return A list of {@link CheckResult} corresponding to the restrictions
     */
    public List<CheckResult> checkRestrictions(Project project) {
        List<CheckResult> results = new LinkedList<CheckResult>();
        for (Restriction restriction : restrictions) {
        	if (isInteractiveRun(restriction))
        		results.add(restriction.check(project, false));
        	else
              results.add(restriction.check(project));
        }
        return results;
    }
    public static int MILLI_SECONDS_IN_DAY = 24*60*60*1000;
    
//    public static final String ASSIGNENT_ID = "Assignment";
    
   
   
//    public static ProjectRequirements getRequirement(Project aProject, ProjectRequirements anOriginal, int aShift) {
//    	Class anOriginalClass = anOriginal.getClass();
//    	String aClassName = anOriginalClass.getName();
//    	int anAssignmentStartIndex = aClassName.indexOf(ASSIGNENT_ID);
//    	if (anAssignmentStartIndex == -1)
//    		return null;
//    	if (anAssignmentStartIndex == -1) {
//    		return anOriginal;
//    	}
//    	int anAssignmentNumberStartIndex = anAssignmentStartIndex + ASSIGNENT_ID.length();
//    	int anAssignmentNumberEndIndex;
//    	for (anAssignmentNumberEndIndex = anAssignmentNumberStartIndex +1;
//    			
//    			anAssignmentNumberEndIndex < aClassName.length() && 
//    			Character.isDigit(aClassName.charAt(anAssignmentNumberEndIndex));
//    			anAssignmentNumberEndIndex++);   
//    	
//    	// This may not have a number actually
//        String anAssignmentNumberString = aClassName.substring(
//        		anAssignmentNumberStartIndex, anAssignmentNumberEndIndex);
//             	
//    	try {
//    		int anAssignmentNumber = Integer.parseInt(anAssignmentNumberString);
//    		int aNewAssignmentNumber = anAssignmentNumber + aShift;
//    		String aNewAssignmentClass = ASSIGNENT_ID + aNewAssignmentNumber;
//    		String aNewClassName = aClassName.replace(
//    				ASSIGNENT_ID + anAssignmentNumber,
//    				ASSIGNENT_ID + aNewAssignmentNumber);
//    		Class<?> aNewClass = Class.forName(aNewClassName);
//
//			return (ProjectRequirements) aNewClass.newInstance();
//    		
//    		
//    	} catch (NumberFormatException e) {
//    		Tracer.error(aClassName + " does not have a number following " + ASSIGNENT_ID );
//    		return anOriginal;
//    	} catch (InstantiationException e) {			
//			e.printStackTrace();
//			return anOriginal;
//		} catch (IllegalAccessException e) {
//			e.printStackTrace();
//			return anOriginal;
//		} catch (ClassNotFoundException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//			return anOriginal;
//
//		}
//    }

   
    @Override
    public double checkDueDate(Project aProject, DateTime dateTime) {
    	return AnAssignmentShiftManager.checkDueDate(this, aProject, dateTime);
//    	return checkDueDate(dateTime);
    	
    }
    /**
     * Given a due date, this figures out what score modifier (a percentage)
     * should be given.
     *
     * @param dateTime The submission time of the project
     * @return A score modifier percentage
     */
    public double checkDueDate(DateTime dateTime) {
        if (dueDates.isEmpty()) {
            return 1;
        }
        double percentage = 0;
        DateTime graceDateTime = dateTime;
        int aGraceDays = GraderSettingsModelSelector.getGraderSettingsModel().getGraceDays();
//        aGraceDays = 1; // to see if it works right
        if (aGraceDays > 0) {
        	graceDateTime = dateTime.minus(aGraceDays*MILLI_SECONDS_IN_DAY);
        }
        for (DueDate dueDate : dueDates) {
        	if (dueDate.getCutoffDate().isAfter(graceDateTime)) {
//            if (dueDate.getCutoffDate().isAfter(dateTime)) {
                percentage = Math.max(percentage, dueDate.getPercentage());
            }
        }
        Class aCurrentClass;
        
        // if percentage is 0, find the first subsequent assignment that gives them non zero
        // return that percentage
        // maybe record that shift in file
        // if current assignment is sacrificed, put multiplier of 0 regardless of value returned.
        
        return percentage;
    }

    @Override
    public Object[] getPermissions() {
        return LanguageDependencyManager.getDefaultPermissible().getPermissions();
    }
    @Override
    public Object getUserObject (Object aKey) {
//    	return userData.get(aKey);
    	return BasicProjectIntrospection.getUserObject(aKey);
    }
    @Override
    public void putUserObject (Object aKey, Object aValue) {
//    	 userData.put(aKey, aValue);
    	BasicProjectIntrospection.putUserObject(aKey, aValue);
    }
    boolean isInteractiveRun(Checkable aFeature) {
    	return aFeature.getName().equals(INTERACTIVE_RUN);
    }

	@Override
	public Feature getInteractiveRunFeature() {
		for (Feature aFeature:features) {
//			if (aFeature.getName().equals(INTERACTIVE_RUN))
			if (isInteractiveRun(aFeature))
				return aFeature;
		}
		return null;
	}
	@Override
	public Restriction getInteractiveRunRestriction() {
		for (Restriction aRestriction:restrictions) {
//			if (aFeature.getName().equals(INTERACTIVE_RUN))
			if (isInteractiveRun(aRestriction))
				return aRestriction;
		}
		return null;
	}

//	@Override
//	public Map<Object, Object> getUserData() {
//		return userData;
//	}
	@Override
	public void clearUserObjects() {
		BasicProjectIntrospection.clearUserObjects();
	}
	
	@Override
	public List<DueDate> getDueDates() {
		return dueDates;
	}
	@Override
	public void setDueDates(List<DueDate> dueDates) {
		this.dueDates = dueDates;
	}

}
]]></snapshot>
  </Command>
  <Command __id="4260" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 12:23:58 EDT 2019" timestamp="88161587" />
  <Command __id="4261" _type="SelectTextCommand" caretOffset="1656" date="Sat Aug 24 12:23:58 EDT 2019" end="1656" start="1646" timestamp="88161660" />
  <Command __id="4262" _type="FileOpenCommand" date="Sat Aug 24 12:24:08 EDT 2019" docASTNodeCount="326" docActiveCodeLength="2859" docExpressionCount="204" docLength="2859" projectName="comp110-grader" timestamp="88171284">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\AnInterpretedRequirements.java]]></filePath>
  </Command>
  <Command __id="4263" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sat Aug 24 12:24:08 EDT 2019" timestamp="88171344" />
  <Command __id="4264" _type="MoveCaretCommand" caretOffset="2049" date="Sat Aug 24 12:24:08 EDT 2019" docOffset="2182" timestamp="88171399" />
  <Command __id="4265" _type="MoveCaretCommand" caretOffset="1966" date="Sat Aug 24 12:24:28 EDT 2019" docOffset="2099" timestamp="88191496" />
  <Command __id="4266" _type="FileOpenCommand" date="Sat Aug 24 12:24:29 EDT 2019" docASTNodeCount="381" docActiveCodeLength="2795" docExpressionCount="271" docLength="2928" projectName="comp110-grader" timestamp="88192790">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\AnInterpretedTestCase.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter;

import wrappers.framework.project.ProjectWrapper;
import framework.grading.testing.BasicTestCase;
import grader.basics.execution.RunningProject;
import grader.basics.junit.NotAutomatableException;
import grader.basics.junit.TestCaseResult;
import grader.basics.project.NotGradableException;
import grader.basics.project.Project;
import grader.requirements.interpreter.checkers.InterpretedChecker;
import grader.requirements.interpreter.checkers.InterpretedCheckerRegistry;
import grader.requirements.interpreter.checkers.InterpretedCheckerResult;
import grader.requirements.interpreter.specification.CSVRequirementsSpecification;
import grader.sakai.project.SakaiProject;
import gradingTools.utils.RunningProjectUtils;

public class AnInterpretedTestCase extends BasicTestCase{
	CSVRequirementsSpecification csvRequirementsSpecification;
	int featureNumber;
	String input;
	
	public AnInterpretedTestCase(String aName, CSVRequirementsSpecification aCSVRequirementsSpecification,
							int aFeatureNum
							) {
		super(aName);
		csvRequirementsSpecification = aCSVRequirementsSpecification;
		featureNumber = aFeatureNum;
	}

	@Override
	public TestCaseResult test(Project project, boolean autoGrade)
			throws NotAutomatableException, NotGradableException {
		SakaiProject aSakaiProject = ((ProjectWrapper) project).getProject();
		String anInput = InterpretedVariablesSubstituter.getInput(csvRequirementsSpecification, featureNumber);
		Integer aTimeOut = csvRequirementsSpecification.getTimeOut(featureNumber);
		String anOutput = "";
		RunningProject runningProject = null;
		if (aTimeOut != null) {
		 runningProject = RunningProjectUtils.runProject(project, aTimeOut, anInput);
		anOutput = runningProject.await();
		} else { // use the I/O from last run, could also store I/O mapping in project
			anInput = aSakaiProject.getCurrentInput();
			anOutput = aSakaiProject.getCurrentOutput().toString();
		}
		String aComparator = csvRequirementsSpecification.getChecker(featureNumber);
		InterpretedChecker aChecker = InterpretedCheckerRegistry.getInterpretedChecker(aComparator);
		int numArgs = aChecker.getNumArgs();
		String[] anArgs = new String[numArgs];
		String allArgs = "";
		for (int i = 0; i < numArgs; i++) {
			String anArg = csvRequirementsSpecification.getArg(featureNumber, i);
			String anActualArg = InterpretedVariablesSubstituter.getValue(aSakaiProject, csvRequirementsSpecification, featureNumber, anOutput, anArg);
			anArgs[i] = anActualArg;
			allArgs += " " + anArg;
		}
		InterpretedCheckerResult aResult = aChecker.check(anArgs);
		String aFunctionCall = aComparator + " " + allArgs;
		
//		if (checkable instanceof Feature && aResult.isSucceeded()) {
		if (aResult.isSucceeded()) {
			return pass("");
		} else 
			return fail(aFunctionCall + " failed \n" + aResult.getNotes());
	}

}
]]></snapshot>
  </Command>
  <Command __id="4267" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 12:24:29 EDT 2019" timestamp="88192863" />
  <Command __id="4268" _type="SelectTextCommand" caretOffset="286" date="Sat Aug 24 12:24:29 EDT 2019" end="286" start="265" timestamp="88192936" />
  <Command __id="4269" _type="MoveCaretCommand" caretOffset="1400" date="Sat Aug 24 12:26:05 EDT 2019" docOffset="2081" timestamp="88288869" />
  <Command __id="4270" _type="SelectTextCommand" caretOffset="1418" date="Sat Aug 24 12:26:06 EDT 2019" end="1418" start="1400" timestamp="88289220" />
  <Command __id="4271" _type="FileOpenCommand" date="Sat Aug 24 12:26:08 EDT 2019" docASTNodeCount="26" docActiveCodeLength="187" docExpressionCount="13" docLength="221" projectName="comp110-grader" timestamp="88291690">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\InterpretedChecker.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter.checkers;


public interface InterpretedChecker {
//	public boolean isExpandFiles();
	public int getNumArgs();
	public InterpretedCheckerResult check (String[] anArgs);

}
]]></snapshot>
  </Command>
  <Command __id="4272" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 12:26:08 EDT 2019" timestamp="88291752" />
  <Command __id="4273" _type="SelectTextCommand" caretOffset="90" date="Sat Aug 24 12:26:08 EDT 2019" end="90" start="72" timestamp="88291812" />
  <Command __id="4274" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.type.hierarchy" date="Sat Aug 24 12:26:15 EDT 2019" timestamp="88298994" />
  <Command __id="4278" _type="FileOpenCommand" date="Sat Aug 24 12:26:56 EDT 2019" docASTNodeCount="1397" docActiveCodeLength="9980" docExpressionCount="918" docLength="16129" projectName="GraderBasics" timestamp="88339441">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\util\DirectoryUtils.java]]></filePath>
    <snapshot><![CDATA[package grader.basics.util;

import grader.basics.BasicLanguageDependencyManager;
import grader.basics.settings.BasicGradingEnvironment;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.ProcessBuilder.Redirect;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
//import scala.Option;
import util.misc.Common;

import util.trace.Tracer;

/**
 * A set of utilities to assist with the recursive nature of directories.
 */
public class DirectoryUtils {

    /**
     * Finds the first file in the given folder that matches the provided filter
     * @param folder The folder to look in
     * @param filter The filter to apply
     * @return The first found file wrapped in an {@link Option} in case none was found.
     */
    public static Option<File> find(File folder, FileFilter filter) {
        File[] files = folder.listFiles(filter);
        if (files == null || files.length == 0) {
            return Option.empty();
        } else {
            return Option.apply(files[0]);
        }
    }

    /**
     * Looks for a folder with the given name recursively in a provided directory.
     * @param currentDir The directory to start looking in
     * @param folderName The name of the desired directory
     * @return The located directory wrapped in an {@link Option} in case it wasn't found
     */
    public static Option<File> locateFolder(File currentDir, final String folderName) {
        // Don't accept files (they don't make sense) or Mac meta folders
        if (!currentDir.isDirectory() || currentDir.getName().equals("__MACOSX")) {
            return Option.empty();
        } else {
            Option<File> folder = find(currentDir, new FileFilter() {
                @Override
                public boolean accept(File pathname) {
                    return pathname.getName().equals(folderName);
                }
            });
            if (folder.isDefined()) {
                return folder;
            } else {
                for (File file : currentDir.listFiles()) {
                    Option<File> possible = locateFolder(file, folderName);
                    if (possible.isDefined()) {
                        return possible;
                    }
                }
                return Option.empty();
            }
        }
    }

    /**
     * Looks for all files matching the provided filter recursively.
     * @param dir The directory to start looking from
     * @param filter The filter to apply
     * @return The set all of all files that matched the filter
     */
    public static Set<File> getFiles(File dir, final FileFilter filter) {
        // Get files in this folder
        File[] files = dir.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                return !pathname.isDirectory() && filter.accept(pathname);
            }
        });
        
        Set<File> allFiles = new HashSet<>(files.length);
        //if (files != null) {
            allFiles.addAll(Arrays.asList(files));
        //}

        // Get files in sub directories
        File[] directories = dir.listFiles(new FileFilter() {
            @Override
            public boolean accept(File pathname) {
                return pathname.isDirectory();
            }
        });
        
        //if (directories != null) {
            for (File directory : directories) {
                allFiles.addAll(getFiles(directory, filter));
            }
        //}

        return allFiles;
    }

	public static Set<File> getSourceFiles(File sourceFolder, String aSourceFilePattern) {
	Set<File> aSourceFiles = getFiles(sourceFolder, new FileFilter() {
		@Override
		public boolean accept(File pathname) {
//			return pathname.getName().endsWith(".java");
			
			try {
				return ((aSourceFilePattern == null) || pathname.getCanonicalPath().contains(aSourceFilePattern)) &&					
						!pathname.getName().startsWith(".") && !pathname.getName().equals("package-info.java") &&
						pathname.getName().endsWith(BasicLanguageDependencyManager.getSourceFileSuffix());
			} catch (IOException e) {				
				e.printStackTrace();
				return false; // should never happen
			}

		}
	});
	return aSourceFiles;
	}
	
	public static boolean hasSuffix (String name, List<String> ignoreSuffixes) {
		for (String suffix:ignoreSuffixes) {
			if (name.endsWith(suffix)) {
                            return true;
                        }
			
		}
		return false; 
		
		
	}
	
	public static boolean compare (File correctDir, File testDir) {
		List<String> suffixes = new ArrayList<>();
		return compare(correctDir, testDir, suffixes);
		
	}
	
	public static String handleSpacesInExecutale(String aCommand) {
//		return aCommand.replaceAll("Program Files", "\"Program Files\""); // hack for now
		return "\"" + aCommand + "\"";
	}
	
	public static String diffWithResult( String anOptions, File correctChild, File testChild, String anOutputFileName) {
		String diffTool = BasicGradingEnvironment.get().getDiff();
		if ((diffTool == null || diffTool.isEmpty())) {
			System.out.println("cannot diff as no difftool provided");
			return "";
		}
//			diffTool = handleSpacesInExecutale(diffTool);
//		Path aPath = Paths.get(diffTool);
		try {
//			String aCanonicalPath = aPath.toFile().getCanonicalPath();
			String aCanonicalPath = diffTool;
			String aCorrectChildName =  "\"" + correctChild.getAbsolutePath() + "\"";
			String aTestChildName = "\"" + testChild.getAbsolutePath() + "\"";
			
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, correctChild.getAbsolutePath(), testChild.getAbsolutePath(), ">", testChild.getAbsolutePath()+"diff" );
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName);
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName,  ">", anOutputFileName);
			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, anOptions, aCorrectChildName, aTestChildName);


//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath );
			Process aProcess;
			aProcessBuilder.redirectError(Redirect.INHERIT);
			if (anOutputFileName == null) {
//				aProcessBuilder.redirectOutput(Redirect.INHERIT);
				aProcess = aProcessBuilder.start();
				aProcess.waitFor();
				BufferedReader br = new BufferedReader(new InputStreamReader(aProcess.getInputStream()));

				StringBuilder builder = new StringBuilder();
				String line = null;
				while ( (line = br.readLine()) != null) {
				   builder.append(line);
				   builder.append(System.getProperty("line.separator"));
				}
				String result = builder.toString();
				return result;
				

			} else {

			File anOutputFile = new File(anOutputFileName);
			if (!anOutputFile.exists())
				anOutputFile.createNewFile();
			aProcessBuilder.redirectOutput(Redirect.to(anOutputFile));
			 aProcess = aProcessBuilder.start();
			aProcess.waitFor();
			return Common.toText(anOutputFile);
			}

//			Process aProcess = aProcessBuilder.start();
//			aProcess.waitFor();
//			String diffText = Common.toText(new File(testChild.getAbsolutePath()+"diff"));

		} catch (IOException | InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return "";
		}
//		String command = diffTool + " " + correctChild.getAbsolutePath() + " " + testChild.getAbsolutePath() + " > " + testChild.getAbsolutePath()+"diff";
////		try {
////			Runtime.getRuntime().exec(command);
//			OEMisc.runWithProcessExecer(diffTool);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
	
		
	}
	public static void diff( String anOptions, File anOriginalFile, File aModifiedFile, String anOutputFileName) {
		String diffTool = BasicGradingEnvironment.get().getDiff();
		if ((diffTool == null || diffTool.isEmpty())) {
			System.out.println("cannot diff as no difftool provided");
			return;
		}
		String[] anOptionsList = anOptions.replace("\"", "").split("\\s+");
//			diffTool = handleSpacesInExecutale(diffTool);
//		Path aPath = Paths.get(diffTool);
		try {
//			String aCanonicalPath = aPath.toFile().getCanonicalPath();
			String aCanonicalPath = diffTool;
			String anOriginalFileName =  "\"" + anOriginalFile.getAbsolutePath() + "\"";
			String aModifiedFileName = "\"" + aModifiedFile.getAbsolutePath() + "\"";
			String[] anArgs = new String[anOptionsList.length + 3];
			for (int i=0; i < anOptionsList.length; i++) {
				anArgs[i + 1] = anOptionsList[i];
			}
			anArgs[0] = aCanonicalPath;
			anArgs[anOptionsList.length + 1] = anOriginalFileName;
			anArgs[anOptionsList.length + 2] = aModifiedFileName;
			
			
			
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, correctChild.getAbsolutePath(), testChild.getAbsolutePath(), ">", testChild.getAbsolutePath()+"diff" );
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName);
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName,  ">", anOutputFileName);
//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, anOptions, anOriginalFileName, aModifiedFileName);
			ProcessBuilder aProcessBuilder = new ProcessBuilder(anArgs);


//			ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath );
			aProcessBuilder.redirectError(Redirect.INHERIT);
			if (anOutputFileName == null) {
				aProcessBuilder.redirectOutput(Redirect.INHERIT);
				

			} else {

			File anOutputFile = new File(anOutputFileName);
			if (!anOutputFile.exists())
				anOutputFile.createNewFile();
			aProcessBuilder.redirectOutput(Redirect.to(anOutputFile));
			
			}

			Process aProcess = aProcessBuilder.start();
			aProcess.waitFor();
//			String diffText = Common.toText(new File(testChild.getAbsolutePath()+"diff"));

		} catch (IOException | InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return;
		}
//		String command = diffTool + " " + correctChild.getAbsolutePath() + " " + testChild.getAbsolutePath() + " > " + testChild.getAbsolutePath()+"diff";
////		try {
////			Runtime.getRuntime().exec(command);
//			OEMisc.runWithProcessExecer(diffTool);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
	
		
	}
	
	public static boolean compare (File correctDir, File testDir, List<String> ignoreSuffixes) {
		boolean retVal = true;		
		if (!correctDir.isDirectory() || ! testDir.isDirectory()) {
			Tracer.error("test or corect dir not really directories");
			return false;
		}
		File[] correctChildren = correctDir.listFiles();
		File[] testChildren = testDir.listFiles();
		if (correctChildren.length != testChildren.length) {
			Tracer.error("correct and test dir not same size:" + correctDir.getAbsolutePath() + "(" + correctChildren.length + "," + testChildren.length + ")");
			Tracer.info(DirectoryUtils.class, "Correct:" +  Common.toString(correctChildren) + " Test:" + Common.toString(testChildren));
			System.out.println( "Correct:" +  Common.toString(correctChildren) + " Test:" + Common.toString(testChildren));

			retVal = false;
//			return false;
			
		}
		for (File correctChild:correctChildren) {
			File testChild = new File (testDir,  correctChild.getName());
			if (!testChild.exists()) {
				Tracer.error("test file does not exist:" + testChild.getName());
				retVal = false;
//				return false;
                                continue;
			}
			if (hasSuffix(correctChild.getName(), ignoreSuffixes)) {
                            continue;
                        }
			if (correctChild.isDirectory()) {
				if (!testChild.isDirectory()) {
					Tracer.error("Test file is not a directory:" + testChild.getName());
					retVal = false;
//					return false;
				}
					if (!compare(correctChild, testChild, ignoreSuffixes)) {
						retVal = false;
						continue;
//						return false;
					} else {
                                            continue;
                                }
				
			}
//			if (hasSuffix(correctChild.getName(), ignoreSuffixes))
//				continue;
//			String diffTool = GradingEnvironment.get().getDiff();
//			if (!(diffTool == null || diffTool.isEmpty())) {
////				diffTool = handleSpacesInExecutale(diffTool);
////			Path aPath = Paths.get(diffTool);
//			try {
////				String aCanonicalPath = aPath.toFile().getCanonicalPath();
//				String aCanonicalPath = diffTool;
//				String aCorrectChildName =  "\"" + correctChild.getAbsolutePath() + "\"";
//				String aTestChildName = "\"" + testChild.getAbsolutePath() + "\"";
//				String anOutputFileName =  testChild.getAbsolutePath() + "diff";
//				File anOutputFile = new File(anOutputFileName);
//				if (!anOutputFile.exists())
//					anOutputFile.createNewFile();
////				ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, correctChild.getAbsolutePath(), testChild.getAbsolutePath(), ">", testChild.getAbsolutePath()+"diff" );
////				ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName);
////				ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName,  ">", anOutputFileName);
//				ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath, aCorrectChildName, aTestChildName);
//
//
////				ProcessBuilder aProcessBuilder = new ProcessBuilder(aCanonicalPath );
//
//				aProcessBuilder.redirectError(Redirect.INHERIT);
//				
//				aProcessBuilder.redirectOutput(Redirect.appendTo(anOutputFile));
//
//				Process aProcess = aProcessBuilder.start();
//				aProcess.waitFor();
////				String diffText = Common.toText(new File(testChild.getAbsolutePath()+"diff"));
//
//			} catch (IOException | InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
////			String command = diffTool + " " + correctChild.getAbsolutePath() + " " + testChild.getAbsolutePath() + " > " + testChild.getAbsolutePath()+"diff";
//////			try {
//////				Runtime.getRuntime().exec(command);
////				OEMisc.runWithProcessExecer(diffTool);
////			} catch (IOException e) {
////				// TODO Auto-generated catch block
////				e.printStackTrace();
////			}
//			}

			String correctText = Common.toText(correctChild).replaceAll("\r\n", "\n");
			String testText = Common.toText(testChild).replaceAll("\r\n", "\n");
			if (!correctText.equals(testText)) {
				Tracer.error("Not equal to test file:" + correctChild.getAbsolutePath());
				Tracer.info(DirectoryUtils.class, "-----------------Correct Text-----------------\n" + correctText);
				Tracer.info(DirectoryUtils.class,"-----------------Test Text-----------------\n" + testText);
//				System.out.println( "-----------------Correct Text-----------------\n" + correctText);
//				System.out.println("-----------------Test Text-----------------\n" + testText);
				diff("-w", correctChild, testChild, null);
				retVal = false;
//				return false;
			} else {
				Tracer.info(DirectoryUtils.class, "Equal to test file:" + correctChild.getAbsolutePath());
			}
			
			
		}		
		return retVal;
//		return true;
	}
	
	public static void main (String[] args) {
		File correctDir = new File ("Test Data/Correct 110 F13 Results/Assignment3");
		File testDir = new File ("Test Data/Test 110 F13 Assignments/Assignment3");
		String[] ignoreSuffixesArray = {".zip", ".ini", ".json"};
		List<String> ignoreSuffixesList = Arrays.asList(ignoreSuffixesArray);
		compare (correctDir, testDir, ignoreSuffixesList);
		
	}
}
]]></snapshot>
  </Command>
  <Command __id="4279" _type="PredictionCommand" date="Sat Aug 24 12:26:56 EDT 2019" prediction_type="MakingProgress" timestamp="88339442" />
  <Command __id="4280" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 12:26:56 EDT 2019" timestamp="88339511" />
  <Command __id="4281" _type="SelectTextCommand" caretOffset="7606" date="Sat Aug 24 12:26:56 EDT 2019" end="7606" start="7602" timestamp="88339575" />
  <Command __id="4282" _type="FileOpenCommand" date="Sat Aug 24 12:27:06 EDT 2019" docASTNodeCount="281" docActiveCodeLength="1746" docExpressionCount="174" docLength="2032" projectName="comp110-grader" timestamp="88349817">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\ADiffChecker.java]]></filePath>
  </Command>
  <Command __id="4283" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sat Aug 24 12:27:06 EDT 2019" timestamp="88349881" />
  <Command __id="4284" _type="MoveCaretCommand" caretOffset="1456" date="Sat Aug 24 12:27:06 EDT 2019" docOffset="1537" timestamp="88349935" />
  <Command __id="4285" _type="ShellCommand" date="Sat Aug 24 12:32:02 EDT 2019" timestamp="88645089" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4286" _type="ShellCommand" date="Sat Aug 24 12:52:46 EDT 2019" timestamp="89889305" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4287" _type="ShellCommand" date="Sat Aug 24 12:52:53 EDT 2019" timestamp="89897012" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4288" _type="ShellCommand" date="Sat Aug 24 12:53:01 EDT 2019" timestamp="89904940" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4289" _type="EclipseCommand" commandID="org.eclipse.search.ui.openFileSearchPage" date="Sat Aug 24 12:53:01 EDT 2019" timestamp="89905010" />
  <Command __id="4290" _type="FileOpenCommand" date="Sat Aug 24 12:53:45 EDT 2019" docASTNodeCount="648" docActiveCodeLength="5050" docExpressionCount="395" docLength="5793" projectName="comp110-grader" timestamp="89949007">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\execution\AProxyProjectClassLoader.java]]></filePath>
    <snapshot><![CDATA[package grader.execution;

import grader.file.FileProxy;
import grader.file.filesystem.AFileSystemFileProxy;
import grader.project.flexible.FlexibleProject;
import grader.project.folder.RootCodeFolder;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AProxyProjectClassLoader extends ClassLoader implements ProxyClassLoader {
    public static final String CLASS_MAIN = "main.finalAssignment";

    RootCodeFolder rootCodeFolder;
    String projectFolderName, binaryFolderName, binaryFileSystemFolderName;
    

	String sourceFolderMixedCaseName;
    List<Class> classesLoaded = new ArrayList();
    
    Map<String, Class> dynamicallyCompiledClass = new HashMap();

    public AProxyProjectClassLoader(RootCodeFolder aRootCodeFolder) {
        init(aRootCodeFolder);
    }

    void init(RootCodeFolder aRootCodeFolder) {
        rootCodeFolder = aRootCodeFolder;
        binaryFolderName = rootCodeFolder.getBinaryProjectFolderName();
        if (rootCodeFolder.getBinaryFolder() != null && rootCodeFolder.getBinaryFolder() instanceof AFileSystemFileProxy) {
        binaryFileSystemFolderName = rootCodeFolder.getBinaryFolder().getMixedCaseAbsoluteName();
        } 
//        else if (rootCodeFolder.getSourceFolder() != null){
//        	binaryFolderMixedCaseName = rootCodeFolder.getSourceFolder().
//        			getMixedCaseAbsoluteName().replaceAll(
//        					"/" + ARootCodeFolder.SOURCE + "/", 
//        					"/" + ARootCodeFolder.BINARY + "/");
//        }
        projectFolderName = rootCodeFolder.getProjectFolderName();
//        if (projectFolderName == null)
//        	projectFolderName = binaryFolderName; // bin folder was missing so bin folder became project folder and hence this confusion
    }

    public InputStream getResourceAsStream(String name) {
        InputStream retVal = super.getResourceAsStream(name);
        if (retVal != null)
            return retVal;
        String aFullFileName = projectFolderName + "/" + name;
        FileProxy fileProxy = rootCodeFolder.getRootFolder().getFileEntry(aFullFileName);
        InputStream inputStream = fileProxy.getInputStream();
        return inputStream;
    }
    @Override
    public Collection<Class> getDynamicallyCompiledClasses() {
    	return dynamicallyCompiledClass.values();
    }
    @Override
    public Class defineDynamicallyCompiledClass (String aClassName, byte[] aBytes) {
    		Class aClass = dynamicallyCompiledClass.get(aClassName); 
    		if (aClass == null)
    	
    			aClass = super.defineClass(aClassName, aBytes, 0, aBytes.length);
            if (aClass != null)
            	dynamicallyCompiledClass.put(aClassName, aClass);
            return aClass;
        
    }
    
    InputStream getInputStreamOfClass(String aFileName) {
    	// refetch the file as we may have recompiled classes
		File classFile = new File(binaryFileSystemFolderName, aFileName);
		if (classFile.exists()) {
			try {
				return  new FileInputStream(classFile);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
				return null;
			}
		} else {
    	
             String aFullFileName = binaryFolderName + "/" + aFileName;
             FileProxy classFileProxy = rootCodeFolder.getFileEntry(aFullFileName);
            return classFileProxy.getInputStream();
		}
    	
    }

    public Class findClass(String aClassName) throws ClassNotFoundException {
        try {
        	Class retVal = dynamicallyCompiledClass.get(aClassName);
        	if (retVal != null)
        		return retVal;
            byte classBytes[];
            String aFileName = aClassName.replaceAll("\\.", "/") + ".class";
//            String aFullFileName = binaryFolderName + "/" + aFileName;
//            FileProxy classFile = rootCodeFolder.getFileEntry(aFullFileName);
//            InputStream inputStream = classFile.getInputStream();
            InputStream inputStream = getInputStreamOfClass(aFileName);
            classBytes = new byte[inputStream.available()];
            inputStream.read(classBytes);
            Class classObject = defineClass(aClassName, classBytes, 0, classBytes.length);
            classesLoaded.add(classObject);
            return classObject;
        } catch (Exception e) {
            return null;
        }
    }
    public void clear() {
    	classesLoaded.clear();
    }
    public Class loadClass(String aClassName) throws ClassNotFoundException {
    	try {
        return super.loadClass(aClassName);
    	} catch (Exception e) {
    		return null;
    	}
    }

    public static void run(FlexibleProject aProject, String mainClassName) {
        try {
            ClassLoader classLoader = new AProxyProjectClassLoader(aProject.getRootCodeFolder());
            Class mainClass = classLoader.loadClass(mainClassName);
            Method mainMethod = mainClass.getMethod("main", String[].class);
            String[] strings = {"move 10 100"};
            Object[] myArgs = {strings};
            mainMethod.invoke(mainClass, myArgs);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    public String getBinaryFileSystemFolderName() {
		return binaryFileSystemFolderName;
	}
    @Override
	public void setBinaryFileSystemFolderName(String binaryFileSystemFolderName) {
		this.binaryFileSystemFolderName = binaryFileSystemFolderName;
	}

    public List<Class> getClassesLoaded() {
        return classesLoaded;
    }
}
]]></snapshot>
  </Command>
  <Command __id="4291" _type="SelectTextCommand" caretOffset="1615" date="Sat Aug 24 12:53:46 EDT 2019" end="1615" start="1604" timestamp="89949154" />
  <Command __id="4292" _type="ShellCommand" date="Sat Aug 24 12:54:13 EDT 2019" timestamp="89976925" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4293" _type="ShellCommand" date="Sat Aug 24 12:54:35 EDT 2019" timestamp="89998546" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4294" _type="ShellCommand" date="Sat Aug 24 12:54:39 EDT 2019" timestamp="90002802" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4295" _type="ShellCommand" date="Sat Aug 24 12:55:10 EDT 2019" timestamp="90033820" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4296" _type="ShellCommand" date="Sat Aug 24 12:55:26 EDT 2019" timestamp="90049385" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4297" _type="ShellCommand" date="Sat Aug 24 12:55:55 EDT 2019" timestamp="90078126" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4298" _type="EclipseCommand" commandID="org.eclipse.ui.project.properties" date="Sat Aug 24 12:55:55 EDT 2019" timestamp="90078147" />
  <Command __id="4299" _type="ShellCommand" date="Sat Aug 24 12:56:08 EDT 2019" timestamp="90091233" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4300" _type="ShellCommand" date="Sat Aug 24 12:57:00 EDT 2019" timestamp="90143081" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4301" _type="EclipseCommand" commandID="org.eclipse.ui.project.properties" date="Sat Aug 24 12:57:00 EDT 2019" timestamp="90143112" />
  <Command __id="4302" _type="PasteCommand" date="Sat Aug 24 12:57:24 EDT 2019" timestamp="90167427" />
  <Command __id="4303" _type="ShellCommand" date="Sat Aug 24 12:57:31 EDT 2019" timestamp="90174281" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4304" _type="ShellCommand" date="Sat Aug 24 12:58:04 EDT 2019" timestamp="90207157" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4305" _type="EclipseCommand" commandID="org.eclipse.ui.project.properties" date="Sat Aug 24 12:58:04 EDT 2019" timestamp="90207178" />
  <Command __id="4306" _type="FileOpenCommand" date="Sat Aug 24 12:58:39 EDT 2019" docASTNodeCount="63" docActiveCodeLength="416" docExpressionCount="32" docLength="416" projectName="comp110-grader" timestamp="90242492">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\ACheckerResult.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter.checkers;

public class ACheckerResult implements InterpretedCheckerResult {
	String notes = "";
	boolean succeeded;
	
	public ACheckerResult(String notes, boolean succeeded) {
		super();
		this.notes = notes;
		this.succeeded = succeeded;
	}
	public String getNotes() {
		return notes;
	}
	
	public boolean isSucceeded() {
		return succeeded;
	}
	
	

}
]]></snapshot>
  </Command>
  <Command __id="4307" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 12:58:39 EDT 2019" docOffset="0" timestamp="90242626" />
  <Command __id="4308" _type="FileOpenCommand" date="Sat Aug 24 12:58:45 EDT 2019" docASTNodeCount="281" docActiveCodeLength="1746" docExpressionCount="174" docLength="2032" projectName="comp110-grader" timestamp="90248831">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\ADiffChecker.java]]></filePath>
  </Command>
  <Command __id="4309" _type="MoveCaretCommand" caretOffset="1456" date="Sat Aug 24 12:58:45 EDT 2019" docOffset="1537" timestamp="90248943" />
  <Command __id="4310" _type="FileOpenCommand" date="Sat Aug 24 12:58:57 EDT 2019" docASTNodeCount="326" docActiveCodeLength="2859" docExpressionCount="204" docLength="2859" projectName="comp110-grader" timestamp="90260237">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\AnInterpretedRequirements.java]]></filePath>
  </Command>
  <Command __id="4311" _type="MoveCaretCommand" caretOffset="1966" date="Sat Aug 24 12:58:57 EDT 2019" docOffset="2099" timestamp="90260371" />
  <Command __id="4312" _type="FileOpenCommand" date="Sat Aug 24 12:59:18 EDT 2019" docASTNodeCount="63" docActiveCodeLength="416" docExpressionCount="32" docLength="416" projectName="comp110-grader" timestamp="90281893">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\ACheckerResult.java]]></filePath>
  </Command>
  <Command __id="4313" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 12:59:18 EDT 2019" docOffset="0" timestamp="90282012" />
  <Command __id="4314" _type="MoveCaretCommand" caretOffset="92" date="Sat Aug 24 12:59:24 EDT 2019" docOffset="92" timestamp="90287704" />
  <Command __id="4315" _type="FileOpenCommand" date="Sat Aug 24 12:59:25 EDT 2019" docASTNodeCount="21" docActiveCodeLength="168" docExpressionCount="11" docLength="168" projectName="comp110-grader" timestamp="90288514">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\InterpretedCheckerResult.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter.checkers;

public interface InterpretedCheckerResult {
	public String getNotes() ;
	
	public boolean isSucceeded() ;

}
]]></snapshot>
  </Command>
  <Command __id="4316" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 12:59:25 EDT 2019" timestamp="90288580" />
  <Command __id="4317" _type="SelectTextCommand" caretOffset="94" date="Sat Aug 24 12:59:25 EDT 2019" end="94" start="70" timestamp="90288658" />
  <Command __id="4318" _type="FileOpenCommand" date="Sat Aug 24 12:59:32 EDT 2019" docASTNodeCount="281" docActiveCodeLength="1746" docExpressionCount="174" docLength="2032" projectName="comp110-grader" timestamp="90295139">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\checkers\ADiffChecker.java]]></filePath>
  </Command>
  <Command __id="4319" _type="MoveCaretCommand" caretOffset="1537" date="Sat Aug 24 12:59:32 EDT 2019" docOffset="1537" timestamp="90295262" />
  <Command __id="4320" _type="ShellCommand" date="Sat Aug 24 12:59:37 EDT 2019" timestamp="90301061" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4321" _type="ShellCommand" date="Sat Aug 24 12:59:50 EDT 2019" timestamp="90313459" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4322" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.move.element" date="Sat Aug 24 12:59:50 EDT 2019" timestamp="90313487" />
  <Command __id="4323" _type="ShellCommand" date="Sat Aug 24 12:59:57 EDT 2019" timestamp="90320529" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4324" _type="ShellCommand" date="Sat Aug 24 12:59:58 EDT 2019" timestamp="90321080" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4325" _type="ShellCommand" date="Sat Aug 24 12:59:58 EDT 2019" timestamp="90321841" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4326" _type="ShellCommand" date="Sat Aug 24 13:00:43 EDT 2019" timestamp="90367070" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4327" _type="EclipseCommand" commandID="org.eclipse.egit.ui.team.Commit" date="Sat Aug 24 13:00:44 EDT 2019" timestamp="90367095" />
  <Command __id="4328" _type="ShellCommand" date="Sat Aug 24 13:00:49 EDT 2019" timestamp="90372173" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4329" _type="ShellCommand" date="Sat Aug 24 13:00:52 EDT 2019" timestamp="90375273" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4330" _type="ShellCommand" date="Sat Aug 24 13:01:02 EDT 2019" timestamp="90385425" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4331" _type="ShellCommand" date="Sat Aug 24 13:01:50 EDT 2019" timestamp="90433376" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4332" _type="EclipseCommand" commandID="org.eclipse.egit.ui.team.Commit" date="Sat Aug 24 13:01:50 EDT 2019" timestamp="90433393" />
  <Command __id="4333" _type="ShellCommand" date="Sat Aug 24 13:01:53 EDT 2019" timestamp="90436732" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4334" _type="ShellCommand" date="Sat Aug 24 13:01:55 EDT 2019" timestamp="90438396" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4335" _type="ShellCommand" date="Sat Aug 24 13:02:17 EDT 2019" timestamp="90460639" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="4336" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 13:02:41 EDT 2019" start_end="END" timestamp="90484179" />
  <Command __id="4337" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" date="Sat Aug 24 13:02:41 EDT 2019" start_end="END" timestamp="90484180" />
  <Command __id="4338" _type="ShellCommand" date="Sat Aug 24 13:02:41 EDT 2019" timestamp="90484428" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="4339" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.move.element" date="Sat Aug 24 13:02:41 EDT 2019" timestamp="90484461" />
  <Command __id="5668" _type="ShellCommand" date="Sat Aug 24 14:54:35 EDT 2019" timestamp="97198498" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5669" _type="PredictionCommand" date="Sat Aug 24 14:54:35 EDT 2019" prediction_type="MakingProgress" timestamp="97198521" />
  <Command __id="5670" _type="MoveCaretCommand" caretOffset="770" date="Sat Aug 24 14:54:35 EDT 2019" docOffset="770" timestamp="97198609" />
  <Command __id="5671" _type="ShellCommand" date="Sat Aug 24 14:54:37 EDT 2019" timestamp="97201044" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5672" _type="ShellCommand" date="Sat Aug 24 14:54:38 EDT 2019" timestamp="97201531" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5673" _type="RunCommand" date="Sat Aug 24 14:54:39 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="97202606" type="Debug" />
  <Command __id="5674" _type="RunCommand" date="Sat Aug 24 14:54:39 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="97202606" type="Debug" />
  <Command __id="5675" _type="RunCommand" date="Sat Aug 24 14:54:39 EDT 2019" kind="HitBreakPoint" projectName="GraderBasics" timestamp="97202606" type="Run" />
  <Command __id="5676" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 14:57:01 EDT 2019" docOffset="0" timestamp="97344127" />
  <Command __id="5677" _type="SelectTextCommand" caretOffset="842" date="Sat Aug 24 14:57:07 EDT 2019" end="842" start="0" timestamp="97350497" />
  <Command __id="5678" _type="CopyCommand" date="Sat Aug 24 14:57:08 EDT 2019" timestamp="97351497" />
  <Command __id="5679" _type="ShellCommand" date="Sat Aug 24 14:57:12 EDT 2019" timestamp="97355326" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5680" _type="ShellCommand" date="Sat Aug 24 14:58:49 EDT 2019" timestamp="97452944" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5681" _type="ShellCommand" date="Sat Aug 24 15:00:27 EDT 2019" timestamp="97550974" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5682" _type="ShellCommand" date="Sat Aug 24 15:00:37 EDT 2019" timestamp="97561061" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5683" _type="EclipseCommand" commandID="org.eclipse.search.ui.openFileSearchPage" date="Sat Aug 24 15:00:38 EDT 2019" timestamp="97561116" />
  <Command __id="5684" _type="ShellCommand" date="Sat Aug 24 15:00:54 EDT 2019" timestamp="97577946" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5685" _type="ShellCommand" date="Sat Aug 24 15:00:56 EDT 2019" timestamp="97579883" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5687" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 15:01:46 EDT 2019" docOffset="0" timestamp="97629717" />
  <Command __id="5688" _type="MoveCaretCommand" caretOffset="360" date="Sat Aug 24 15:02:00 EDT 2019" docOffset="360" timestamp="97643363" />
  <Command __id="5690" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:02:01 EDT 2019" timestamp="97644915" />
  <Command __id="5691" _type="SelectTextCommand" caretOffset="602" date="Sat Aug 24 15:02:01 EDT 2019" end="602" start="549" timestamp="97644990" />
  <Command __id="5692" _type="MoveCaretCommand" caretOffset="1206" date="Sat Aug 24 15:02:25 EDT 2019" docOffset="1325" timestamp="97668375" />
  <Command __id="5693" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:02:26 EDT 2019" timestamp="97669421" />
  <Command __id="5750" _type="RunCommand" date="Sat Aug 24 15:05:49 EDT 2019" kind="StepInto" projectName="(Unknown)" timestamp="97872583" type="Run" />
  <Command __id="5751" _type="EHExceptionCommand" date="Sat Aug 24 15:05:49 EDT 2019" timestamp="97872857" type="Exception">
    <outputString><![CDATA[E***No folder found for download path:Browse to a valid assignment download path. In the settings window, please enter correct download path for a problem in module:Comp110Interp or change the module.
]]></outputString>
  </Command>
  <Command __id="5752" _type="EHExceptionCommand" date="Sat Aug 24 15:05:49 EDT 2019" timestamp="97872964" type="Exception">
    <outputString><![CDATA[E***No stored download path. When the settings window comes up, please enter correct download path for a problem in module:Comp110Interp or change the module.
E***No folder found for download path:Browse to a valid assignment download path. In the settings window, please enter correct download path for a problem in module:Comp110Interp or change the module.
]]></outputString>
  </Command>
  <Command __id="5753" _type="EHExceptionCommand" date="Sat Aug 24 15:05:50 EDT 2019" timestamp="97873347" type="Exception">
    <outputString><![CDATA[Clearing scores of all students
]]></outputString>
  </Command>
  <Command __id="5754" _type="EHExceptionCommand" date="Sat Aug 24 15:05:54 EDT 2019" timestamp="97877289" type="Exception">
    <outputString><![CDATA[W***Checkstyle not enabled
]]></outputString>
  </Command>
  <Command __id="5755" _type="EHExceptionCommand" date="Sat Aug 24 15:05:54 EDT 2019" timestamp="97877675" type="Exception">
    <outputString><![CDATA[Searching for onyens between:acorrect->jbartel
Found start onyen:All, Correct (acorrect)
]]></outputString>
  </Command>
  <Command __id="5756" _type="EHExceptionCommand" date="Sat Aug 24 15:05:54 EDT 2019" timestamp="97877824" type="Exception">
    <outputString><![CDATA[Read spreadsheet table of size:8 from d:/dewan_backup/java/grader/test data/test 110interp/assignment1/grades.csv
Found end onyen:Bartel, Jacob(jbartel)
]]></outputString>
  </Command>
  <Command __id="5757" _type="EHExceptionCommand" date="Sat Aug 24 15:05:55 EDT 2019" timestamp="97878140" type="Exception">
    <outputString><![CDATA[Found unzipped folder, processing zip folder:Test Data\Test 110Interp\Assignment1\All, Correct (acorrect)\Submission attachment(s)\Program1
]]></outputString>
  </Command>
  <Command __id="5758" _type="EHExceptionCommand" date="Sat Aug 24 15:05:55 EDT 2019" timestamp="97878205" type="Exception">
    <outputString><![CDATA[Found unzipped folder, processing zip folder:Test Data\Test 110Interp\Assignment1\Bin, Missing (binmiss)\Submission attachment(s)\Program1
Found unzipped folder, processing zip folder:Test Data\Test 110Interp\Assignment1\Bartel, Jacob(jbartel)\Submission attachment(s)\Program1]]></outputString>
  </Command>
  <Command __id="5759" _type="EHExceptionCommand" date="Sat Aug 24 15:05:55 EDT 2019" timestamp="97878263" type="Exception">
    <outputString><![CDATA[
Student ids from assignment database:[all, correct (acorrect), bartel, jacob(jbartel), bin, missing (binmiss)]
]]></outputString>
  </Command>
  <Command __id="5760" _type="ExceptionCommand" date="Sat Aug 24 15:05:56 EDT 2019" timestamp="97879605" type="Exception">
    <exceptionString><![CDATA[Clearing project database
Clearing bulk assignment folder
D:/dewan_backup/Java/Grader/Test Data/Test 110Interp/Assignment1 clearing entries
D:/dewan_backup/Java/Grader/Test Data/Test 110Interp/Assignment1 clearing entries
D:/dewan_backup/Java/Grader/./log/AssignmentsData/Comp110Interp/Assignment1 clearing entries
W***Time(1566673556481, 15:5:56) Received notification(s) for unknown (possibly invisible or unrecognized atomic-shape) property: CleanSlateAll of object: grader.settings.AGraderSettingsModel@1da25c85. Ignoring notification.
Read spreadsheet table of size:8 from d:/dewan_backup/java/grader/test data/test 110interp/assignment1/grades.csv
java.io.FileNotFoundException: D:\dewan_backup\Java\Grader\.\log\AssignmentsData\Comp110Interp\Assignment1\dewan_FeatureGrades.csv (The system cannot find the file specified)
	at java.io.FileInputStream.open0(Native Method)
	at java.io.FileInputStream.open(FileInputStream.java:195)
	at java.io.FileInputStream.<init>(FileInputStream.java:138)
	at grader.file.filesystem.AFileSystemFileProxy.getInputStream(AFileSystemFileProxy.java:88)
	at grader.spreadsheet.csv.ASakaiCSVFinalGradeManager.createTable(ASakaiCSVFinalGradeManager.java:132)
	at grader.spreadsheet.csv.ASakaiCSVFeatureGradeManager.createTable(ASakaiCSVFeatureGradeManager.java:85)
	at grader.spreadsheet.csv.ASakaiCSVFinalGradeManager.propertyChange(ASakaiCSVFinalGradeManager.java:493)
	at java.beans.PropertyChangeSupport.fire(PropertyChangeSupport.java:335)
	at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:327)
	at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:263)
	at grader.settings.AGraderSettingsModel.cleanSlateAll(AGraderSettingsModel.java:788)
	at demoAndTest.multiparadigm.C.ACMixedArithmeticGraderDemoerAndTester.initializeProblem(ACMixedArithmeticGraderDemoerAndTester.java:121)
	at demoAndTest.multiparadigm.C.ACMixedArithmeticGraderDemoerAndTester.doSteps(ACMixedArithmeticGraderDemoerAndTester.java:63)
	at demoAndTest.basic.AJavaPalindromeBasedGraderDemoerAndTester.demoAndTest(AJavaPalindromeBasedGraderDemoerAndTester.java:122)
	at demoAndTest.interpretedSpec.java.AJavaMixedArithmeticIntrepretedInputGraderTester.main(AJavaMixedArithmeticIntrepretedInputGraderTester.java:17)
java.lang.NullPointerException
	at java.io.Reader.<init>(Reader.java:78)
	at java.io.InputStreamReader.<init>(InputStreamReader.java:72)
	at grader.spreadsheet.csv.ASakaiCSVFinalGradeManager.createTable(ASakaiCSVFinalGradeManager.java:133)
	at grader.spreadsheet.csv.ASakaiCSVFeatureGradeManager.createTable(ASakaiCSVFeatureGradeManager.java:85)
	at grader.spreadsheet.csv.ASakaiCSVFinalGradeManager.propertyChange(ASakaiCSVFinalGradeManager.java:493)
]]></exceptionString>
  </Command>
  <Command __id="5761" _type="EHExceptionCommand" date="Sat Aug 24 15:05:56 EDT 2019" timestamp="97879668" type="Exception">
    <outputString><![CDATA[	at java.beans.PropertyChangeSupport.fire(PropertyChangeSupport.java:335)
	at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:327)
	at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:263)
	at grader.settings.AGraderSettingsModel.cleanSlateAll(AGraderSettingsModel.java:788)
	at demoAndTest.multiparadigm.C.ACMixedArithmeticGraderDemoerAndTester.initializeProblem(ACMixedArithmeticGraderDemoerAndTester.java:121)
	at demoAndTest.multiparadigm.C.ACMixedArithmeticGraderDemoerAndTester.doSteps(ACMixedArithmeticGraderDemoerAndTester.java:63)
	at demoAndTest.basic.AJavaPalindromeBasedGraderDemoerAndTester.demoAndTest(AJavaPalindromeBasedGraderDemoerAndTester.java:122)
	at demoAndTest.interpretedSpec.java.AJavaMixedArithmeticIntrepretedInputGraderTester.main(AJavaMixedArithmeticIntrepretedInputGraderTester.java:17)
]]></outputString>
  </Command>
  <Command __id="5762" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.StepReturn" date="Sat Aug 24 15:05:59 EDT 2019" timestamp="97882977" />
  <Command __id="5763" _type="RunCommand" date="Sat Aug 24 15:05:59 EDT 2019" kind="StepInto" projectName="(Unknown)" timestamp="97882982" type="Run" />
  <Command __id="5764" _type="ExceptionCommand" date="Sat Aug 24 15:06:00 EDT 2019" timestamp="97883149" type="Exception">
    <exceptionString><![CDATA[Exception in thread "main" java.lang.NullPointerException
	at grader.spreadsheet.csv.ASakaiCSVFeatureGradeManager.createTable(ASakaiCSVFeatureGradeManager.java:88)
	at grader.spreadsheet.csv.ASakaiCSVFinalGradeManager.propertyChange(ASakaiCSVFinalGradeManager.java:493)
	at java.beans.PropertyChangeSupport.fire(PropertyChangeSupport.java:335)
	at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:327)
	at java.beans.PropertyChangeSupport.firePropertyChange(PropertyChangeSupport.java:263)
	at grader.settings.AGraderSettingsModel.cleanSlateAll(AGraderSettingsModel.java:788)
	at demoAndTest.multiparadigm.C.ACMixedArithmeticGraderDemoerAndTester.initializeProblem(ACMixedArithmeticGraderDemoerAndTester.java:121)
	at demoAndTest.multiparadigm.C.ACMixedArithmeticGraderDemoerAndTester.doSteps(ACMixedArithmeticGraderDemoerAndTester.java:63)
	at demoAndTest.basic.AJavaPalindromeBasedGraderDemoerAndTester.demoAndTest(AJavaPalindromeBasedGraderDemoerAndTester.java:122)
	at demoAndTest.interpretedSpec.java.AJavaMixedArithmeticIntrepretedInputGraderTester.main(AJavaMixedArithmeticIntrepretedInputGraderTester.java:17)
]]></exceptionString>
  </Command>
  <Command __id="5765" _type="RunCommand" date="Sat Aug 24 15:06:20 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="97904000" type="Debug" />
  <Command __id="5766" _type="RunCommand" date="Sat Aug 24 15:06:20 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="97904000" type="Debug" />
  <Command __id="5767" _type="RunCommand" date="Sat Aug 24 15:06:20 EDT 2019" kind="HitBreakPoint" projectName="comp110-grader" timestamp="97904000" type="Run" />
  <Command __id="5768" _type="ShellCommand" date="Sat Aug 24 15:06:27 EDT 2019" timestamp="97910419" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5769" _type="ShellCommand" date="Sat Aug 24 15:06:36 EDT 2019" timestamp="97919116" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5770" _type="EclipseCommand" commandID="org.eclipse.search.ui.openFileSearchPage" date="Sat Aug 24 15:06:36 EDT 2019" timestamp="97919166" />
  <Command __id="5772" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 15:06:59 EDT 2019" docOffset="0" timestamp="97942199" />
  <Command __id="5774" _type="SelectTextCommand" caretOffset="602" date="Sat Aug 24 15:07:14 EDT 2019" end="602" start="549" timestamp="97957904" />
  <Command __id="5776" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 15:08:55 EDT 2019" docOffset="0" timestamp="98058873" />
  <Command __id="5777" _type="MoveCaretCommand" caretOffset="375" date="Sat Aug 24 15:09:07 EDT 2019" docOffset="375" timestamp="98070567" />
  <Command __id="5778" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:09:09 EDT 2019" timestamp="98072264" />
  <Command __id="5780" _type="SelectTextCommand" caretOffset="35818" date="Sat Aug 24 15:09:12 EDT 2019" end="35818" start="35789" timestamp="98075984" />
  <Command __id="5781" _type="MoveCaretCommand" caretOffset="35819" date="Sat Aug 24 15:11:48 EDT 2019" docOffset="40856" timestamp="98231281" />
  <Command __id="5782" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:11:49 EDT 2019" timestamp="98232441" />
  <Command __id="5783" _type="MoveCaretCommand" caretOffset="892" date="Sat Aug 24 15:11:52 EDT 2019" docOffset="5929" timestamp="98235291" />
  <Command __id="5784" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.type.hierarchy" date="Sat Aug 24 15:11:56 EDT 2019" timestamp="98239253" />
  <Command __id="5786" _type="SelectTextCommand" caretOffset="132" date="Sat Aug 24 15:11:58 EDT 2019" end="132" start="111" timestamp="98241143" />
  <Command __id="5787" _type="SelectTextCommand" caretOffset="361" date="Sat Aug 24 15:12:12 EDT 2019" end="361" start="345" timestamp="98256051" />
  <Command __id="5788" _type="CopyCommand" date="Sat Aug 24 15:12:13 EDT 2019" timestamp="98257066" />
  <Command __id="5789" _type="ShellCommand" date="Sat Aug 24 15:12:25 EDT 2019" timestamp="98268183" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5790" _type="ShellCommand" date="Sat Aug 24 15:12:25 EDT 2019" timestamp="98268339" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5791" _type="ShellCommand" date="Sat Aug 24 15:12:34 EDT 2019" timestamp="98277526" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5792" _type="ShellCommand" date="Sat Aug 24 15:12:34 EDT 2019" timestamp="98277678" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5793" _type="ShellCommand" date="Sat Aug 24 15:12:45 EDT 2019" timestamp="98288376" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5794" _type="PasteCommand" date="Sat Aug 24 15:12:49 EDT 2019" timestamp="98292375" />
  <Command __id="5795" _type="PasteCommand" date="Sat Aug 24 15:13:00 EDT 2019" timestamp="98303203" />
  <Command __id="5796" _type="ShellCommand" date="Sat Aug 24 15:13:08 EDT 2019" timestamp="98312017" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5797" _type="EclipseCommand" commandID="org.eclipse.search.ui.openFileSearchPage" date="Sat Aug 24 15:13:08 EDT 2019" timestamp="98312067" />
  <Command __id="5799" _type="ShellCommand" date="Sat Aug 24 15:17:07 EDT 2019" timestamp="98550426" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5800" _type="ShellCommand" date="Sat Aug 24 15:17:51 EDT 2019" timestamp="98594935" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5803" _type="SelectTextCommand" caretOffset="361" date="Sat Aug 24 15:18:43 EDT 2019" end="361" start="345" timestamp="98646680" />
  <Command __id="5804" _type="MoveCaretCommand" caretOffset="305" date="Sat Aug 24 15:18:45 EDT 2019" docOffset="1499" timestamp="98648861" />
  <Command __id="5805" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:18:49 EDT 2019" timestamp="98652152" />
  <Command __id="5806" _type="MoveCaretCommand" caretOffset="1258" date="Sat Aug 24 15:18:59 EDT 2019" docOffset="2452" timestamp="98663027" />
  <Command __id="5807" _type="PredictionCommand" date="Sat Aug 24 15:18:59 EDT 2019" prediction_type="MakingProgress" timestamp="98663048" />
  <Command __id="5808" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:19:01 EDT 2019" timestamp="98664841" />
  <Command __id="5809" _type="MoveCaretCommand" caretOffset="8654" date="Sat Aug 24 15:19:18 EDT 2019" docOffset="9848" timestamp="98681360" />
  <Command __id="5810" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:19:19 EDT 2019" timestamp="98682821" />
  <Command __id="5811" _type="MoveCaretCommand" caretOffset="16492" date="Sat Aug 24 15:19:26 EDT 2019" docOffset="17686" timestamp="98689737" />
  <Command __id="5812" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:19:27 EDT 2019" timestamp="98690966" />
  <Command __id="5813" _type="MoveCaretCommand" caretOffset="16723" date="Sat Aug 24 15:19:32 EDT 2019" docOffset="17917" timestamp="98695625" />
  <Command __id="5814" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:19:34 EDT 2019" timestamp="98697270" />
  <Command __id="5815" _type="MoveCaretCommand" caretOffset="8628" date="Sat Aug 24 15:20:38 EDT 2019" docOffset="9822" timestamp="98761694" />
  <Command __id="5817" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:20:43 EDT 2019" timestamp="98766996" />
  <Command __id="5818" _type="SelectTextCommand" caretOffset="4123" date="Sat Aug 24 15:20:44 EDT 2019" end="4123" start="4098" timestamp="98767081" />
  <Command __id="5819" _type="MoveCaretCommand" caretOffset="4168" date="Sat Aug 24 15:20:54 EDT 2019" docOffset="4373" timestamp="98777763" />
  <Command __id="5821" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:20:56 EDT 2019" timestamp="98779204" />
  <Command __id="5822" _type="SelectTextCommand" caretOffset="110" date="Sat Aug 24 15:20:56 EDT 2019" end="110" start="95" timestamp="98779271" />
  <Command __id="5824" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sat Aug 24 15:20:58 EDT 2019" timestamp="98782011" />
  <Command __id="5825" _type="MoveCaretCommand" caretOffset="4168" date="Sat Aug 24 15:20:58 EDT 2019" docOffset="4373" timestamp="98782069" />
  <Command __id="5827" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sat Aug 24 15:21:03 EDT 2019" timestamp="98786101" />
  <Command __id="5828" _type="MoveCaretCommand" caretOffset="8628" date="Sat Aug 24 15:21:03 EDT 2019" docOffset="9822" timestamp="98786164" />
  <Command __id="5829" _type="ShellCommand" date="Sat Aug 24 15:51:30 EDT 2019" timestamp="100613094" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5830" _type="ShellCommand" date="Sat Aug 24 15:54:04 EDT 2019" timestamp="100767897" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5831" _type="ShellCommand" date="Sat Aug 24 15:54:08 EDT 2019" timestamp="100772049" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5832" _type="ShellCommand" date="Sat Aug 24 15:54:21 EDT 2019" timestamp="100784384" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5834" _type="MoveCaretCommand" caretOffset="375" date="Sat Aug 24 15:55:01 EDT 2019" docOffset="375" timestamp="100824562" />
  <Command __id="5835" _type="MoveCaretCommand" caretOffset="1810" date="Sat Aug 24 15:55:46 EDT 2019" docOffset="1810" timestamp="100869772" />
  <Command __id="5836" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:55:48 EDT 2019" timestamp="100871166" />
  <Command __id="5837" _type="MoveCaretCommand" caretOffset="1504" date="Sat Aug 24 15:57:14 EDT 2019" docOffset="1721" timestamp="100957179" />
  <Command __id="5838" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:57:15 EDT 2019" timestamp="100958090" />
  <Command __id="5839" _type="MoveCaretCommand" caretOffset="1834" date="Sat Aug 24 15:57:18 EDT 2019" docOffset="2051" timestamp="100961753" />
  <Command __id="5840" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:57:19 EDT 2019" timestamp="100962407" />
  <Command __id="5841" _type="MoveCaretCommand" caretOffset="1077" date="Sat Aug 24 15:57:29 EDT 2019" docOffset="1294" timestamp="100972533" />
  <Command __id="5842" _type="InsertStringCommand" date="Sat Aug 24 15:57:30 EDT 2019" timestamp="100973945" timestamp2="100973945">
    <data><![CDATA[g]]></data>
  </Command>
  <Command __id="5843" _type="MoveCaretCommand" caretOffset="1307" date="Sat Aug 24 15:57:33 EDT 2019" docOffset="1524" timestamp="100976663" />
  <Command __id="5844" _type="MoveCaretCommand" caretOffset="1077" date="Sat Aug 24 15:58:15 EDT 2019" docOffset="1294" timestamp="101018885" />
  <Command __id="5845" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:58:17 EDT 2019" timestamp="101020406" />
  <Command __id="5846" _type="MoveCaretCommand" caretOffset="1038" date="Sat Aug 24 15:58:20 EDT 2019" docOffset="1255" timestamp="101023997" />
  <Command __id="5848" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.toggle.comment" date="Sat Aug 24 15:58:21 EDT 2019" timestamp="101025028" />
  <Command __id="5849" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Aug 24 15:58:22 EDT 2019" timestamp="101025912" />
  <Command __id="5850" _type="ShellCommand" date="Sat Aug 24 15:58:26 EDT 2019" timestamp="101029949" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="5851" _type="ShellCommand" date="Sat Aug 24 15:58:28 EDT 2019" timestamp="101031722" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="5852" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 15:58:28 EDT 2019" timestamp="101031739" />
  <Command __id="5863" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.organize.imports" date="Sat Aug 24 15:58:31 EDT 2019" timestamp="101034494" />
  <Command __id="5864" _type="MoveCaretCommand" caretOffset="1665" date="Sat Aug 24 15:58:52 EDT 2019" docOffset="1665" timestamp="101055403" />
  <Command __id="5865" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:58:53 EDT 2019" timestamp="101056720" />
  <Command __id="5866" _type="MoveCaretCommand" caretOffset="1995" date="Sat Aug 24 15:58:55 EDT 2019" docOffset="1995" timestamp="101058202" />
  <Command __id="5867" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:58:56 EDT 2019" timestamp="101059088" />
  <Command __id="5868" _type="MoveCaretCommand" caretOffset="2214" date="Sat Aug 24 15:59:04 EDT 2019" docOffset="2214" timestamp="101067931" />
  <Command __id="5869" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 15:59:06 EDT 2019" timestamp="101069098" />
  <Command __id="5879" _type="FileOpenCommand" date="Sat Aug 24 16:02:04 EDT 2019" docASTNodeCount="8" docActiveCodeLength="62" docExpressionCount="4" docLength="62" projectName="GraderBasics" timestamp="101247778">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\utils\CSVReader.java]]></filePath>
    <snapshot><![CDATA[package gradingTools.utils;

public class CSVReader {

}
]]></snapshot>
  </Command>
  <Command __id="5881" _type="FileOpenCommand" date="Sat Aug 24 16:02:09 EDT 2019" projectName="null" timestamp="101252491">
    <filePath><![CDATA[null]]></filePath>
  </Command>
  <Command __id="5885" _type="FileOpenCommand" date="Sat Aug 24 16:02:26 EDT 2019" docASTNodeCount="8" docActiveCodeLength="62" docExpressionCount="4" docLength="62" projectName="GraderBasics" timestamp="101269341">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\utils\CSVReader.java]]></filePath>
  </Command>
  <DocumentChange __id="5888" _type="Replace" date="Sat Aug 24 16:02:31 EDT 2019" docASTNodeCount="565" docActiveCodeLength="4424" docExpressionCount="329" docLength="9436" endLine="4" insertionLength="9403" int_docASTNodeCount="5" int_docActiveCodeLength="33" int_docExpressionCount="3" int_docLength="33" length="29" offset="31" startLine="2" timestamp="101274512">
    <deletedText><![CDATA[public class CSVReader {

}]]></deletedText>
    <insertedText><![CDATA[Copyright 2005 Bytecode Pty Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

/**
* A very simple CSV reader released under a commercial-friendly license.
* 
* @author Glen Smith
* 
*/
public class CSVReader implements Closeable {

   private BufferedReader br;

   private boolean hasNext = true;

   private CSVParser parser;
   
   private int skipLines;

   private boolean linesSkiped;

   /**
    * The default line to start reading.
    */
   public static final int DEFAULT_SKIP_LINES = 0;

   /**
    * Constructs CSVReader using a comma for the separator.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    */
   public CSVReader(Reader reader) {
       this(reader, CSVParser.DEFAULT_SEPARATOR, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
   }

   /**
    * Constructs CSVReader with supplied separator.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries.
    */
   public CSVReader(Reader reader, char separator) {
       this(reader, separator, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
   }

   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    */
   public CSVReader(Reader reader, char separator, char quotechar) {
       this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
   }

   /**
    * Constructs CSVReader with supplied separator, quote char and quote handling
    * behavior.
    *
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param strictQuotes
    *            sets if characters outside the quotes are ignored
    */
   public CSVReader(Reader reader, char separator, char quotechar, boolean strictQuotes) {
       this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, strictQuotes);
   }

  /**
    * Constructs CSVReader with supplied separator and quote char.
    *
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    */

   public CSVReader(Reader reader, char separator,
			char quotechar, char escape) {
       this(reader, separator, quotechar, escape, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
	}
   
   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param line
    *            the line number to skip for start reading 
    */
   public CSVReader(Reader reader, char separator, char quotechar, int line) {
       this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, line, CSVParser.DEFAULT_STRICT_QUOTES);
   }

   /**
    * Constructs CSVReader with supplied separator and quote char.
    *
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    * @param line
    *            the line number to skip for start reading
    */
   public CSVReader(Reader reader, char separator, char quotechar, char escape, int line) {
       this(reader, separator, quotechar, escape, line, CSVParser.DEFAULT_STRICT_QUOTES);
   }
   
   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    * @param line
    *            the line number to skip for start reading
    * @param strictQuotes
    *            sets if characters outside the quotes are ignored
    */
   public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes) {
       this(reader, separator, quotechar, escape, line, strictQuotes, CSVParser.DEFAULT_IGNORE_LEADING_WHITESPACE);
   }

   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    * @param line
    *            the line number to skip for start reading
    * @param strictQuotes
    *            sets if characters outside the quotes are ignored
    * @param ignoreLeadingWhiteSpace
    *            it true, parser should ignore white space before a quote in a field
    */
   public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes, boolean ignoreLeadingWhiteSpace) {
       this.br = new BufferedReader(reader);
       this.parser = new CSVParser(separator, quotechar, escape, strictQuotes, ignoreLeadingWhiteSpace);
       this.skipLines = line;
   }

  /**
    * Reads the entire file into a List with each element being a String[] of
    * tokens.
    * 
    * @return a List of String[], with each String[] representing a line of the
    *         file.
    * 
    * @throws IOException
    *             if bad things happen during the read
    */
   public List<String[]> readAll() throws IOException {

       List<String[]> allElements = new ArrayList<String[]>();
       while (hasNext) {
           String[] nextLineAsTokens = readNext();
           if (nextLineAsTokens != null)
               allElements.add(nextLineAsTokens);
       }
       return allElements;

   }

   /**
    * Reads the next line from the buffer and converts to a string array.
    * 
    * @return a string array with each comma-separated element as a separate
    *         entry.
    * 
    * @throws IOException
    *             if bad things happen during the read
    */
   public String[] readNext() throws IOException {
   	
   	String[] result = null;
   	do {
   		String nextLine = getNextLine();
   		if (!hasNext) {
   			return result; // should throw if still pending?
   		}
   		String[] r = parser.parseLineMulti(nextLine);
   		if (r.length > 0) {
   			if (result == null) {
   				result = r;
   			} else {
   				String[] t = new String[result.length+r.length];
   				System.arraycopy(result, 0, t, 0, result.length);
   				System.arraycopy(r, 0, t, result.length, r.length);
   				result = t;
   			}
   		}
   	} while (parser.isPending());
   	return result;
   }

   /**
    * Reads the next line from the file.
    * 
    * @return the next line from the file without trailing newline
    * @throws IOException
    *             if bad things happen during the read
    */
   private String getNextLine() throws IOException {
   	if (!this.linesSkiped) {
           for (int i = 0; i < skipLines; i++) {
               br.readLine();
           }
           this.linesSkiped = true;
       }
       String nextLine = br.readLine();
       if (nextLine == null) {
           hasNext = false;
       }
       return hasNext ? nextLine : null;
   }

   /**
    * Closes the underlying reader.
    * 
    * @throws IOException if the close fails
    */
   public void close() throws IOException{
   	br.close();
   }]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="5890" _type="Insert" date="Sat Aug 24 16:02:33 EDT 2019" docASTNodeCount="565" docActiveCodeLength="4429" docExpressionCount="329" docLength="9441" length="5" offset="9434" timestamp="101276717">
    <text><![CDATA[
   ]]></text>
  </DocumentChange>
  <DocumentChange __id="5892" _type="Replace" date="Sat Aug 24 16:02:34 EDT 2019" docASTNodeCount="565" docActiveCodeLength="4427" docExpressionCount="329" docLength="9439" endLine="279" insertionLength="1" int_docASTNodeCount="565" int_docActiveCodeLength="4426" int_docExpressionCount="329" int_docLength="9438" length="3" offset="9436" startLine="279" timestamp="101277678">
    <deletedText><![CDATA[   ]]></deletedText>
    <insertedText><![CDATA[}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="5894" _type="Replace" date="Sat Aug 24 16:02:43 EDT 2019" docASTNodeCount="565" docActiveCodeLength="4429" docExpressionCount="329" docLength="9441" endLine="279" insertionLength="3" int_docASTNodeCount="565" int_docActiveCodeLength="4426" int_docExpressionCount="329" int_docLength="9438" length="1" offset="9436" startLine="279" timestamp="101286242">
    <deletedText><![CDATA[}]]></deletedText>
    <insertedText><![CDATA[   ]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="5896" _type="Delete" date="Sat Aug 24 16:02:44 EDT 2019" docASTNodeCount="565" docActiveCodeLength="4424" docExpressionCount="329" docLength="9436" endLine="279" length="5" offset="9434" startLine="278" timestamp="101287402">
    <text><![CDATA[
   ]]></text>
  </DocumentChange>
  <DocumentChange __id="5898" _type="Replace" date="Sat Aug 24 16:02:45 EDT 2019" docASTNodeCount="8" docActiveCodeLength="62" docExpressionCount="4" docLength="62" endLine="278" insertionLength="29" int_docASTNodeCount="5" int_docActiveCodeLength="33" int_docExpressionCount="3" int_docLength="33" length="9403" offset="31" startLine="2" timestamp="101288081">
    <deletedText><![CDATA[Copyright 2005 Bytecode Pty Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

/**
* A very simple CSV reader released under a commercial-friendly license.
* 
* @author Glen Smith
* 
*/
public class CSVReader implements Closeable {

   private BufferedReader br;

   private boolean hasNext = true;

   private CSVParser parser;
   
   private int skipLines;

   private boolean linesSkiped;

   /**
    * The default line to start reading.
    */
   public static final int DEFAULT_SKIP_LINES = 0;

   /**
    * Constructs CSVReader using a comma for the separator.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    */
   public CSVReader(Reader reader) {
       this(reader, CSVParser.DEFAULT_SEPARATOR, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
   }

   /**
    * Constructs CSVReader with supplied separator.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries.
    */
   public CSVReader(Reader reader, char separator) {
       this(reader, separator, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
   }

   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    */
   public CSVReader(Reader reader, char separator, char quotechar) {
       this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
   }

   /**
    * Constructs CSVReader with supplied separator, quote char and quote handling
    * behavior.
    *
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param strictQuotes
    *            sets if characters outside the quotes are ignored
    */
   public CSVReader(Reader reader, char separator, char quotechar, boolean strictQuotes) {
       this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, strictQuotes);
   }

  /**
    * Constructs CSVReader with supplied separator and quote char.
    *
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    */

   public CSVReader(Reader reader, char separator,
			char quotechar, char escape) {
       this(reader, separator, quotechar, escape, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
	}
   
   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param line
    *            the line number to skip for start reading 
    */
   public CSVReader(Reader reader, char separator, char quotechar, int line) {
       this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, line, CSVParser.DEFAULT_STRICT_QUOTES);
   }

   /**
    * Constructs CSVReader with supplied separator and quote char.
    *
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    * @param line
    *            the line number to skip for start reading
    */
   public CSVReader(Reader reader, char separator, char quotechar, char escape, int line) {
       this(reader, separator, quotechar, escape, line, CSVParser.DEFAULT_STRICT_QUOTES);
   }
   
   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    * @param line
    *            the line number to skip for start reading
    * @param strictQuotes
    *            sets if characters outside the quotes are ignored
    */
   public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes) {
       this(reader, separator, quotechar, escape, line, strictQuotes, CSVParser.DEFAULT_IGNORE_LEADING_WHITESPACE);
   }

   /**
    * Constructs CSVReader with supplied separator and quote char.
    * 
    * @param reader
    *            the reader to an underlying CSV source.
    * @param separator
    *            the delimiter to use for separating entries
    * @param quotechar
    *            the character to use for quoted elements
    * @param escape
    *            the character to use for escaping a separator or quote
    * @param line
    *            the line number to skip for start reading
    * @param strictQuotes
    *            sets if characters outside the quotes are ignored
    * @param ignoreLeadingWhiteSpace
    *            it true, parser should ignore white space before a quote in a field
    */
   public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes, boolean ignoreLeadingWhiteSpace) {
       this.br = new BufferedReader(reader);
       this.parser = new CSVParser(separator, quotechar, escape, strictQuotes, ignoreLeadingWhiteSpace);
       this.skipLines = line;
   }

  /**
    * Reads the entire file into a List with each element being a String[] of
    * tokens.
    * 
    * @return a List of String[], with each String[] representing a line of the
    *         file.
    * 
    * @throws IOException
    *             if bad things happen during the read
    */
   public List<String[]> readAll() throws IOException {

       List<String[]> allElements = new ArrayList<String[]>();
       while (hasNext) {
           String[] nextLineAsTokens = readNext();
           if (nextLineAsTokens != null)
               allElements.add(nextLineAsTokens);
       }
       return allElements;

   }

   /**
    * Reads the next line from the buffer and converts to a string array.
    * 
    * @return a string array with each comma-separated element as a separate
    *         entry.
    * 
    * @throws IOException
    *             if bad things happen during the read
    */
   public String[] readNext() throws IOException {
   	
   	String[] result = null;
   	do {
   		String nextLine = getNextLine();
   		if (!hasNext) {
   			return result; // should throw if still pending?
   		}
   		String[] r = parser.parseLineMulti(nextLine);
   		if (r.length > 0) {
   			if (result == null) {
   				result = r;
   			} else {
   				String[] t = new String[result.length+r.length];
   				System.arraycopy(result, 0, t, 0, result.length);
   				System.arraycopy(r, 0, t, result.length, r.length);
   				result = t;
   			}
   		}
   	} while (parser.isPending());
   	return result;
   }

   /**
    * Reads the next line from the file.
    * 
    * @return the next line from the file without trailing newline
    * @throws IOException
    *             if bad things happen during the read
    */
   private String getNextLine() throws IOException {
   	if (!this.linesSkiped) {
           for (int i = 0; i < skipLines; i++) {
               br.readLine();
           }
           this.linesSkiped = true;
       }
       String nextLine = br.readLine();
       if (nextLine == null) {
           hasNext = false;
       }
       return hasNext ? nextLine : null;
   }

   /**
    * Closes the underlying reader.
    * 
    * @throws IOException if the close fails
    */
   public void close() throws IOException{
   	br.close();
   }]]></deletedText>
    <insertedText><![CDATA[public class CSVReader {

}]]></insertedText>
  </DocumentChange>
  <Command __id="5900" _type="FileOpenCommand" date="Sat Aug 24 16:02:47 EDT 2019" projectName="null" timestamp="101290509">
    <filePath><![CDATA[null]]></filePath>
  </Command>
  <Command __id="5905" _type="FileOpenCommand" date="Sat Aug 24 16:03:06 EDT 2019" docASTNodeCount="8" docActiveCodeLength="62" docExpressionCount="4" docLength="62" projectName="GraderBasics" timestamp="101309522">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\utils\CSVReader.java]]></filePath>
  </Command>
  <DocumentChange __id="5909" _type="Replace" date="Sat Aug 24 16:03:10 EDT 2019" docASTNodeCount="565" docActiveCodeLength="4001" docExpressionCount="329" docLength="9695" endLine="4" insertionLength="9662" int_docASTNodeCount="5" int_docActiveCodeLength="33" int_docExpressionCount="3" int_docLength="33" length="29" offset="31" startLine="2" timestamp="101313371">
    <deletedText><![CDATA[public class CSVReader {

}]]></deletedText>
    <insertedText><![CDATA[
/**
 Copyright 2005 Bytecode Pty Ltd.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

/**
 * A very simple CSV reader released under a commercial-friendly license.
 * 
 * @author Glen Smith
 * 
 */
public class CSVReader implements Closeable {

    private BufferedReader br;

    private boolean hasNext = true;

    private CSVParser parser;
    
    private int skipLines;

    private boolean linesSkiped;

    /**
     * The default line to start reading.
     */
    public static final int DEFAULT_SKIP_LINES = 0;

    /**
     * Constructs CSVReader using a comma for the separator.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     */
    public CSVReader(Reader reader) {
        this(reader, CSVParser.DEFAULT_SEPARATOR, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
    }

    /**
     * Constructs CSVReader with supplied separator.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries.
     */
    public CSVReader(Reader reader, char separator) {
        this(reader, separator, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
    }

    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     */
    public CSVReader(Reader reader, char separator, char quotechar) {
        this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
    }

    /**
     * Constructs CSVReader with supplied separator, quote char and quote handling
     * behavior.
     *
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param strictQuotes
     *            sets if characters outside the quotes are ignored
     */
    public CSVReader(Reader reader, char separator, char quotechar, boolean strictQuotes) {
        this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, strictQuotes);
    }

   /**
     * Constructs CSVReader with supplied separator and quote char.
     *
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     */

    public CSVReader(Reader reader, char separator,
			char quotechar, char escape) {
        this(reader, separator, quotechar, escape, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
	}
    
    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param line
     *            the line number to skip for start reading 
     */
    public CSVReader(Reader reader, char separator, char quotechar, int line) {
        this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, line, CSVParser.DEFAULT_STRICT_QUOTES);
    }

    /**
     * Constructs CSVReader with supplied separator and quote char.
     *
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     * @param line
     *            the line number to skip for start reading
     */
    public CSVReader(Reader reader, char separator, char quotechar, char escape, int line) {
        this(reader, separator, quotechar, escape, line, CSVParser.DEFAULT_STRICT_QUOTES);
    }
    
    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     * @param line
     *            the line number to skip for start reading
     * @param strictQuotes
     *            sets if characters outside the quotes are ignored
     */
    public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes) {
        this(reader, separator, quotechar, escape, line, strictQuotes, CSVParser.DEFAULT_IGNORE_LEADING_WHITESPACE);
    }

    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     * @param line
     *            the line number to skip for start reading
     * @param strictQuotes
     *            sets if characters outside the quotes are ignored
     * @param ignoreLeadingWhiteSpace
     *            it true, parser should ignore white space before a quote in a field
     */
    public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes, boolean ignoreLeadingWhiteSpace) {
        this.br = new BufferedReader(reader);
        this.parser = new CSVParser(separator, quotechar, escape, strictQuotes, ignoreLeadingWhiteSpace);
        this.skipLines = line;
    }

   /**
     * Reads the entire file into a List with each element being a String[] of
     * tokens.
     * 
     * @return a List of String[], with each String[] representing a line of the
     *         file.
     * 
     * @throws IOException
     *             if bad things happen during the read
     */
    public List<String[]> readAll() throws IOException {

        List<String[]> allElements = new ArrayList<String[]>();
        while (hasNext) {
            String[] nextLineAsTokens = readNext();
            if (nextLineAsTokens != null)
                allElements.add(nextLineAsTokens);
        }
        return allElements;

    }

    /**
     * Reads the next line from the buffer and converts to a string array.
     * 
     * @return a string array with each comma-separated element as a separate
     *         entry.
     * 
     * @throws IOException
     *             if bad things happen during the read
     */
    public String[] readNext() throws IOException {
    	
    	String[] result = null;
    	do {
    		String nextLine = getNextLine();
    		if (!hasNext) {
    			return result; // should throw if still pending?
    		}
    		String[] r = parser.parseLineMulti(nextLine);
    		if (r.length > 0) {
    			if (result == null) {
    				result = r;
    			} else {
    				String[] t = new String[result.length+r.length];
    				System.arraycopy(result, 0, t, 0, result.length);
    				System.arraycopy(r, 0, t, result.length, r.length);
    				result = t;
    			}
    		}
    	} while (parser.isPending());
    	return result;
    }

    /**
     * Reads the next line from the file.
     * 
     * @return the next line from the file without trailing newline
     * @throws IOException
     *             if bad things happen during the read
     */
    private String getNextLine() throws IOException {
    	if (!this.linesSkiped) {
            for (int i = 0; i < skipLines; i++) {
                br.readLine();
            }
            this.linesSkiped = true;
        }
        String nextLine = br.readLine();
        if (nextLine == null) {
            hasNext = false;
        }
        return hasNext ? nextLine : null;
    }

    /**
     * Closes the underlying reader.
     * 
     * @throws IOException if the close fails
     */
    public void close() throws IOException{
    	br.close();
    }
    
}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="5911" _type="Replace" date="Sat Aug 24 16:03:25 EDT 2019" docASTNodeCount="8" docActiveCodeLength="62" docExpressionCount="4" docLength="62" endLine="282" insertionLength="29" int_docASTNodeCount="5" int_docActiveCodeLength="33" int_docExpressionCount="3" int_docLength="33" length="9662" offset="31" startLine="2" timestamp="101328405">
    <deletedText><![CDATA[
/**
 Copyright 2005 Bytecode Pty Ltd.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

/**
 * A very simple CSV reader released under a commercial-friendly license.
 * 
 * @author Glen Smith
 * 
 */
public class CSVReader implements Closeable {

    private BufferedReader br;

    private boolean hasNext = true;

    private CSVParser parser;
    
    private int skipLines;

    private boolean linesSkiped;

    /**
     * The default line to start reading.
     */
    public static final int DEFAULT_SKIP_LINES = 0;

    /**
     * Constructs CSVReader using a comma for the separator.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     */
    public CSVReader(Reader reader) {
        this(reader, CSVParser.DEFAULT_SEPARATOR, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
    }

    /**
     * Constructs CSVReader with supplied separator.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries.
     */
    public CSVReader(Reader reader, char separator) {
        this(reader, separator, CSVParser.DEFAULT_QUOTE_CHARACTER, CSVParser.DEFAULT_ESCAPE_CHARACTER);
    }

    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     */
    public CSVReader(Reader reader, char separator, char quotechar) {
        this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
    }

    /**
     * Constructs CSVReader with supplied separator, quote char and quote handling
     * behavior.
     *
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param strictQuotes
     *            sets if characters outside the quotes are ignored
     */
    public CSVReader(Reader reader, char separator, char quotechar, boolean strictQuotes) {
        this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, DEFAULT_SKIP_LINES, strictQuotes);
    }

   /**
     * Constructs CSVReader with supplied separator and quote char.
     *
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     */

    public CSVReader(Reader reader, char separator,
			char quotechar, char escape) {
        this(reader, separator, quotechar, escape, DEFAULT_SKIP_LINES, CSVParser.DEFAULT_STRICT_QUOTES);
	}
    
    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param line
     *            the line number to skip for start reading 
     */
    public CSVReader(Reader reader, char separator, char quotechar, int line) {
        this(reader, separator, quotechar, CSVParser.DEFAULT_ESCAPE_CHARACTER, line, CSVParser.DEFAULT_STRICT_QUOTES);
    }

    /**
     * Constructs CSVReader with supplied separator and quote char.
     *
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     * @param line
     *            the line number to skip for start reading
     */
    public CSVReader(Reader reader, char separator, char quotechar, char escape, int line) {
        this(reader, separator, quotechar, escape, line, CSVParser.DEFAULT_STRICT_QUOTES);
    }
    
    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     * @param line
     *            the line number to skip for start reading
     * @param strictQuotes
     *            sets if characters outside the quotes are ignored
     */
    public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes) {
        this(reader, separator, quotechar, escape, line, strictQuotes, CSVParser.DEFAULT_IGNORE_LEADING_WHITESPACE);
    }

    /**
     * Constructs CSVReader with supplied separator and quote char.
     * 
     * @param reader
     *            the reader to an underlying CSV source.
     * @param separator
     *            the delimiter to use for separating entries
     * @param quotechar
     *            the character to use for quoted elements
     * @param escape
     *            the character to use for escaping a separator or quote
     * @param line
     *            the line number to skip for start reading
     * @param strictQuotes
     *            sets if characters outside the quotes are ignored
     * @param ignoreLeadingWhiteSpace
     *            it true, parser should ignore white space before a quote in a field
     */
    public CSVReader(Reader reader, char separator, char quotechar, char escape, int line, boolean strictQuotes, boolean ignoreLeadingWhiteSpace) {
        this.br = new BufferedReader(reader);
        this.parser = new CSVParser(separator, quotechar, escape, strictQuotes, ignoreLeadingWhiteSpace);
        this.skipLines = line;
    }

   /**
     * Reads the entire file into a List with each element being a String[] of
     * tokens.
     * 
     * @return a List of String[], with each String[] representing a line of the
     *         file.
     * 
     * @throws IOException
     *             if bad things happen during the read
     */
    public List<String[]> readAll() throws IOException {

        List<String[]> allElements = new ArrayList<String[]>();
        while (hasNext) {
            String[] nextLineAsTokens = readNext();
            if (nextLineAsTokens != null)
                allElements.add(nextLineAsTokens);
        }
        return allElements;

    }

    /**
     * Reads the next line from the buffer and converts to a string array.
     * 
     * @return a string array with each comma-separated element as a separate
     *         entry.
     * 
     * @throws IOException
     *             if bad things happen during the read
     */
    public String[] readNext() throws IOException {
    	
    	String[] result = null;
    	do {
    		String nextLine = getNextLine();
    		if (!hasNext) {
    			return result; // should throw if still pending?
    		}
    		String[] r = parser.parseLineMulti(nextLine);
    		if (r.length > 0) {
    			if (result == null) {
    				result = r;
    			} else {
    				String[] t = new String[result.length+r.length];
    				System.arraycopy(result, 0, t, 0, result.length);
    				System.arraycopy(r, 0, t, result.length, r.length);
    				result = t;
    			}
    		}
    	} while (parser.isPending());
    	return result;
    }

    /**
     * Reads the next line from the file.
     * 
     * @return the next line from the file without trailing newline
     * @throws IOException
     *             if bad things happen during the read
     */
    private String getNextLine() throws IOException {
    	if (!this.linesSkiped) {
            for (int i = 0; i < skipLines; i++) {
                br.readLine();
            }
            this.linesSkiped = true;
        }
        String nextLine = br.readLine();
        if (nextLine == null) {
            hasNext = false;
        }
        return hasNext ? nextLine : null;
    }

    /**
     * Closes the underlying reader.
     * 
     * @throws IOException if the close fails
     */
    public void close() throws IOException{
    	br.close();
    }
    
}]]></deletedText>
    <insertedText><![CDATA[public class CSVReader {

}]]></insertedText>
  </DocumentChange>
  <Command __id="5913" _type="FileOpenCommand" date="Sat Aug 24 16:03:28 EDT 2019" projectName="null" timestamp="101331765">
    <filePath><![CDATA[null]]></filePath>
  </Command>
  <Command __id="5917" _type="FileOpenCommand" date="Sat Aug 24 16:03:48 EDT 2019" projectName="null" timestamp="101351485">
    <filePath><![CDATA[null]]></filePath>
  </Command>
  <Command __id="5922" _type="FileOpenCommand" date="Sat Aug 24 16:05:36 EDT 2019" docASTNodeCount="1" docActiveCodeLength="4605" docExpressionCount="0" docLength="4605" projectName="comp110-grader" timestamp="101459653">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\pom.xml]]></filePath>
    <snapshot><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>edu.unc</groupId>

    <artifactId>comp110-grader</artifactId>
    <version>1.0</version>


    <dependencies>

        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-io</artifactId>
            <version>1.3.2</version>
        </dependency>

        <dependency>
            <groupId>net.lingala.zip4j</groupId>
            <artifactId>zip4j</artifactId>
            <version>1.3.1</version>
        </dependency>

        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
            <version>2.3</version>
        </dependency>

        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>3.9</version>
        </dependency>

        <dependency>
            <groupId>net.sf.opencsv</groupId>
            <artifactId>opencsv</artifactId>
            <version>2.3</version>
        </dependency>

        <dependency>
            <groupId>org.scala-lang</groupId>
            <artifactId>scala-library</artifactId>
            <version>2.10.3</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
        </dependency>

        <dependency>
            <groupId>com.intellij</groupId>
            <artifactId>forms_rt</artifactId>
            <version>7.0.3</version>
        </dependency>

        <dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-mapper-asl</artifactId>
            <version>1.9.13</version>
        </dependency>

        <dependency>
            <groupId>edu.unc</groupId>
            <artifactId>oeall</artifactId>
            <version>22</version>
        </dependency>

        <dependency>
            <groupId>qdox</groupId>
            <artifactId>qdox</artifactId>
            <version>1.6.1</version>
        </dependency>

        <dependency>
            <groupId>commons-configuration</groupId>
            <artifactId>commons-configuration</artifactId>
            <version>1.9</version>
        </dependency>

        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.2.4</version>
        </dependency>


        <dependency>
            <groupId>com.github.antlrjavaparser</groupId>
            <artifactId>antlr-java-parser</artifactId>
            <version>1.0.17</version>
        </dependency>

        <dependency>
            <groupId>javassist</groupId>
            <artifactId>javassist</artifactId>
            <version>3.12.1.GA</version>
        </dependency>

        <dependency>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-javadoc-plugin</artifactId>
            <version>2.9.1</version>
        </dependency>


    </dependencies>

    <packaging>jar</packaging>

    <build>
        <plugins>

            <plugin>
                <artifactId>maven-assembly-plugin</artifactId>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>gradingTools.Driver</mainClass>
                        </manifest>
                    </archive>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                </configuration>
                <executions>
                    <execution>
                        <id>make-assembly</id> <!-- this is used for inheritance merges -->
                        <phase>package</phase> <!-- bind to the packaging phase -->
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>
</project>
]]></snapshot>
  </Command>
  <Command __id="5923" _type="FileOpenCommand" date="Sat Aug 24 16:06:12 EDT 2019" docASTNodeCount="939" docActiveCodeLength="6458" docExpressionCount="538" docLength="6551" projectName="comp110-grader" timestamp="101495543">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\specification\ACSVRequirementsSpecification.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter.specification;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;

import au.com.bytecode.opencsv.CSVReader;
import grader.file.FileProxy;
import grader.sakai.project.SakaiProjectDatabase;
//import bus.uigen.Message;

public class ACSVRequirementsSpecification implements CSVRequirementsSpecification {
	public static final String TYPE_NAME = "Type";
	public static final int TYPE_COLUMN = 0;
	public static final int DESCRIPTION_COLUMN = TYPE_COLUMN+1;
	public static final int MAX_SCORE_COLUMN = DESCRIPTION_COLUMN + 1;
	public static final  int TIMEOUT_COLUMN = MAX_SCORE_COLUMN + 1;
	public static final  int INPUT_COLUMN = TIMEOUT_COLUMN + 1;
	public static final  int MODEL_OUTPUT_COLUMN = INPUT_COLUMN + 1;
	public static final int EXTRA_CREDIT_COLUMN = MODEL_OUTPUT_COLUMN + 1;
	public static final  int CHECKER_COLUMN = EXTRA_CREDIT_COLUMN  + 1;
	public static final  int START_CHECKER_ARGUMENTS_COLUMN = CHECKER_COLUMN + 1;
	
	protected int headerRow = 0;
	protected int numRequirements;
	FileProxy specificationSpreadsheet; // w
	
	List<String[]>  table;
	protected boolean valid;
//	protected FrameworkProjectRequirements projectRequirements;
  


	public ACSVRequirementsSpecification(FileProxy aSpecificationSpreadsheet) {
		specificationSpreadsheet = aSpecificationSpreadsheet;	
		init();
	}
	
	public ACSVRequirementsSpecification(SakaiProjectDatabase aSakaiProjectDatabase) {
		specificationSpreadsheet = aSakaiProjectDatabase.getAssignmentDataFolder().getRequirementsSpreadsheetFile();
		init();
	}
	
	protected void init() {
		maybeCreateTable();
		headerRow = getHeaderRowNum(table);
		valid = headerRow >= 0;
		makeRequirements();
		

	}
	
	protected void makeRequirements() {
		if (isValid()) {
			numRequirements = table.size() - (headerRow + 1);
			
		}
		
	}
	
	protected void maybeCreateTable() {
		if (table != null)
			return;
		createTable();
		
	}
	
	protected void createTable() {
		
		try {
			InputStream input = specificationSpreadsheet.getInputStream();
			CSVReader csvReader 	=	new CSVReader(new InputStreamReader(input));
		     table = csvReader.readAll();
			csvReader.close();
			input.close();
			
		   
	    
	    
		} catch (Exception e) {
			e.printStackTrace();
		
			
		}
		
	}
	
	
	
	public int getHeaderRowNum(List<String[]> aSheet) {
		 for (int rowNum = 0; rowNum < aSheet.size(); rowNum ++) {
			 String[] aRow = aSheet.get(rowNum);
			 if (aRow[TYPE_COLUMN].equalsIgnoreCase(TYPE_NAME))
				 return rowNum;
		 }
		 return -1;
		
	}
	
	
	
	
	
	public FileProxy getSpecificationSpreadsheet() {
		return specificationSpreadsheet;
	}

	public String getFileName() {
		return specificationSpreadsheet.getMixedCaseAbsoluteName();
	}

	public boolean isValid() {
		return valid;
	}

	public void setValid(boolean newValue) {
		this.valid = newValue;
	}

	public List<String[]> getTable() {
		return table;
	}
	@Override
	public int getNumberOfRequirements() {
		return numRequirements;
	}
	@Override
	public String getArg(int aRequirementNum, int anArgNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		int aColumnNum = START_CHECKER_ARGUMENTS_COLUMN + anArgNum;
		return table.get(aRowNum)[aColumnNum];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have arg " + anArgNum);
			return null;
		}
	}
	public String getType(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[TYPE_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have type ");
			return null;
		}
	}
	
	public String getDescription(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[DESCRIPTION_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have description ");
			return null;
		}
	}
	@Override
	public Double getMaxScore(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return Double.parseDouble(table.get(aRowNum)[MAX_SCORE_COLUMN]);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score");
			return null;
		}
	}
	
	@Override
	public Integer getTimeOut(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		String aTimeOut = table.get(aRowNum)[TIMEOUT_COLUMN];
		if (aTimeOut == null || aTimeOut.isEmpty())
			return null;
		return Integer.parseInt(aTimeOut);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have timeout");
			return null;
		}
	}
	@Override
	public boolean isExtraCredit(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[EXTRA_CREDIT_COLUMN].replaceAll("\\s+", "");
			return !aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have extra credit");
				return false;
			}
	}
	
	
	@Override
	public boolean isManual(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[CHECKER_COLUMN].replaceAll("\\s+", "");
			return aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have checker column");
				return false;
			}
	}

	
	public String getInput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[INPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score ");
			return null;
		}
	}
	public String getModelOutput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[MODEL_OUTPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have model output");
			return null;
		}
	}
	public String getChecker(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[CHECKER_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have a function");
			return null;
		}
	}
	

}
]]></snapshot>
  </Command>
  <DocumentChange __id="5930" _type="Insert" date="Sat Aug 24 16:06:27 EDT 2019" docASTNodeCount="939" docActiveCodeLength="6461" docExpressionCount="538" docLength="6554" length="3" offset="2384" timestamp="101510819">
    <text><![CDATA[
	]]></text>
  </DocumentChange>
  <DocumentChange __id="5932" _type="Replace" date="Sat Aug 24 16:06:28 EDT 2019" docASTNodeCount="990" docActiveCodeLength="6821" docExpressionCount="567" docLength="6914" endLine="86" insertionLength="361" int_docASTNodeCount="939" int_docActiveCodeLength="6460" int_docExpressionCount="538" int_docLength="6553" length="1" offset="2386" startLine="86" timestamp="101511594">
    <deletedText><![CDATA[	]]></deletedText>
    <insertedText><![CDATA[protected void createTable() {
		
		try {
			InputStream input = specificationSpreadsheet.getInputStream();
			CSVReader csvReader 	=	new CSVReader(new InputStreamReader(input));
		     table = csvReader.readAll();
			csvReader.close();
			input.close();
			
		   
	    
	    
		} catch (Exception e) {
			e.printStackTrace();
		
			
		}
		
	}]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="5935" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="988" docActiveCodeLength="6790" docExpressionCount="566" docLength="6916" length="2" offset="2022" timestamp="101522202">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5936" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="988" docActiveCodeLength="6788" docExpressionCount="566" docLength="6918" length="2" offset="2057" timestamp="101522205">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5937" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="972" docActiveCodeLength="6781" docExpressionCount="555" docLength="6920" length="2" offset="2063" timestamp="101522208">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5938" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="964" docActiveCodeLength="6716" docExpressionCount="550" docLength="6922" length="2" offset="2074" timestamp="101522210">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5939" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6646" docExpressionCount="543" docLength="6924" length="2" offset="2143" timestamp="101522213">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5940" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6611" docExpressionCount="543" docLength="6926" length="2" offset="2217" timestamp="101522216">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5941" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6590" docExpressionCount="543" docLength="6928" length="2" offset="2256" timestamp="101522225">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5943" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6573" docExpressionCount="543" docLength="6930" length="2" offset="2281" timestamp="101522228">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5944" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6570" docExpressionCount="543" docLength="6932" length="2" offset="2302" timestamp="101522231">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5945" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6565" docExpressionCount="543" docLength="6934" length="2" offset="2309" timestamp="101522234">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5946" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6560" docExpressionCount="543" docLength="6936" length="2" offset="2318" timestamp="101522237">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5947" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6555" docExpressionCount="543" docLength="6938" length="2" offset="2327" timestamp="101522239">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5948" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6530" docExpressionCount="538" docLength="6940" length="2" offset="2336" timestamp="101522241">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5949" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6507" docExpressionCount="538" docLength="6942" length="2" offset="2365" timestamp="101522243">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5950" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6505" docExpressionCount="538" docLength="6944" length="2" offset="2392" timestamp="101522245">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5951" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6502" docExpressionCount="538" docLength="6946" length="2" offset="2398" timestamp="101522247">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5952" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6499" docExpressionCount="538" docLength="6948" length="2" offset="2405" timestamp="101522250">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5953" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6497" docExpressionCount="538" docLength="6950" length="2" offset="2412" timestamp="101522252">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5954" _type="Insert" date="Sat Aug 24 16:06:39 EDT 2019" docASTNodeCount="939" docActiveCodeLength="6495" docExpressionCount="538" docLength="6952" length="2" offset="2418" timestamp="101522253">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="5956" _type="FileOpenCommand" date="Sat Aug 24 16:06:55 EDT 2019" docASTNodeCount="1" docActiveCodeLength="4605" docExpressionCount="0" docLength="4605" projectName="comp110-grader" timestamp="101538734">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\pom.xml]]></filePath>
  </Command>
  <Command __id="5971" _type="FileOpenCommand" date="Sat Aug 24 16:11:58 EDT 2019" docASTNodeCount="939" docActiveCodeLength="6495" docExpressionCount="538" docLength="6952" projectName="comp110-grader" timestamp="101841436">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\requirements\interpreter\specification\ACSVRequirementsSpecification.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter.specification;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;

import au.com.bytecode.opencsv.CSVReader;
import grader.file.FileProxy;
import grader.sakai.project.SakaiProjectDatabase;
//import bus.uigen.Message;

public class ACSVRequirementsSpecification implements CSVRequirementsSpecification {
	public static final String TYPE_NAME = "Type";
	public static final int TYPE_COLUMN = 0;
	public static final int DESCRIPTION_COLUMN = TYPE_COLUMN+1;
	public static final int MAX_SCORE_COLUMN = DESCRIPTION_COLUMN + 1;
	public static final  int TIMEOUT_COLUMN = MAX_SCORE_COLUMN + 1;
	public static final  int INPUT_COLUMN = TIMEOUT_COLUMN + 1;
	public static final  int MODEL_OUTPUT_COLUMN = INPUT_COLUMN + 1;
	public static final int EXTRA_CREDIT_COLUMN = MODEL_OUTPUT_COLUMN + 1;
	public static final  int CHECKER_COLUMN = EXTRA_CREDIT_COLUMN  + 1;
	public static final  int START_CHECKER_ARGUMENTS_COLUMN = CHECKER_COLUMN + 1;
	
	protected int headerRow = 0;
	protected int numRequirements;
	FileProxy specificationSpreadsheet; // w
	
	List<String[]>  table;
	protected boolean valid;
//	protected FrameworkProjectRequirements projectRequirements;
  


	public ACSVRequirementsSpecification(FileProxy aSpecificationSpreadsheet) {
		specificationSpreadsheet = aSpecificationSpreadsheet;	
		init();
	}
	
	public ACSVRequirementsSpecification(SakaiProjectDatabase aSakaiProjectDatabase) {
		specificationSpreadsheet = aSakaiProjectDatabase.getAssignmentDataFolder().getRequirementsSpreadsheetFile();
		init();
	}
	
	protected void init() {
		maybeCreateTable();
		headerRow = getHeaderRowNum(table);
		valid = headerRow >= 0;
		makeRequirements();
		

	}
	
	protected void makeRequirements() {
		if (isValid()) {
			numRequirements = table.size() - (headerRow + 1);
			
		}
		
	}
	
	protected void maybeCreateTable() {
		if (table != null)
			return;
		createTable();
		
	}
	
//	protected void createTable() {
//		
//		try {
//			InputStream input = specificationSpreadsheet.getInputStream();
//			CSVReader csvReader 	=	new CSVReader(new InputStreamReader(input));
//		     table = csvReader.readAll();
//			csvReader.close();
//			input.close();
//			
//		   
//	    
//	    
//		} catch (Exception e) {
//			e.printStackTrace();
//		
//			
//		}
//		
//	}
protected void createTable() {
		
		try {
			InputStream input = specificationSpreadsheet.getInputStream();
			CSVReader csvReader 	=	new CSVReader(new InputStreamReader(input));
		     table = csvReader.readAll();
			csvReader.close();
			input.close();
			
		   
	    
	    
		} catch (Exception e) {
			e.printStackTrace();
		
			
		}
		
	}
	
	
	
	public int getHeaderRowNum(List<String[]> aSheet) {
		 for (int rowNum = 0; rowNum < aSheet.size(); rowNum ++) {
			 String[] aRow = aSheet.get(rowNum);
			 if (aRow[TYPE_COLUMN].equalsIgnoreCase(TYPE_NAME))
				 return rowNum;
		 }
		 return -1;
		
	}
	
	
	
	
	
	public FileProxy getSpecificationSpreadsheet() {
		return specificationSpreadsheet;
	}

	public String getFileName() {
		return specificationSpreadsheet.getMixedCaseAbsoluteName();
	}

	public boolean isValid() {
		return valid;
	}

	public void setValid(boolean newValue) {
		this.valid = newValue;
	}

	public List<String[]> getTable() {
		return table;
	}
	@Override
	public int getNumberOfRequirements() {
		return numRequirements;
	}
	@Override
	public String getArg(int aRequirementNum, int anArgNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		int aColumnNum = START_CHECKER_ARGUMENTS_COLUMN + anArgNum;
		return table.get(aRowNum)[aColumnNum];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have arg " + anArgNum);
			return null;
		}
	}
	public String getType(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[TYPE_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have type ");
			return null;
		}
	}
	
	public String getDescription(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[DESCRIPTION_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have description ");
			return null;
		}
	}
	@Override
	public Double getMaxScore(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return Double.parseDouble(table.get(aRowNum)[MAX_SCORE_COLUMN]);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score");
			return null;
		}
	}
	
	@Override
	public Integer getTimeOut(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		String aTimeOut = table.get(aRowNum)[TIMEOUT_COLUMN];
		if (aTimeOut == null || aTimeOut.isEmpty())
			return null;
		return Integer.parseInt(aTimeOut);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have timeout");
			return null;
		}
	}
	@Override
	public boolean isExtraCredit(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[EXTRA_CREDIT_COLUMN].replaceAll("\\s+", "");
			return !aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have extra credit");
				return false;
			}
	}
	
	
	@Override
	public boolean isManual(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[CHECKER_COLUMN].replaceAll("\\s+", "");
			return aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have checker column");
				return false;
			}
	}

	
	public String getInput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[INPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score ");
			return null;
		}
	}
	public String getModelOutput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[MODEL_OUTPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have model output");
			return null;
		}
	}
	public String getChecker(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[CHECKER_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have a function");
			return null;
		}
	}
	

}
]]></snapshot>
  </Command>
  <DocumentChange __id="5973" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6497" docExpressionCount="538" docLength="6950" endLine="85" length="2" offset="2418" startLine="85" timestamp="101843188">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5974" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6499" docExpressionCount="538" docLength="6948" endLine="84" length="2" offset="2412" startLine="84" timestamp="101843190">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5975" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6502" docExpressionCount="538" docLength="6946" endLine="83" length="2" offset="2405" startLine="83" timestamp="101843191">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5976" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6505" docExpressionCount="538" docLength="6944" endLine="82" length="2" offset="2398" startLine="82" timestamp="101843193">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5977" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6507" docExpressionCount="538" docLength="6942" endLine="81" length="2" offset="2392" startLine="81" timestamp="101843195">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5978" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="941" docActiveCodeLength="6530" docExpressionCount="538" docLength="6940" endLine="80" length="2" offset="2365" startLine="80" timestamp="101843197">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5979" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6555" docExpressionCount="543" docLength="6938" endLine="79" length="2" offset="2336" startLine="79" timestamp="101843200">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="5980" _type="Delete" date="Sat Aug 24 16:12:00 EDT 2019" docASTNodeCount="952" docActiveCodeLength="6560" docExpressionCount="543" docLength="6936" endLine="78" length="2" offset="2327" startLine="78" timestamp="101843203">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="6127" _type="PasteCommand" date="Sat Aug 24 16:28:09 EDT 2019" timestamp="102812562" />
  <Command __id="6128" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Aug 24 16:28:10 EDT 2019" timestamp="102813988" />
  <Command __id="6129" _type="MoveCaretCommand" caretOffset="51" date="Sat Aug 24 16:28:15 EDT 2019" docOffset="51" timestamp="102818695" />
  <Command __id="6130" _type="SelectTextCommand" caretOffset="58" date="Sat Aug 24 16:28:15 EDT 2019" end="58" start="41" timestamp="102818986" />
  <Command __id="6131" _type="CopyCommand" date="Sat Aug 24 16:28:16 EDT 2019" timestamp="102819622" />
  <Command __id="6133" _type="SelectTextCommand" caretOffset="146" date="Sat Aug 24 16:28:18 EDT 2019" end="253" start="146" timestamp="102821566" />
  <Command __id="6134" _type="MoveCaretCommand" caretOffset="189" date="Sat Aug 24 16:28:19 EDT 2019" docOffset="1927" timestamp="102822644" />
  <Command __id="6135" _type="SelectTextCommand" caretOffset="148" date="Sat Aug 24 16:28:23 EDT 2019" end="253" start="148" timestamp="102826544" />
  <Command __id="6136" _type="CopyCommand" date="Sat Aug 24 16:28:23 EDT 2019" timestamp="102826978" />
  <Command __id="6137" _type="MoveCaretCommand" caretOffset="253" date="Sat Aug 24 16:28:25 EDT 2019" docOffset="1991" timestamp="102828736" />
  <Command __id="6139" _type="InsertStringCommand" date="Sat Aug 24 16:28:26 EDT 2019" timestamp="102829107" timestamp2="102829107">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="6141" _type="PasteCommand" date="Sat Aug 24 16:28:26 EDT 2019" timestamp="102829767" />
  <Command __id="6142" _type="SelectTextCommand" caretOffset="148" date="Sat Aug 24 16:28:28 EDT 2019" end="253" start="148" timestamp="102831945" />
  <Command __id="6145" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.toggle.comment" date="Sat Aug 24 16:28:29 EDT 2019" timestamp="102832540" />
  <Command __id="6146" _type="MoveCaretCommand" caretOffset="196" date="Sat Aug 24 16:28:32 EDT 2019" docOffset="1934" timestamp="102835264" />
  <Command __id="6147" _type="SelectTextCommand" caretOffset="312" date="Sat Aug 24 16:28:36 EDT 2019" end="312" start="305" timestamp="102839538" />
  <Command __id="6149" _type="InsertStringCommand" date="Sat Aug 24 16:28:37 EDT 2019" repeat="6" timestamp="102840223" timestamp2="102842354">
    <data><![CDATA[RootCo]]></data>
  </Command>
  <Command __id="6160" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:28:39 EDT 2019" start_end="START" timestamp="102842856" />
  <Command __id="6161" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.contentAssist.proposals" date="Sat Aug 24 16:28:40 EDT 2019" timestamp="102843115" />
  <Command __id="6162" _type="ShellCommand" date="Sat Aug 24 16:28:41 EDT 2019" timestamp="102844378" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6163" _type="ShellCommand" date="Sat Aug 24 16:28:41 EDT 2019" timestamp="102844597" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6164" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:28:41 EDT 2019" start_end="END" timestamp="102844619" />
  <Command __id="6166" _type="MoveCaretCommand" caretOffset="319" date="Sat Aug 24 16:28:41 EDT 2019" docOffset="2057" timestamp="102844647" />
  <Command __id="6168" _type="InsertStringCommand" date="Sat Aug 24 16:28:42 EDT 2019" timestamp="102845477" timestamp2="102845477">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="6076" _type="FileOpenCommand" date="Sat Aug 24 16:22:02 EDT 2019" docASTNodeCount="111" docActiveCodeLength="752" docExpressionCount="54" docLength="831" projectName="GraderBasics" timestamp="102445301">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\AnAbstractProxy.java]]></filePath>
  </Command>
  <Command __id="6078" _type="FileOpenCommand" date="Sat Aug 24 16:22:08 EDT 2019" docASTNodeCount="554" docActiveCodeLength="4431" docExpressionCount="336" docLength="4830" projectName="GraderBasics" timestamp="102451849">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\AnAbstractFileProxy.java]]></filePath>
    <snapshot><![CDATA[package grader.file;

import grader.basics.util.GraderFileUtils;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import util.misc.Common;

public abstract class AnAbstractFileProxy extends AnAbstractProxy implements FileProxy {
    protected RootFolderProxy rootFolderProxy;
   

	List<FileProxy> fileEntries;
    List<FileProxy> childrenProxies;
    boolean isFolder;
    boolean isDescendentsInitialized;

  
	public AnAbstractFileProxy(RootFolderProxy aRootFolderProxy) {
        rootFolderProxy = aRootFolderProxy;
    }

    @Override
    public boolean isDirectory() {
        return getChildrenNames().size() > 0;
    }

    public FileProxy getParentFolder() {
//        String parentName = Common.getParentFileName(getAbsoluteName());
//        return this.getFileEntry(parentName);
    	return this.getFileEntry(getParentFolderName());
    }
    @Override
    public String getParentFolderName() {
        return Common.getParentFileName(getAbsoluteName());
//        return this.getFileEntry(parentName);
    }
    
    public void clear() {
    	super.clear();
    	if (descendentNames != null)
    	descendentNames.clear();
    	if (fileEntries != null)
    	fileEntries.clear();   	
    }

    public void initRootData() {
        String myName = getAbsoluteName();
        int myDepth = Common.numOccurences(myName, '/');
        descendentNames = rootFolderProxy.getDescendentEntryNames(this);
        isFolder = descendentNames.size() > 0;
        fileEntries = new ArrayList();
        for (String entryName : descendentNames) {
            int childDepth = Common.numOccurences(entryName, '/');

            if (childDepth == myDepth + 1) {
                childrenNames.add(entryName);
            }
            fileEntries.add(rootFolderProxy.getFileEntry(entryName));
        }
    }

    public List<FileProxy> getFileEntries() {
        return fileEntries;
    }

    public FileProxy getFileEntry(String name) {
        return rootFolderProxy.getFileEntry(name);
    }

    public FileProxy getFileEntryFromLocalName(String name) {
        return rootFolderProxy.getFileEntry(getAbsoluteName() + "/" + name);
    }

    public Set<String> getEntryNames() {
        return descendentNames;
    }

    public Set<String> getDescendentEntryNames(FileProxy aParent) {
    	if (aParent == null)
    		return new HashSet();
        return rootFolderProxy.getDescendentEntryNames(aParent);
    }

    @Override
    public List<FileProxy> getChildrenOf(String aParentName) {
        return rootFolderProxy.getChildrenOf(aParentName);
    }
    @Override
   	public String getParentRelativeName() {
            if (getParentFolder() == null) {
       		return getLocalName();
            } else {
                //System.out.println(this.getClass().getName());
       		return GraderFileUtils.toRelativeName(getParentFolder().getLocalName(), getLocalName());
            }
   	}
    @Override
   	public String getParentRelativeMixedCaseName() {
            if (getParentFolder() == null) {
                return getMixedCaseLocalName();
            } else {
                //System.out.println(this.getClass().getName());
                return GraderFileUtils.toRelativeName(getParentFolder().getMixedCaseLocalName(), getMixedCaseLocalName());
            }	
   	}
    @Override
    public List<FileProxy> getChildren() {
    	if (childrenProxies == null) {
    		childrenProxies = getChildrenOf(getAbsoluteName());
    	}
//    	return getChildrenOf(getAbsoluteName());
    	return childrenProxies;

    }
    
    @Override
    public String displayTree() {
    	String retVal = getParentRelativeName();
    	if (!isDirectory()) return retVal;
//    	String localName = getLocalName();
//    	String absoluteName = getAbsoluteName();
    	List<FileProxy> children = getChildren();
    	if (children.size() == 0) return retVal;
    	retVal += "( ";
    	
    	for (int i = 0; i < children.size(); i++) {
    		String childRepresentation = children.get(i).displayTree();
    		if (i == 0)
    			retVal += childRepresentation;
    		else
    			retVal += ", " + childRepresentation;
    	}
    	retVal += ")";

    	return retVal;
    }
    public boolean isDescendentsInitialized() {
  		return isDescendentsInitialized;
  	}

  	public void setDescendentsInitialized(boolean isDescendentsInitialized) {
  		this.isDescendentsInitialized = isDescendentsInitialized;
  	}
  	@Override
  	 public RootFolderProxy getRootFolderProxy() {
 		return rootFolderProxy;
 	}
  	@Override

 	public void setRootFolderProxy(RootFolderProxy rootFolderProxy) {
 		this.rootFolderProxy = rootFolderProxy;
 	}

}
]]></snapshot>
  </Command>
  <Command __id="6080" _type="FileOpenCommand" date="Sat Aug 24 16:22:10 EDT 2019" docASTNodeCount="111" docActiveCodeLength="752" docExpressionCount="54" docLength="831" projectName="GraderBasics" timestamp="102453543">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\AnAbstractProxy.java]]></filePath>
  </Command>
  <Command __id="6082" _type="FileOpenCommand" date="Sat Aug 24 16:23:04 EDT 2019" docASTNodeCount="775" docActiveCodeLength="5668" docExpressionCount="470" docLength="7928" projectName="GraderBasics" timestamp="102507897">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\AnAbstractRootFolderProxy.java]]></filePath>
  </Command>
  <Command __id="6085" _type="FileOpenCommand" date="Sat Aug 24 16:23:09 EDT 2019" docASTNodeCount="82" docActiveCodeLength="563" docExpressionCount="48" docLength="563" projectName="comp110-grader" timestamp="102512866">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\trace\file\load\RootFolderProxyLoaded.java]]></filePath>
    <snapshot><![CDATA[package grader.trace.file.load;

import grader.basics.trace.FileInfo;

public class RootFolderProxyLoaded extends FileInfo {

	public RootFolderProxyLoaded(String aMessage, String aFileName,
			Object aFinder) {
		super(aMessage, aFileName, aFinder);
	}
	
	public static RootFolderProxyLoaded newCase(String aFileName,
			Object aFinder) {
		String aMessage =  "Root file-system folder loaded: " + aFileName;
		RootFolderProxyLoaded retVal = new RootFolderProxyLoaded(aMessage, aFileName, aFinder);
		retVal.announce();
		return retVal;
	}

}
]]></snapshot>
  </Command>
  <Command __id="6096" _type="FileOpenCommand" date="Sat Aug 24 16:24:11 EDT 2019" docASTNodeCount="302" docActiveCodeLength="2255" docExpressionCount="220" docLength="2281" projectName="GraderBasics" timestamp="102574856">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\trace\grader\basics\GraderBasicsTraceUtility.java]]></filePath>
  </Command>
  <Command __id="6098" _type="FileOpenCommand" date="Sat Aug 24 16:24:12 EDT 2019" docASTNodeCount="111" docActiveCodeLength="752" docExpressionCount="54" docLength="831" projectName="GraderBasics" timestamp="102576077">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\AnAbstractProxy.java]]></filePath>
  </Command>
  <Command __id="6100" _type="FileOpenCommand" date="Sat Aug 24 16:24:42 EDT 2019" docASTNodeCount="775" docActiveCodeLength="5668" docExpressionCount="470" docLength="7928" projectName="GraderBasics" timestamp="102605084">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\AnAbstractRootFolderProxy.java]]></filePath>
  </Command>
  <Command __id="6102" _type="FileOpenCommand" date="Sat Aug 24 16:24:48 EDT 2019" docASTNodeCount="100" docActiveCodeLength="867" docExpressionCount="69" docLength="867" projectName="GraderBasics" timestamp="102611445">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\ARootFolderCreator.java]]></filePath>
    <snapshot><![CDATA[package grader.file;

import grader.file.filesystem.AFileSystemRootFolderProxy;
import grader.file.zipfile.AZippedRootFolderProxy;
import grader.project.flexible.AFlexibleProject;

public class ARootFolderCreator implements RootFolderCreator {
    public  RootFolderProxy createRootFolder(String aFolder, String[] aLazilyFetchSubFoldersOf, String[] anIgnoreFiles) {
        boolean isZipperFolder = aFolder.endsWith(AFlexibleProject.ZIP_SUFFIX_1) || aFolder.endsWith(AFlexibleProject.ZIP_SUFFIX_2);
        
        if (isZipperFolder) {
        	System.out.println ("Creating zipped folder:" + aFolder + " with sffx2 " + AFlexibleProject.ZIP_SUFFIX_2);
            return new AZippedRootFolderProxy(aFolder);
        } else {
            return new AFileSystemRootFolderProxy(aFolder, aLazilyFetchSubFoldersOf, anIgnoreFiles );
        }
    }

}
]]></snapshot>
  </Command>
  <Command __id="6109" _type="FileOpenCommand" date="Sat Aug 24 16:26:31 EDT 2019" docASTNodeCount="27" docActiveCodeLength="182" docExpressionCount="12" docLength="182" projectName="GraderBasics" timestamp="102714489">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\RootFolderCreator.java]]></filePath>
    <snapshot><![CDATA[package grader.file;

public interface RootFolderCreator {
	public  RootFolderProxy createRootFolder(String aFolder, String[] aLazilyFetchSubFoldersOf, String[] anIgnoreFiles);
}]]></snapshot>
  </Command>
  <Command __id="6112" _type="FileOpenCommand" date="Sat Aug 24 16:26:36 EDT 2019" docASTNodeCount="100" docActiveCodeLength="867" docExpressionCount="69" docLength="867" projectName="GraderBasics" timestamp="102719192">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\ARootFolderCreator.java]]></filePath>
  </Command>
  <Command __id="6115" _type="FileOpenCommand" date="Sat Aug 24 16:27:49 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20756" docExpressionCount="1387" docLength="25751" projectName="comp110-grader" timestamp="102793075">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\project\flexible\AFlexibleProject.java]]></filePath>
    <snapshot><![CDATA[package grader.project.flexible;

import framework.grading.testing.Checkable;
import framework.grading.testing.TestCase;
import framework.logging.loggers.FeedbackTextSummaryLogger;
import grader.basics.execution.MainClassFinder;
import grader.basics.execution.RunningProject;
import grader.basics.settings.BasicGradingEnvironment;
import grader.basics.trace.ProjectFolderNotFound;
import grader.config.StaticConfigurationUtils;
import grader.execution.AProxyProjectClassLoader;
import grader.execution.FlexibleMainClassFinder;
import grader.execution.ProjectRunnerSelector;
import grader.execution.ProxyBasedClassesManager;
import grader.execution.ProxyClassLoader;
import grader.file.FileProxy;
import grader.file.RootFolderProxy;
import grader.file.filesystem.AFileSystemRootFolderProxy;
import grader.file.zipfile.AZippedRootFolderProxy;
import grader.language.LanguageDependencyManager;
import grader.project.folder.ARootCodeFolder;
import grader.project.folder.RootCodeFolder;
import grader.project.source.AClassesTextManager;
import grader.project.source.ClassesTextManager;
import grader.project.view.AClassViewManager;
import grader.project.view.ClassViewManager;
import grader.sakai.StudentCodingAssignment;
import grader.sakai.project.SakaiProject;
import grader.trace.execution.MainClassFound;
import grader.trace.execution.MainClassNotFound;
import grader.trace.execution.MainMethodNotFound;
import grader.trace.overall_transcript.OverallTranscriptCleared;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import util.misc.Common;
import wrappers.framework.project.ProjectWrapper;

import com.thoughtworks.qdox.JavaDocBuilder;

public class AFlexibleProject implements FlexibleProject {

    public static final String ZIP_SUFFIX_1 = ".zip";
    public static final String ZIP_SUFFIX_2 = ".jar";
//    public static final String ZIP_SUFFIX_2 = ".zip"; // forget about jars, but keep another suffix

    public static final String DEFAULT_PROJECT_FOLDER = ".";
    public static final String DEFAULT_GRADING_FOLDER = "C:/Users/dewan/Downloads/GraderData";
    public static final String DEFAULT_TRANSCRIPT_FILE_PREFIX = "transcript";
    public static final String DEFAULT_TRANSCRIPT_FILE_SUFFIX = ".txt";
    public static final String DEFAULT_TRASNCRIPT_FILE_NAME = DEFAULT_TRANSCRIPT_FILE_PREFIX + DEFAULT_TRANSCRIPT_FILE_SUFFIX;
//    public static final String PROJECT_DIRECTORY = "D:/dewan_backup/Java/AmandaKaramFinalUpdated/Final";
//    public static final String PROJECT_ZIPPED_DIRECTORY = "D:/dewan_backup/Java/AmandaKaramFinalUpdated.zip";
    public static final String DEFAULT_CHECK_STYLE_FILE_PREFIX = "checkstyle";
    public static final String DEFAULT_CHECK_STYLE_FILE_SUFFIX = ".txt";
    public static final String DEFAULT_CHECK_STYLE__NAME = DEFAULT_CHECK_STYLE_FILE_PREFIX + DEFAULT_CHECK_STYLE_FILE_SUFFIX;
    String projectFolderName = DEFAULT_PROJECT_FOLDER;
    String gradingProjectFolderName = DEFAULT_GRADING_FOLDER;
    ProxyBasedClassesManager classesManager;
    ClassViewManager classViewManager;
    ClassesTextManager classesTextManager;
    boolean zippedFolder;
    RootCodeFolder rootCodeFolder;
    RootFolderProxy rootFolder;
    ProxyClassLoader proxyClassLoader;
    ClassLoader oldClassLoader;
    String outputFolder = ".";
    String sourceFileName, outputFileName, checkStyleFileName;
    String sourceSuffix = ClassesTextManager.DEFAULT_SOURCES_FILE_SUFFIX;
    String outputSuffix = DEFAULT_TRANSCRIPT_FILE_SUFFIX;
    String checkStyleSuffix = DEFAULT_CHECK_STYLE_FILE_SUFFIX;
    boolean hasBeenRun, canBeRun = true; // strange that initial value is true
    boolean hasBeenCompiled, canBeCompiled; 
    boolean hasBeenLoaded, canBeLoaded; 


    JavaDocBuilder javaDocBuilder;
    MainClassFinder mainClassFinder;
    Checkable currentGradingFeature; // ugly but do not want to change project runner code that has access to project and not grading feature
    String[][] args;
    boolean runChecked;
    StringBuffer currentOutput = new StringBuffer();
    StringBuffer currentInput = new StringBuffer();
    
    TestCase currentTestCase;
    RunningProject currentRunningProject;




	//    Map<String, String> processToOutput = new HashMap();
//    Map<String, String> processToInput = new HashMap();
    String[] currentArgs;
//    FileWriter outputFile ;

    protected Class mainClass;
    protected Method mainMethod;
    protected String mainClassName;
    protected String[] inputFiles;
    protected String[] outputFiles;
    boolean noProjectFolder;
//    List<String> nonCompiledClasses = new ArrayList();
    List<String> classNamesThatCouldNotBeCompiled = new ArrayList();

    List<String> classNamesCompiled = new ArrayList();

    
     boolean filesCompiled = false;
     boolean filesUnzipped = false;

   

//	static boolean forceCompile = false; //compile whether that is needed or not
//	static boolean checkStyle = false; 
	Map<String, String> entryPoints;
	
	ProjectWrapper wrapper;



	

	public AFlexibleProject(String aProjectFolder, String anOutputFolder, boolean aZippedFolder) {
        init(aProjectFolder, anOutputFolder, aZippedFolder);
    }

    public AFlexibleProject(StudentCodingAssignment aStudentCodingAssignment) {
        //init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getAbsoluteName());
        init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getMixedCaseAbsoluteName());
    }

    public AFlexibleProject(StudentCodingAssignment aStudentCodingAssignment, String aSourceSuffix, String anOutputSuffix) {
        sourceSuffix = aSourceSuffix;
        outputSuffix = anOutputSuffix;
        RootFolderProxy aProjectFolder = aStudentCodingAssignment.getProjectFolder();
        FileProxy aFeedbackFolder = aStudentCodingAssignment.getFeedbackFolder();
        if (aFeedbackFolder == null) {
//        	System.err.println("No feedback folder,not creating project");
        	throw new RuntimeException("No feedback folder,not creating project");
        }
        String aFeedbackFolderName = aFeedbackFolder.getMixedCaseAbsoluteName();
        
        //init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getAbsoluteName());
        init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getMixedCaseAbsoluteName());
        init(aProjectFolder, aFeedbackFolderName);

    }
    public void clear() {
    	if (classesManager != null)
		classesManager.clear();
    	if (proxyClassLoader != null)
		proxyClassLoader.clear();
    }

    public String toString() {
        return "(" + projectFolderName + "," + outputFolder + ")";
    }

//    public AProject(RootFolderProxy aRootFolder, String anOutputFolder) {
//        init(aRootFolder, anOutputFolder);
//    }

    @Override
    public String getOutputFolder() {
        return outputFolder;
    }

    @Override
    public void setOutputFolder(String outputFolder) {
        this.outputFolder = outputFolder;
    }

    protected MainClassFinder createMainClassFinder() {
//        return new AMainClassFinder();
//    	return JavaMainClassFinderSelector.getMainClassFinder();
        return LanguageDependencyManager.getMainClassFinder();

    }

    public void init(String aProjectFolder, String anOutputFolder, boolean aZippedFolder) {
        if (aZippedFolder) {
            rootFolder = new AZippedRootFolderProxy(aProjectFolder);
        } else {
            rootFolder = new AFileSystemRootFolderProxy(aProjectFolder);
        }
        init(rootFolder, anOutputFolder);
    }

    @Override
    public boolean isNoProjectFolder() {
        return noProjectFolder;
    }

    @Override
    public void setNoProjectFolder(boolean noProjectFolder) {
        this.noProjectFolder = noProjectFolder;
    }
    @Override
    public void setNewClassLoader() {
    	if (BasicGradingEnvironment.get().isLoadClasses()) {
            if (rootCodeFolder.hasValidBinaryFolder()) {
                proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder);
            } else {
                proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder); // create class loader in this case also
            }
        }
    }

    public void init(RootFolderProxy aRootFolder, String anOutputFolder) {
        outputFolder = anOutputFolder;

        rootFolder = aRootFolder;
        outputFileName = createFullOutputFileName();
        checkStyleFileName = createFullCheckStyleFileName();

        if (aRootFolder == null) {
            setNoProjectFolder(true);
            return;
        } else {

            //projectFolderName = aRootFolder.getAbsoluteName();
            projectFolderName = aRootFolder.getMixedCaseAbsoluteName();
//        if (projectFolderName.contains("bluong"))
//        	System.out.println("bluoing");
//        outputFolder = anOutputFolder;
            try {
                rootCodeFolder = new ARootCodeFolder(rootFolder);
            } catch (ProjectFolderNotFound e) {
            	FeedbackTextSummaryLogger.logNoSrcFolder(this);
                setNoProjectFolder(true);
                return;
            }
//            if (AProject.isLoadClasses()) {
//                if (rootCodeFolder.hasValidBinaryFolder()) {
//                    proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder);
//                } else {
//                    proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder); // create class loader in this case also
//                }
//            }
            setNewClassLoader();
            sourceFileName = createFullSourceFileName();
//        outputFileName = createFullOutputFileName();
            classesManager = new AProxyBasedClassesManager();
            mainClassFinder = createMainClassFinder();
        }
    }

    public String createLocalSourceFileName() {
        return classesTextManager.DEFAULT_SOURCES_FILE_PREFIX + sourceSuffix;
    }
    
    

    public String createLocalOutputFileName() {
        return DEFAULT_TRANSCRIPT_FILE_PREFIX + outputSuffix;
    }

    public String createFullSourceFileName() {
        return outputFolder + "/" + createLocalSourceFileName();
    }

    public String createFullOutputFileName() {
        return outputFolder + "/" + createLocalOutputFileName();
    }
    public String createLocalCheckStyleFileName() {
        return DEFAULT_CHECK_STYLE_FILE_PREFIX + checkStyleSuffix;
    }
    
    String checkStyleText = null;
    @Override
    public String getCheckstyleText() {
    	if (checkStyleText == null) { // assume it will never change
			checkStyleText = "";
    		if (!isNoProjectFolder()) {
    			checkStyleText = "";    		
    			String aFileName = getCheckStyleFileName();
    			File aFile = new File(aFileName);
    			if (aFile.exists()) {    	
    			    try {
						checkStyleText = Common.readFile(aFile).toString();
					} catch (IOException e) {
						e.printStackTrace();
					}
    			}
    		}
    	}
    	return checkStyleText;
    }

    public String createFullCheckStyleFileName() {
        return outputFolder + "/" + createLocalCheckStyleFileName();
    }


    boolean madeClassDescriptions;
    List<Class> classesImplicitlyLoaded;

    public List<Class> getImplicitlyLoadedClasses() {
        return classesImplicitlyLoaded;
    }

    public void maybeMakeClassDescriptions() {
    	// earlier it expected class descroptions to be fetched after running
        // but we need the class descriptions to find the main method sometimes
        // so removing this check
//        if (!runChecked && !hasBeenRun)
//            return;
//    	if (!isLoadClasses())
//    		return;
        if (madeClassDescriptions) {
            return;
        }

        makeClassDescriptions();
        madeClassDescriptions = true;

//        try { // Added by Josh: Exceptions can occur when making class descriptions
//            classesManager.makeClassDescriptions(this);
//            classViewManager = new AClassViewManager(classesManager);
//            classesTextManager = new AClassesTextManager(classViewManager);
//            classesTextManager.initializeAllSourcesText();
//            System.out.println("Write sources to:" + sourceFileName);
//            classesTextManager.writeAllSourcesText(sourceFileName);
//            madeClassDescriptions = true;
//        } catch (Exception e) {
//            System.out.println("Error making class descriptions");
//        }
    }

    public void makeClassDescriptions() {
        if (isNoProjectFolder()) {
            return;
        }

        try { // Added by Josh: Exceptions can occur when making class descriptions
            classesManager.makeClassDescriptions(this);
            classViewManager = new AClassViewManager(classesManager);
            classesTextManager = new AClassesTextManager(classViewManager);
            classesTextManager.initializeAllSourcesText();
//            System.out.println("Write sources to:" + sourceFileName);
            classesTextManager.writeAllSourcesText(sourceFileName);
            madeClassDescriptions = true;
        } catch (Exception e) {
            System.out.println("Error making class descriptions");
            e.printStackTrace();
        }
    }

    public String getOutputFileName() {
        return outputFileName;
    }
    

    public String getCheckStyleFileName() {
        return checkStyleFileName;
    }

    public boolean hasBeenRun() {
        return hasBeenRun;
    }

    public void setHasBeenRun(boolean newVal) {
        hasBeenRun = newVal;
        runChecked = true;
        if (hasBeenRun && proxyClassLoader != null) {
            classesImplicitlyLoaded = new ArrayList(proxyClassLoader.getClassesLoaded());
        }
    }

    public boolean hasBeenCompiled() {
		return hasBeenCompiled;
	}

	public void setHasBeenCompiled(boolean hasBeenCompiled) {
		this.hasBeenCompiled = hasBeenCompiled;
	}

	public boolean canBeCompiled() {
		return canBeCompiled;
	}

	public void setCanBeCompiled(boolean canBeCompiled) {
		this.canBeCompiled = canBeCompiled;
	}
	
	 public boolean hasBeenLoaded() {
			return hasBeenLoaded;
		}

		public void setHasBeenLoaded(boolean hasBeenLoaded) {
			this.hasBeenLoaded = hasBeenLoaded;
		}

		public boolean canBeLoaded() {
			return canBeLoaded;
		}

		public void setCanBeLoaded(boolean canBeLoaded) {
			this.canBeLoaded = canBeLoaded;
		}

	@Override()
    public boolean setRunParameters(String aMainClassName, String anArgs[][], String[] anInputFiles, String[] anOutputFiles, MainClassFinder aMainClassFinder) {
        args = anArgs;
        try {
            mainClassName = aMainClassName;
            mainClass = proxyClassLoader.loadClass(mainClassName);
            inputFiles = anInputFiles;
            outputFiles = anOutputFiles;
            if (mainClass == null) {
                mainClass = ((FlexibleMainClassFinder) mainClassFinder).mainClass(rootCodeFolder, proxyClassLoader, mainClassName, this);
            }
            if (mainClass == null) {
//                System.out.println("Missing main class:" + mainClassName + " for student:" + getProjectFolderName());
                setCanBeRun(false);
                MainClassNotFound.newCase(mainClassName, getProjectFolderName(), this);
                return false;
            }

            mainMethod = mainClass.getMethod("main", String[].class);
            if (mainMethod == null) {
//                System.out.println("Missing main method:" + "main");
                MainMethodNotFound.newCase(mainClassName, getProjectFolderName(), this);

                setCanBeRun(false);
                return false;
            }
            MainClassFound.newCase(mainClassName, getProjectFolderName(), this);

            return true;
        } catch (Exception e) {
            System.out.println("cannot  run:" + getProjectFolderName());
            setCanBeRun(false);
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public Thread runProject() {
        try {
            if (!canBeRun()) {
                return null;
            }
            Runnable runnable = ProjectRunnerSelector.createProjectRunner(mainClassName, args, this, inputFiles, outputFiles, mainClass, mainMethod);
            Thread retVal = new Thread(runnable);
            retVal.start();
            System.out.println("started:" + retVal);
            return retVal;
        } catch (Exception e) {
            System.out.println("Could not run:" + getProjectFolderName());
            setCanBeRun(false);
            e.printStackTrace();
            return null;
        }
    }

    public Thread run(String aMainClassName, String[][] anArgs, String[] anInputFiles, String[] anOutputFiles) {
        setRunParameters(aMainClassName, anArgs, anInputFiles, anOutputFiles, mainClassFinder);
        return runProject();
    }

    public AFlexibleProject(String aProjectFolder, String anOutputFolder) {
        init(aProjectFolder, anOutputFolder, aProjectFolder.endsWith(ZIP_SUFFIX_1) || aProjectFolder.endsWith(ZIP_SUFFIX_2) );

    }

    public AFlexibleProject(String aProjectFolder) {
        init(aProjectFolder, outputFolder, aProjectFolder.endsWith(ZIP_SUFFIX_1) || aProjectFolder.endsWith(ZIP_SUFFIX_2));

    }

    public ProxyClassLoader getClassLoader() {
        return proxyClassLoader;
    }

    public ProxyBasedClassesManager getClassesManager() {
        maybeMakeClassDescriptions();
        return classesManager;
    }

    public void setClassesManager(ProxyBasedClassesManager aClassesManager) {
        this.classesManager = aClassesManager;
    }

    public ClassViewManager getClassViewManager() {
        maybeMakeClassDescriptions();
        return classViewManager;
    }

    public void setClassViewManager(ClassViewManager aClassViewManager) {
        this.classViewManager = aClassViewManager;
    }

    public ClassesTextManager getClassesTextManager() {
        maybeMakeClassDescriptions();
        return classesTextManager;
    }

    public void setClassesTextManager(ClassesTextManager aClassesTextManager) {
        this.classesTextManager = aClassesTextManager;
    }

    public void setProjectFolder(String aProjectFolder) {
        this.projectFolderName = aProjectFolder;
    }

    public String getProjectFolderName() {
        return projectFolderName;
    }

    public RootCodeFolder getRootCodeFolder() {
        return rootCodeFolder;
    }

    @Override
    public String getSourceProjectFolderName() {
        return rootCodeFolder.getSourceProjectFolderName();
    }

    @Override
    public String getSourceFileName() {
        return sourceFileName;
    }

    @Override
    public String getBinaryProjectFolderName() {
        return rootCodeFolder.getBinaryProjectFolderName();
    }

    @Override
    public boolean runChecked() {
        return runChecked;
    }

    @Override
    public void setCanBeRun(boolean newVal) {
        runChecked = true;
        canBeRun = newVal;

    }

    @Override
    public boolean canBeRun() {
        return canBeRun;
    }

    @Override
    public JavaDocBuilder getJavaDocBuilder() {
        if (javaDocBuilder == null) {
            javaDocBuilder = new JavaDocBuilder();
        }
        return javaDocBuilder;
    }

    @Override
    public StringBuffer getCurrentOutput() {
        return currentOutput;
    }

    @Override
    public void clearOutput() {
        currentOutput.setLength(0);
        try {
            FileWriter fileWriter = new FileWriter(new File(outputFileName));
            OverallTranscriptCleared.newCase(null, null, (SakaiProject) this, outputFileName, this);
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    @Override
    public void setCurrentOutput(StringBuffer currentOutput) {
        this.currentOutput = currentOutput;
    }

    @Override
    public Checkable getCurrentGradingFeature() {
        return currentGradingFeature;
    }

    @Override
    public void setCurrentGradingFeature(Checkable currentGradingFeature) {
        this.currentGradingFeature = currentGradingFeature;
    }

    @Override
    public String getCurrentInput() {
        return currentInput.toString();
    }

    @Override
    public void setCurrentInput(String aCurrentInput) {
        currentInput.setLength(0);
        appendCurrentInput(aCurrentInput);
    }

    @Override
    public void appendCurrentInput(String aCurrentInput) {
        currentInput.append(aCurrentInput);
    }

//    @Override
//  	public void appendCurrentInput(String aProcess, String aCurrentInput) {
////  		currentInput.append(aCurrentInput);
//    }
    @Override
    public String[] getCurrentArgs() {
        return currentArgs;
    }

    @Override
    public void setCurrentArgs(String[] currentArgs) {
        this.currentArgs = currentArgs;
    }

    @Override
    public String getSourceSuffix() {
        return sourceSuffix;
    }

    @Override
    public boolean hasUnCompiledClasses() {
        // TODO Auto-generated method stub
        return classNamesThatCouldNotBeCompiled.size() > 0;
    }

    @Override
    public List<String> getNonCompiledClasses() {
        return classNamesThatCouldNotBeCompiled;
    }

    @Override
    public void addNonCompiledClass(String newVal) {
        classNamesThatCouldNotBeCompiled.add(newVal);

    }

    @Override
    public boolean hasCompiledClasses() {
        // TODO Auto-generated method stub
        return classNamesCompiled.size() > 0;
    }

    @Override
    public List<String> getCompiledClasses() {
        return classNamesCompiled;
    }

    @Override
    public void addCompiledClass(String newVal) {
        classNamesCompiled.add(newVal);

    }
//    static boolean loadClasses = false;
//
//    static boolean compileMissingObjectCode = false;
//    static boolean unzipFiles = false;
// 
//
//	static boolean preCompileMissingObjectCode = false;
//    public static boolean isLoadClasses() {
//        return loadClasses;
//    }
//
//    public static void setLoadClasses(boolean makeClassDescriptions) {
//        AProject.loadClasses = makeClassDescriptions;
//    }
//
//    public static boolean isCompileMissingObjectCode() {
//        return compileMissingObjectCode;
//    }
//
//    public static void setCompileMissingObjectCode(boolean newVal) {
//        AProject.compileMissingObjectCode = newVal;
//    }
//
//    public static boolean isForceCompile() {
//        return forceCompile;
//    }
//
//    public static void setForceCompile(boolean forceCompile) {
//        AProject.forceCompile = forceCompile;
//    }
//
//    public static boolean isPreCompileMissingObjectCode() {
//        return preCompileMissingObjectCode;
//    }
//
//    public static void setPrecompileMissingObjectCode(
//            boolean preCompileMissingObjectCode) {
//        AProject.preCompileMissingObjectCode = preCompileMissingObjectCode;
//    }
    @Override
    public  boolean isFilesCompiled() {
        return filesCompiled;
    }
    @Override

    public  void setFilesCompiled(boolean filesCompiled) {
        this.filesCompiled = filesCompiled;
    }
    @Override
    public  boolean isFilesUnzipped() {
		return filesUnzipped;
	}
    @Override
	public  void setFilesUnzipped(boolean filesUnzipped) {
		this.filesUnzipped = filesUnzipped;
	}
//	   public static boolean isUnzipFiles() {
//			return unzipFiles;
//		}
//
//		public static void setUnzipFiles(boolean unzipFiles) {
//			AProject.unzipFiles = unzipFiles;
//		}
		public TestCase getCurrentTestCase() {
			return currentTestCase;
		}

		public void setCurrentTestCase(TestCase currentTestCase) {
			this.currentTestCase = currentTestCase;
		}

//	    public static boolean isCheckStyle() {
//			return checkStyle;
//		}

//	    public static void setCheckStyle(boolean checkStyle) {
//			AProject.checkStyle = checkStyle;
//		}
	    public Map<String, String> getEntryPoints() {
	    	if (entryPoints == null) {
				entryPoints = LanguageDependencyManager.getMainClassFinder()
						.getEntryPoints(getWrapper(), StaticConfigurationUtils.getPotentialMainEntryPointNames());

			}
			return entryPoints;
//			return entryPoints;
		}

		public void setEntryPoints(Map<String, String> entryPoints) {
			this.entryPoints = entryPoints;
		}
		@Override
		public RunningProject getCurrentRunningProject() {
			return currentRunningProject;
		}
		@Override

		public void setCurrentRunningProject(RunningProject currentRunningProject) {
			this.currentRunningProject = currentRunningProject;
		}
		  @Override
		     public ProjectWrapper getWrapper() {
		 		return wrapper;
		 	}
		     @Override
		     public void setWrapper(ProjectWrapper newValue) {
		 		this.wrapper = newValue;
		 	}
}
]]></snapshot>
  </Command>
  <Command __id="6120" _type="FileOpenCommand" date="Sat Aug 24 16:28:04 EDT 2019" docASTNodeCount="27" docActiveCodeLength="182" docExpressionCount="12" docLength="182" projectName="GraderBasics" timestamp="102807291">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\RootFolderCreator.java]]></filePath>
  </Command>
  <DocumentChange __id="6123" _type="Insert" date="Sat Aug 24 16:28:07 EDT 2019" docASTNodeCount="27" docActiveCodeLength="184" docExpressionCount="12" docLength="184" length="2" offset="181" timestamp="102810443">
    <text><![CDATA[
]]></text>
  </DocumentChange>
  <DocumentChange __id="6126" _type="Insert" date="Sat Aug 24 16:28:09 EDT 2019" docASTNodeCount="45" docActiveCodeLength="293" docExpressionCount="18" docLength="293" length="109" offset="181" timestamp="102812515">
    <text><![CDATA[	   public static final String ZIP_SUFFIX_1 = ".zip";
	    public static final String ZIP_SUFFIX_2 = ".jar";]]></text>
  </DocumentChange>
  <Command __id="6132" _type="FileOpenCommand" date="Sat Aug 24 16:28:18 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20756" docExpressionCount="1387" docLength="25751" projectName="comp110-grader" timestamp="102821467">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\project\flexible\AFlexibleProject.java]]></filePath>
  </Command>
  <DocumentChange __id="6138" _type="Insert" date="Sat Aug 24 16:28:26 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20762" docExpressionCount="1387" docLength="25757" length="6" offset="1991" timestamp="102829102">
    <text><![CDATA[
    ]]></text>
  </DocumentChange>
  <DocumentChange __id="6140" _type="Replace" date="Sat Aug 24 16:28:26 EDT 2019" docASTNodeCount="2402" docActiveCodeLength="20866" docExpressionCount="1393" docLength="25861" endLine="50" insertionLength="108" int_docASTNodeCount="2384" int_docActiveCodeLength="20758" int_docExpressionCount="1387" int_docLength="25753" length="4" offset="1993" startLine="50" timestamp="102829754">
    <deletedText><![CDATA[    ]]></deletedText>
    <insertedText><![CDATA[    public static final String ZIP_SUFFIX_1 = ".zip";
    public static final String ZIP_SUFFIX_2 = ".jar";]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="6143" _type="Insert" date="Sat Aug 24 16:28:29 EDT 2019" docASTNodeCount="2393" docActiveCodeLength="20813" docExpressionCount="1390" docLength="25863" length="2" offset="1883" timestamp="102832517">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="6144" _type="Insert" date="Sat Aug 24 16:28:29 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20760" docExpressionCount="1387" docLength="25865" length="2" offset="1940" timestamp="102832521">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="6148" _type="Replace" date="Sat Aug 24 16:28:37 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20754" docExpressionCount="1387" docLength="25859" endLine="50" insertionLength="1" int_docASTNodeCount="2383" int_docActiveCodeLength="20753" int_docExpressionCount="1386" int_docLength="25858" length="7" offset="2043" startLine="50" timestamp="102840215">
    <deletedText><![CDATA[".zip";]]></deletedText>
    <insertedText><![CDATA[R]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="6150" _type="Insert" date="Sat Aug 24 16:28:37 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20759" docExpressionCount="1387" docLength="25864" length="5" offset="2044" repeat="5" timestamp="102840554" timestamp2="102842351">
    <text><![CDATA[ootCo]]></text>
  </DocumentChange>
  <DocumentChange __id="6165" _type="Replace" date="Sat Aug 24 16:28:41 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20767" docExpressionCount="1387" docLength="25872" endLine="50" insertionLength="14" int_docASTNodeCount="2383" int_docActiveCodeLength="20753" int_docExpressionCount="1386" int_docLength="25858" length="6" offset="2043" startLine="50" timestamp="102844626">
    <deletedText><![CDATA[RootCo]]></deletedText>
    <insertedText><![CDATA[RootCodeFolder]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="6167" _type="Insert" date="Sat Aug 24 16:28:42 EDT 2019" docASTNodeCount="2383" docActiveCodeLength="20768" docExpressionCount="1386" docLength="25873" length="1" offset="2057" timestamp="102845469">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <Command __id="6169" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sat Aug 24 16:28:42 EDT 2019" start_end="START" timestamp="102845482" />
  <DocumentChange __id="6170" _type="Insert" date="Sat Aug 24 16:28:44 EDT 2019" docASTNodeCount="2386" docActiveCodeLength="20769" docExpressionCount="1389" docLength="25874" length="1" offset="2058" timestamp="102847641">
    <text><![CDATA[Z]]></text>
  </DocumentChange>
  <Command __id="6171" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:28:44 EDT 2019" start_end="END" timestamp="102847654" />
  <DocumentChange __id="6172" _type="Delete" date="Sat Aug 24 16:28:46 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20756" docExpressionCount="1387" docLength="25861" endLine="50" length="13" offset="2046" repeat="13" startLine="50" timestamp="102849930" timestamp2="102852218">
    <text><![CDATA[tCodeFolder.Z]]></text>
  </DocumentChange>
  <Command __id="6173" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sat Aug 24 16:28:46 EDT 2019" repeat="13" timestamp="102849945" timestamp2="102852221" />
  <DocumentChange __id="6198" _type="Insert" date="Sat Aug 24 16:28:50 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20760" docExpressionCount="1387" docLength="25865" length="4" offset="2046" repeat="4" timestamp="102853126" timestamp2="102854050">
    <text><![CDATA[tFol]]></text>
  </DocumentChange>
  <Command __id="6199" _type="InsertStringCommand" date="Sat Aug 24 16:28:50 EDT 2019" repeat="4" timestamp="102853133" timestamp2="102854058">
    <data><![CDATA[tFol]]></data>
  </Command>
  <Command __id="6206" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:28:51 EDT 2019" start_end="START" timestamp="102854579" />
  <Command __id="6207" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.contentAssist.proposals" date="Sat Aug 24 16:28:51 EDT 2019" timestamp="102854689" />
  <Command __id="6208" _type="ShellCommand" date="Sat Aug 24 16:28:52 EDT 2019" timestamp="102855493" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6209" _type="ShellCommand" date="Sat Aug 24 16:28:52 EDT 2019" timestamp="102855697" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6210" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:28:52 EDT 2019" start_end="END" timestamp="102855717" />
  <DocumentChange __id="6211" _type="Replace" date="Sat Aug 24 16:28:52 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20768" docExpressionCount="1387" docLength="25873" endLine="50" insertionLength="15" int_docASTNodeCount="2383" int_docActiveCodeLength="20753" int_docExpressionCount="1386" int_docLength="25858" length="7" offset="2043" startLine="50" timestamp="102855724">
    <deletedText><![CDATA[RootFol]]></deletedText>
    <insertedText><![CDATA[RootFolderProxy]]></insertedText>
  </DocumentChange>
  <Command __id="6212" _type="MoveCaretCommand" caretOffset="320" date="Sat Aug 24 16:28:52 EDT 2019" docOffset="2058" timestamp="102855768" />
  <DocumentChange __id="6213" _type="Insert" date="Sat Aug 24 16:28:53 EDT 2019" docASTNodeCount="2383" docActiveCodeLength="20769" docExpressionCount="1386" docLength="25874" length="1" offset="2058" timestamp="102856441">
    <text><![CDATA[.]]></text>
  </DocumentChange>
  <DocumentChange __id="6216" _type="Delete" date="Sat Aug 24 16:28:57 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20763" docExpressionCount="1387" docLength="25868" endLine="50" length="6" offset="2053" repeat="6" startLine="50" timestamp="102860876" timestamp2="102861963">
    <text><![CDATA[Proxy.]]></text>
  </DocumentChange>
  <DocumentChange __id="6222" _type="Insert" date="Sat Aug 24 16:28:59 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20765" docExpressionCount="1387" docLength="25870" length="2" offset="2053" repeat="2" timestamp="102862616" timestamp2="102862907">
    <text><![CDATA[Cr]]></text>
  </DocumentChange>
  <Command __id="6224" _type="FileOpenCommand" date="Sat Aug 24 16:29:03 EDT 2019" docASTNodeCount="45" docActiveCodeLength="293" docExpressionCount="18" docLength="293" projectName="GraderBasics" timestamp="102866699">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\file\RootFolderCreator.java]]></filePath>
    <snapshot><![CDATA[package grader.file;

public interface RootFolderCreator {
	public  RootFolderProxy createRootFolder(String aFolder, String[] aLazilyFetchSubFoldersOf, String[] anIgnoreFiles);
	   public static final String ZIP_SUFFIX_1 = ".zip";
	    public static final String ZIP_SUFFIX_2 = ".jar";
}]]></snapshot>
  </Command>
  <Command __id="6225" _type="SelectTextCommand" caretOffset="58" date="Sat Aug 24 16:29:03 EDT 2019" end="58" start="41" timestamp="102866795" />
  <Command __id="6226" _type="FileOpenCommand" date="Sat Aug 24 16:29:06 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20765" docExpressionCount="1387" docLength="25870" projectName="comp110-grader" timestamp="102869784">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\project\flexible\AFlexibleProject.java]]></filePath>
    <snapshot><![CDATA[package grader.project.flexible;

import framework.grading.testing.Checkable;
import framework.grading.testing.TestCase;
import framework.logging.loggers.FeedbackTextSummaryLogger;
import grader.basics.execution.MainClassFinder;
import grader.basics.execution.RunningProject;
import grader.basics.settings.BasicGradingEnvironment;
import grader.basics.trace.ProjectFolderNotFound;
import grader.config.StaticConfigurationUtils;
import grader.execution.AProxyProjectClassLoader;
import grader.execution.FlexibleMainClassFinder;
import grader.execution.ProjectRunnerSelector;
import grader.execution.ProxyBasedClassesManager;
import grader.execution.ProxyClassLoader;
import grader.file.FileProxy;
import grader.file.RootFolderProxy;
import grader.file.filesystem.AFileSystemRootFolderProxy;
import grader.file.zipfile.AZippedRootFolderProxy;
import grader.language.LanguageDependencyManager;
import grader.project.folder.ARootCodeFolder;
import grader.project.folder.RootCodeFolder;
import grader.project.source.AClassesTextManager;
import grader.project.source.ClassesTextManager;
import grader.project.view.AClassViewManager;
import grader.project.view.ClassViewManager;
import grader.sakai.StudentCodingAssignment;
import grader.sakai.project.SakaiProject;
import grader.trace.execution.MainClassFound;
import grader.trace.execution.MainClassNotFound;
import grader.trace.execution.MainMethodNotFound;
import grader.trace.overall_transcript.OverallTranscriptCleared;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import util.misc.Common;
import wrappers.framework.project.ProjectWrapper;

import com.thoughtworks.qdox.JavaDocBuilder;

public class AFlexibleProject implements FlexibleProject {

//    public static final String ZIP_SUFFIX_1 = ".zip";
//    public static final String ZIP_SUFFIX_2 = ".jar";
    public static final String ZIP_SUFFIX_1 = RootFolderCr
    public static final String ZIP_SUFFIX_2 = ".jar";
//    public static final String ZIP_SUFFIX_2 = ".zip"; // forget about jars, but keep another suffix

    public static final String DEFAULT_PROJECT_FOLDER = ".";
    public static final String DEFAULT_GRADING_FOLDER = "C:/Users/dewan/Downloads/GraderData";
    public static final String DEFAULT_TRANSCRIPT_FILE_PREFIX = "transcript";
    public static final String DEFAULT_TRANSCRIPT_FILE_SUFFIX = ".txt";
    public static final String DEFAULT_TRASNCRIPT_FILE_NAME = DEFAULT_TRANSCRIPT_FILE_PREFIX + DEFAULT_TRANSCRIPT_FILE_SUFFIX;
//    public static final String PROJECT_DIRECTORY = "D:/dewan_backup/Java/AmandaKaramFinalUpdated/Final";
//    public static final String PROJECT_ZIPPED_DIRECTORY = "D:/dewan_backup/Java/AmandaKaramFinalUpdated.zip";
    public static final String DEFAULT_CHECK_STYLE_FILE_PREFIX = "checkstyle";
    public static final String DEFAULT_CHECK_STYLE_FILE_SUFFIX = ".txt";
    public static final String DEFAULT_CHECK_STYLE__NAME = DEFAULT_CHECK_STYLE_FILE_PREFIX + DEFAULT_CHECK_STYLE_FILE_SUFFIX;
    String projectFolderName = DEFAULT_PROJECT_FOLDER;
    String gradingProjectFolderName = DEFAULT_GRADING_FOLDER;
    ProxyBasedClassesManager classesManager;
    ClassViewManager classViewManager;
    ClassesTextManager classesTextManager;
    boolean zippedFolder;
    RootCodeFolder rootCodeFolder;
    RootFolderProxy rootFolder;
    ProxyClassLoader proxyClassLoader;
    ClassLoader oldClassLoader;
    String outputFolder = ".";
    String sourceFileName, outputFileName, checkStyleFileName;
    String sourceSuffix = ClassesTextManager.DEFAULT_SOURCES_FILE_SUFFIX;
    String outputSuffix = DEFAULT_TRANSCRIPT_FILE_SUFFIX;
    String checkStyleSuffix = DEFAULT_CHECK_STYLE_FILE_SUFFIX;
    boolean hasBeenRun, canBeRun = true; // strange that initial value is true
    boolean hasBeenCompiled, canBeCompiled; 
    boolean hasBeenLoaded, canBeLoaded; 


    JavaDocBuilder javaDocBuilder;
    MainClassFinder mainClassFinder;
    Checkable currentGradingFeature; // ugly but do not want to change project runner code that has access to project and not grading feature
    String[][] args;
    boolean runChecked;
    StringBuffer currentOutput = new StringBuffer();
    StringBuffer currentInput = new StringBuffer();
    
    TestCase currentTestCase;
    RunningProject currentRunningProject;




	//    Map<String, String> processToOutput = new HashMap();
//    Map<String, String> processToInput = new HashMap();
    String[] currentArgs;
//    FileWriter outputFile ;

    protected Class mainClass;
    protected Method mainMethod;
    protected String mainClassName;
    protected String[] inputFiles;
    protected String[] outputFiles;
    boolean noProjectFolder;
//    List<String> nonCompiledClasses = new ArrayList();
    List<String> classNamesThatCouldNotBeCompiled = new ArrayList();

    List<String> classNamesCompiled = new ArrayList();

    
     boolean filesCompiled = false;
     boolean filesUnzipped = false;

   

//	static boolean forceCompile = false; //compile whether that is needed or not
//	static boolean checkStyle = false; 
	Map<String, String> entryPoints;
	
	ProjectWrapper wrapper;



	

	public AFlexibleProject(String aProjectFolder, String anOutputFolder, boolean aZippedFolder) {
        init(aProjectFolder, anOutputFolder, aZippedFolder);
    }

    public AFlexibleProject(StudentCodingAssignment aStudentCodingAssignment) {
        //init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getAbsoluteName());
        init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getMixedCaseAbsoluteName());
    }

    public AFlexibleProject(StudentCodingAssignment aStudentCodingAssignment, String aSourceSuffix, String anOutputSuffix) {
        sourceSuffix = aSourceSuffix;
        outputSuffix = anOutputSuffix;
        RootFolderProxy aProjectFolder = aStudentCodingAssignment.getProjectFolder();
        FileProxy aFeedbackFolder = aStudentCodingAssignment.getFeedbackFolder();
        if (aFeedbackFolder == null) {
//        	System.err.println("No feedback folder,not creating project");
        	throw new RuntimeException("No feedback folder,not creating project");
        }
        String aFeedbackFolderName = aFeedbackFolder.getMixedCaseAbsoluteName();
        
        //init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getAbsoluteName());
        init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getMixedCaseAbsoluteName());
        init(aProjectFolder, aFeedbackFolderName);

    }
    public void clear() {
    	if (classesManager != null)
		classesManager.clear();
    	if (proxyClassLoader != null)
		proxyClassLoader.clear();
    }

    public String toString() {
        return "(" + projectFolderName + "," + outputFolder + ")";
    }

//    public AProject(RootFolderProxy aRootFolder, String anOutputFolder) {
//        init(aRootFolder, anOutputFolder);
//    }

    @Override
    public String getOutputFolder() {
        return outputFolder;
    }

    @Override
    public void setOutputFolder(String outputFolder) {
        this.outputFolder = outputFolder;
    }

    protected MainClassFinder createMainClassFinder() {
//        return new AMainClassFinder();
//    	return JavaMainClassFinderSelector.getMainClassFinder();
        return LanguageDependencyManager.getMainClassFinder();

    }

    public void init(String aProjectFolder, String anOutputFolder, boolean aZippedFolder) {
        if (aZippedFolder) {
            rootFolder = new AZippedRootFolderProxy(aProjectFolder);
        } else {
            rootFolder = new AFileSystemRootFolderProxy(aProjectFolder);
        }
        init(rootFolder, anOutputFolder);
    }

    @Override
    public boolean isNoProjectFolder() {
        return noProjectFolder;
    }

    @Override
    public void setNoProjectFolder(boolean noProjectFolder) {
        this.noProjectFolder = noProjectFolder;
    }
    @Override
    public void setNewClassLoader() {
    	if (BasicGradingEnvironment.get().isLoadClasses()) {
            if (rootCodeFolder.hasValidBinaryFolder()) {
                proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder);
            } else {
                proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder); // create class loader in this case also
            }
        }
    }

    public void init(RootFolderProxy aRootFolder, String anOutputFolder) {
        outputFolder = anOutputFolder;

        rootFolder = aRootFolder;
        outputFileName = createFullOutputFileName();
        checkStyleFileName = createFullCheckStyleFileName();

        if (aRootFolder == null) {
            setNoProjectFolder(true);
            return;
        } else {

            //projectFolderName = aRootFolder.getAbsoluteName();
            projectFolderName = aRootFolder.getMixedCaseAbsoluteName();
//        if (projectFolderName.contains("bluong"))
//        	System.out.println("bluoing");
//        outputFolder = anOutputFolder;
            try {
                rootCodeFolder = new ARootCodeFolder(rootFolder);
            } catch (ProjectFolderNotFound e) {
            	FeedbackTextSummaryLogger.logNoSrcFolder(this);
                setNoProjectFolder(true);
                return;
            }
//            if (AProject.isLoadClasses()) {
//                if (rootCodeFolder.hasValidBinaryFolder()) {
//                    proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder);
//                } else {
//                    proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder); // create class loader in this case also
//                }
//            }
            setNewClassLoader();
            sourceFileName = createFullSourceFileName();
//        outputFileName = createFullOutputFileName();
            classesManager = new AProxyBasedClassesManager();
            mainClassFinder = createMainClassFinder();
        }
    }

    public String createLocalSourceFileName() {
        return classesTextManager.DEFAULT_SOURCES_FILE_PREFIX + sourceSuffix;
    }
    
    

    public String createLocalOutputFileName() {
        return DEFAULT_TRANSCRIPT_FILE_PREFIX + outputSuffix;
    }

    public String createFullSourceFileName() {
        return outputFolder + "/" + createLocalSourceFileName();
    }

    public String createFullOutputFileName() {
        return outputFolder + "/" + createLocalOutputFileName();
    }
    public String createLocalCheckStyleFileName() {
        return DEFAULT_CHECK_STYLE_FILE_PREFIX + checkStyleSuffix;
    }
    
    String checkStyleText = null;
    @Override
    public String getCheckstyleText() {
    	if (checkStyleText == null) { // assume it will never change
			checkStyleText = "";
    		if (!isNoProjectFolder()) {
    			checkStyleText = "";    		
    			String aFileName = getCheckStyleFileName();
    			File aFile = new File(aFileName);
    			if (aFile.exists()) {    	
    			    try {
						checkStyleText = Common.readFile(aFile).toString();
					} catch (IOException e) {
						e.printStackTrace();
					}
    			}
    		}
    	}
    	return checkStyleText;
    }

    public String createFullCheckStyleFileName() {
        return outputFolder + "/" + createLocalCheckStyleFileName();
    }


    boolean madeClassDescriptions;
    List<Class> classesImplicitlyLoaded;

    public List<Class> getImplicitlyLoadedClasses() {
        return classesImplicitlyLoaded;
    }

    public void maybeMakeClassDescriptions() {
    	// earlier it expected class descroptions to be fetched after running
        // but we need the class descriptions to find the main method sometimes
        // so removing this check
//        if (!runChecked && !hasBeenRun)
//            return;
//    	if (!isLoadClasses())
//    		return;
        if (madeClassDescriptions) {
            return;
        }

        makeClassDescriptions();
        madeClassDescriptions = true;

//        try { // Added by Josh: Exceptions can occur when making class descriptions
//            classesManager.makeClassDescriptions(this);
//            classViewManager = new AClassViewManager(classesManager);
//            classesTextManager = new AClassesTextManager(classViewManager);
//            classesTextManager.initializeAllSourcesText();
//            System.out.println("Write sources to:" + sourceFileName);
//            classesTextManager.writeAllSourcesText(sourceFileName);
//            madeClassDescriptions = true;
//        } catch (Exception e) {
//            System.out.println("Error making class descriptions");
//        }
    }

    public void makeClassDescriptions() {
        if (isNoProjectFolder()) {
            return;
        }

        try { // Added by Josh: Exceptions can occur when making class descriptions
            classesManager.makeClassDescriptions(this);
            classViewManager = new AClassViewManager(classesManager);
            classesTextManager = new AClassesTextManager(classViewManager);
            classesTextManager.initializeAllSourcesText();
//            System.out.println("Write sources to:" + sourceFileName);
            classesTextManager.writeAllSourcesText(sourceFileName);
            madeClassDescriptions = true;
        } catch (Exception e) {
            System.out.println("Error making class descriptions");
            e.printStackTrace();
        }
    }

    public String getOutputFileName() {
        return outputFileName;
    }
    

    public String getCheckStyleFileName() {
        return checkStyleFileName;
    }

    public boolean hasBeenRun() {
        return hasBeenRun;
    }

    public void setHasBeenRun(boolean newVal) {
        hasBeenRun = newVal;
        runChecked = true;
        if (hasBeenRun && proxyClassLoader != null) {
            classesImplicitlyLoaded = new ArrayList(proxyClassLoader.getClassesLoaded());
        }
    }

    public boolean hasBeenCompiled() {
		return hasBeenCompiled;
	}

	public void setHasBeenCompiled(boolean hasBeenCompiled) {
		this.hasBeenCompiled = hasBeenCompiled;
	}

	public boolean canBeCompiled() {
		return canBeCompiled;
	}

	public void setCanBeCompiled(boolean canBeCompiled) {
		this.canBeCompiled = canBeCompiled;
	}
	
	 public boolean hasBeenLoaded() {
			return hasBeenLoaded;
		}

		public void setHasBeenLoaded(boolean hasBeenLoaded) {
			this.hasBeenLoaded = hasBeenLoaded;
		}

		public boolean canBeLoaded() {
			return canBeLoaded;
		}

		public void setCanBeLoaded(boolean canBeLoaded) {
			this.canBeLoaded = canBeLoaded;
		}

	@Override()
    public boolean setRunParameters(String aMainClassName, String anArgs[][], String[] anInputFiles, String[] anOutputFiles, MainClassFinder aMainClassFinder) {
        args = anArgs;
        try {
            mainClassName = aMainClassName;
            mainClass = proxyClassLoader.loadClass(mainClassName);
            inputFiles = anInputFiles;
            outputFiles = anOutputFiles;
            if (mainClass == null) {
                mainClass = ((FlexibleMainClassFinder) mainClassFinder).mainClass(rootCodeFolder, proxyClassLoader, mainClassName, this);
            }
            if (mainClass == null) {
//                System.out.println("Missing main class:" + mainClassName + " for student:" + getProjectFolderName());
                setCanBeRun(false);
                MainClassNotFound.newCase(mainClassName, getProjectFolderName(), this);
                return false;
            }

            mainMethod = mainClass.getMethod("main", String[].class);
            if (mainMethod == null) {
//                System.out.println("Missing main method:" + "main");
                MainMethodNotFound.newCase(mainClassName, getProjectFolderName(), this);

                setCanBeRun(false);
                return false;
            }
            MainClassFound.newCase(mainClassName, getProjectFolderName(), this);

            return true;
        } catch (Exception e) {
            System.out.println("cannot  run:" + getProjectFolderName());
            setCanBeRun(false);
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public Thread runProject() {
        try {
            if (!canBeRun()) {
                return null;
            }
            Runnable runnable = ProjectRunnerSelector.createProjectRunner(mainClassName, args, this, inputFiles, outputFiles, mainClass, mainMethod);
            Thread retVal = new Thread(runnable);
            retVal.start();
            System.out.println("started:" + retVal);
            return retVal;
        } catch (Exception e) {
            System.out.println("Could not run:" + getProjectFolderName());
            setCanBeRun(false);
            e.printStackTrace();
            return null;
        }
    }

    public Thread run(String aMainClassName, String[][] anArgs, String[] anInputFiles, String[] anOutputFiles) {
        setRunParameters(aMainClassName, anArgs, anInputFiles, anOutputFiles, mainClassFinder);
        return runProject();
    }

    public AFlexibleProject(String aProjectFolder, String anOutputFolder) {
        init(aProjectFolder, anOutputFolder, aProjectFolder.endsWith(ZIP_SUFFIX_1) || aProjectFolder.endsWith(ZIP_SUFFIX_2) );

    }

    public AFlexibleProject(String aProjectFolder) {
        init(aProjectFolder, outputFolder, aProjectFolder.endsWith(ZIP_SUFFIX_1) || aProjectFolder.endsWith(ZIP_SUFFIX_2));

    }

    public ProxyClassLoader getClassLoader() {
        return proxyClassLoader;
    }

    public ProxyBasedClassesManager getClassesManager() {
        maybeMakeClassDescriptions();
        return classesManager;
    }

    public void setClassesManager(ProxyBasedClassesManager aClassesManager) {
        this.classesManager = aClassesManager;
    }

    public ClassViewManager getClassViewManager() {
        maybeMakeClassDescriptions();
        return classViewManager;
    }

    public void setClassViewManager(ClassViewManager aClassViewManager) {
        this.classViewManager = aClassViewManager;
    }

    public ClassesTextManager getClassesTextManager() {
        maybeMakeClassDescriptions();
        return classesTextManager;
    }

    public void setClassesTextManager(ClassesTextManager aClassesTextManager) {
        this.classesTextManager = aClassesTextManager;
    }

    public void setProjectFolder(String aProjectFolder) {
        this.projectFolderName = aProjectFolder;
    }

    public String getProjectFolderName() {
        return projectFolderName;
    }

    public RootCodeFolder getRootCodeFolder() {
        return rootCodeFolder;
    }

    @Override
    public String getSourceProjectFolderName() {
        return rootCodeFolder.getSourceProjectFolderName();
    }

    @Override
    public String getSourceFileName() {
        return sourceFileName;
    }

    @Override
    public String getBinaryProjectFolderName() {
        return rootCodeFolder.getBinaryProjectFolderName();
    }

    @Override
    public boolean runChecked() {
        return runChecked;
    }

    @Override
    public void setCanBeRun(boolean newVal) {
        runChecked = true;
        canBeRun = newVal;

    }

    @Override
    public boolean canBeRun() {
        return canBeRun;
    }

    @Override
    public JavaDocBuilder getJavaDocBuilder() {
        if (javaDocBuilder == null) {
            javaDocBuilder = new JavaDocBuilder();
        }
        return javaDocBuilder;
    }

    @Override
    public StringBuffer getCurrentOutput() {
        return currentOutput;
    }

    @Override
    public void clearOutput() {
        currentOutput.setLength(0);
        try {
            FileWriter fileWriter = new FileWriter(new File(outputFileName));
            OverallTranscriptCleared.newCase(null, null, (SakaiProject) this, outputFileName, this);
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    @Override
    public void setCurrentOutput(StringBuffer currentOutput) {
        this.currentOutput = currentOutput;
    }

    @Override
    public Checkable getCurrentGradingFeature() {
        return currentGradingFeature;
    }

    @Override
    public void setCurrentGradingFeature(Checkable currentGradingFeature) {
        this.currentGradingFeature = currentGradingFeature;
    }

    @Override
    public String getCurrentInput() {
        return currentInput.toString();
    }

    @Override
    public void setCurrentInput(String aCurrentInput) {
        currentInput.setLength(0);
        appendCurrentInput(aCurrentInput);
    }

    @Override
    public void appendCurrentInput(String aCurrentInput) {
        currentInput.append(aCurrentInput);
    }

//    @Override
//  	public void appendCurrentInput(String aProcess, String aCurrentInput) {
////  		currentInput.append(aCurrentInput);
//    }
    @Override
    public String[] getCurrentArgs() {
        return currentArgs;
    }

    @Override
    public void setCurrentArgs(String[] currentArgs) {
        this.currentArgs = currentArgs;
    }

    @Override
    public String getSourceSuffix() {
        return sourceSuffix;
    }

    @Override
    public boolean hasUnCompiledClasses() {
        // TODO Auto-generated method stub
        return classNamesThatCouldNotBeCompiled.size() > 0;
    }

    @Override
    public List<String> getNonCompiledClasses() {
        return classNamesThatCouldNotBeCompiled;
    }

    @Override
    public void addNonCompiledClass(String newVal) {
        classNamesThatCouldNotBeCompiled.add(newVal);

    }

    @Override
    public boolean hasCompiledClasses() {
        // TODO Auto-generated method stub
        return classNamesCompiled.size() > 0;
    }

    @Override
    public List<String> getCompiledClasses() {
        return classNamesCompiled;
    }

    @Override
    public void addCompiledClass(String newVal) {
        classNamesCompiled.add(newVal);

    }
//    static boolean loadClasses = false;
//
//    static boolean compileMissingObjectCode = false;
//    static boolean unzipFiles = false;
// 
//
//	static boolean preCompileMissingObjectCode = false;
//    public static boolean isLoadClasses() {
//        return loadClasses;
//    }
//
//    public static void setLoadClasses(boolean makeClassDescriptions) {
//        AProject.loadClasses = makeClassDescriptions;
//    }
//
//    public static boolean isCompileMissingObjectCode() {
//        return compileMissingObjectCode;
//    }
//
//    public static void setCompileMissingObjectCode(boolean newVal) {
//        AProject.compileMissingObjectCode = newVal;
//    }
//
//    public static boolean isForceCompile() {
//        return forceCompile;
//    }
//
//    public static void setForceCompile(boolean forceCompile) {
//        AProject.forceCompile = forceCompile;
//    }
//
//    public static boolean isPreCompileMissingObjectCode() {
//        return preCompileMissingObjectCode;
//    }
//
//    public static void setPrecompileMissingObjectCode(
//            boolean preCompileMissingObjectCode) {
//        AProject.preCompileMissingObjectCode = preCompileMissingObjectCode;
//    }
    @Override
    public  boolean isFilesCompiled() {
        return filesCompiled;
    }
    @Override

    public  void setFilesCompiled(boolean filesCompiled) {
        this.filesCompiled = filesCompiled;
    }
    @Override
    public  boolean isFilesUnzipped() {
		return filesUnzipped;
	}
    @Override
	public  void setFilesUnzipped(boolean filesUnzipped) {
		this.filesUnzipped = filesUnzipped;
	}
//	   public static boolean isUnzipFiles() {
//			return unzipFiles;
//		}
//
//		public static void setUnzipFiles(boolean unzipFiles) {
//			AProject.unzipFiles = unzipFiles;
//		}
		public TestCase getCurrentTestCase() {
			return currentTestCase;
		}

		public void setCurrentTestCase(TestCase currentTestCase) {
			this.currentTestCase = currentTestCase;
		}

//	    public static boolean isCheckStyle() {
//			return checkStyle;
//		}

//	    public static void setCheckStyle(boolean checkStyle) {
//			AProject.checkStyle = checkStyle;
//		}
	    public Map<String, String> getEntryPoints() {
	    	if (entryPoints == null) {
				entryPoints = LanguageDependencyManager.getMainClassFinder()
						.getEntryPoints(getWrapper(), StaticConfigurationUtils.getPotentialMainEntryPointNames());

			}
			return entryPoints;
//			return entryPoints;
		}

		public void setEntryPoints(Map<String, String> entryPoints) {
			this.entryPoints = entryPoints;
		}
		@Override
		public RunningProject getCurrentRunningProject() {
			return currentRunningProject;
		}
		@Override

		public void setCurrentRunningProject(RunningProject currentRunningProject) {
			this.currentRunningProject = currentRunningProject;
		}
		  @Override
		     public ProjectWrapper getWrapper() {
		 		return wrapper;
		 	}
		     @Override
		     public void setWrapper(ProjectWrapper newValue) {
		 		this.wrapper = newValue;
		 	}
}
]]></snapshot>
  </Command>
  <Command __id="6227" _type="MoveCaretCommand" caretOffset="317" date="Sat Aug 24 16:29:06 EDT 2019" docOffset="2055" timestamp="102869889" />
  <DocumentChange __id="6228" _type="Insert" date="Sat Aug 24 16:29:08 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20766" docExpressionCount="1387" docLength="25871" length="1" offset="2055" timestamp="102871428">
    <text><![CDATA[e]]></text>
  </DocumentChange>
  <Command __id="6229" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:29:08 EDT 2019" start_end="START" timestamp="102871930" />
  <Command __id="6230" _type="EclipseCommand" commandID="org.eclipse.ui.edit.text.contentAssist.proposals" date="Sat Aug 24 16:29:08 EDT 2019" timestamp="102872019" />
  <Command __id="6231" _type="ShellCommand" date="Sat Aug 24 16:29:10 EDT 2019" timestamp="102873368" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6232" _type="ShellCommand" date="Sat Aug 24 16:29:10 EDT 2019" timestamp="102873538" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6233" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:29:10 EDT 2019" start_end="END" timestamp="102873558" />
  <DocumentChange __id="6234" _type="Replace" date="Sat Aug 24 16:29:10 EDT 2019" docASTNodeCount="2384" docActiveCodeLength="20770" docExpressionCount="1387" docLength="25875" endLine="50" insertionLength="17" int_docASTNodeCount="2383" int_docActiveCodeLength="20753" int_docExpressionCount="1386" int_docLength="25858" length="13" offset="2043" startLine="50" timestamp="102873566">
    <deletedText><![CDATA[RootFolderCre]]></deletedText>
    <insertedText><![CDATA[RootFolderCreator]]></insertedText>
  </DocumentChange>
  <DocumentChange __id="6235" _type="Insert" date="Sat Aug 24 16:29:10 EDT 2019" docASTNodeCount="2390" docActiveCodeLength="20809" docExpressionCount="1392" docLength="25914" length="39" offset="710" repeat="2" timestamp="102873578" timestamp2="102873582">
    <text><![CDATA[
import grader.file.RootFolderCreator;]]></text>
  </DocumentChange>
  <DocumentChange __id="6237" _type="Insert" date="Sat Aug 24 16:29:11 EDT 2019" docASTNodeCount="2392" docActiveCodeLength="20823" docExpressionCount="1394" docLength="25928" length="14" offset="2099" repeat="3" timestamp="102874444" timestamp2="102877577">
    <text><![CDATA[.ZIP_SUFFIX_1;]]></text>
  </DocumentChange>
  <Command __id="6238" _type="InsertStringCommand" date="Sat Aug 24 16:29:11 EDT 2019" timestamp="102874450" timestamp2="102874450">
    <data><![CDATA[.]]></data>
  </Command>
  <Command __id="6239" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="true" date="Sat Aug 24 16:29:11 EDT 2019" start_end="START" timestamp="102874455" />
  <Command __id="6240" _type="ShellCommand" date="Sat Aug 24 16:29:12 EDT 2019" timestamp="102875358" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6241" _type="ShellCommand" date="Sat Aug 24 16:29:12 EDT 2019" timestamp="102875563" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6242" _type="AssistCommand" assist_type="CONTENT_ASSIST" auto_activated="false" date="Sat Aug 24 16:29:12 EDT 2019" start_end="END" timestamp="102875585" />
  <Command __id="6244" _type="MoveCaretCommand" caretOffset="335" date="Sat Aug 24 16:29:12 EDT 2019" docOffset="2112" timestamp="102875648" />
  <Command __id="6246" _type="InsertStringCommand" date="Sat Aug 24 16:29:14 EDT 2019" timestamp="102877584" timestamp2="102877584">
    <data><![CDATA[;]]></data>
  </Command>
  <Command __id="6247" _type="SelectTextCommand" caretOffset="335" date="Sat Aug 24 16:29:19 EDT 2019" end="335" start="305" timestamp="102882370" />
  <Command __id="6248" _type="CopyCommand" date="Sat Aug 24 16:29:19 EDT 2019" timestamp="102882829" />
  <Command __id="6249" _type="SelectTextCommand" caretOffset="390" date="Sat Aug 24 16:29:23 EDT 2019" end="390" start="384" timestamp="102886270" />
  <DocumentChange __id="6250" _type="Replace" date="Sat Aug 24 16:29:23 EDT 2019" docASTNodeCount="2394" docActiveCodeLength="20847" docExpressionCount="1396" docLength="25952" endLine="52" insertionLength="30" int_docASTNodeCount="2391" int_docActiveCodeLength="20817" int_docExpressionCount="1393" int_docLength="25922" length="6" offset="2161" startLine="52" timestamp="102886782">
    <deletedText><![CDATA[".jar"]]></deletedText>
    <insertedText><![CDATA[RootFolderCreator.ZIP_SUFFIX_1]]></insertedText>
  </DocumentChange>
  <Command __id="6251" _type="PasteCommand" date="Sat Aug 24 16:29:23 EDT 2019" timestamp="102886793" />
  <Command __id="6252" _type="PredictionCommand" date="Sat Aug 24 16:29:23 EDT 2019" prediction_type="MakingProgress" timestamp="102886795" />
  <DocumentChange __id="6253" _type="Delete" date="Sat Aug 24 16:29:25 EDT 2019" docASTNodeCount="2394" docActiveCodeLength="20846" docExpressionCount="1396" docLength="25951" endLine="52" length="1" offset="2190" startLine="52" timestamp="102888432">
    <text><![CDATA[1]]></text>
  </DocumentChange>
  <Command __id="6254" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sat Aug 24 16:29:25 EDT 2019" timestamp="102888434" />
  <DocumentChange __id="6327" _type="Delete" date="Sat Aug 24 16:29:57 EDT 2019" docASTNodeCount="96" docActiveCodeLength="827" docExpressionCount="65" docLength="961" endLine="9" length="17" offset="594" repeat="17" startLine="9" timestamp="102920729" timestamp2="102924403">
    <text><![CDATA[AFlexibleProject.]]></text>
  </DocumentChange>
  <Command __id="6328" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sat Aug 24 16:29:57 EDT 2019" repeat="17" timestamp="102920737" timestamp2="102924417" />
  <Command __id="6361" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Aug 24 16:30:02 EDT 2019" timestamp="102925305" />
  <Command __id="6362" _type="FileOpenCommand" date="Sat Aug 24 16:30:09 EDT 2019" docASTNodeCount="2394" docActiveCodeLength="20847" docExpressionCount="1396" docLength="25952" projectName="comp110-grader" timestamp="102932224">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\project\flexible\AFlexibleProject.java]]></filePath>
    <snapshot><![CDATA[package grader.project.flexible;

import framework.grading.testing.Checkable;
import framework.grading.testing.TestCase;
import framework.logging.loggers.FeedbackTextSummaryLogger;
import grader.basics.execution.MainClassFinder;
import grader.basics.execution.RunningProject;
import grader.basics.settings.BasicGradingEnvironment;
import grader.basics.trace.ProjectFolderNotFound;
import grader.config.StaticConfigurationUtils;
import grader.execution.AProxyProjectClassLoader;
import grader.execution.FlexibleMainClassFinder;
import grader.execution.ProjectRunnerSelector;
import grader.execution.ProxyBasedClassesManager;
import grader.execution.ProxyClassLoader;
import grader.file.FileProxy;
import grader.file.RootFolderCreator;
import grader.file.RootFolderProxy;
import grader.file.filesystem.AFileSystemRootFolderProxy;
import grader.file.zipfile.AZippedRootFolderProxy;
import grader.language.LanguageDependencyManager;
import grader.project.folder.ARootCodeFolder;
import grader.project.folder.RootCodeFolder;
import grader.project.source.AClassesTextManager;
import grader.project.source.ClassesTextManager;
import grader.project.view.AClassViewManager;
import grader.project.view.ClassViewManager;
import grader.sakai.StudentCodingAssignment;
import grader.sakai.project.SakaiProject;
import grader.trace.execution.MainClassFound;
import grader.trace.execution.MainClassNotFound;
import grader.trace.execution.MainMethodNotFound;
import grader.trace.overall_transcript.OverallTranscriptCleared;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import util.misc.Common;
import wrappers.framework.project.ProjectWrapper;

import com.thoughtworks.qdox.JavaDocBuilder;

public class AFlexibleProject implements FlexibleProject {

//    public static final String ZIP_SUFFIX_1 = ".zip";
//    public static final String ZIP_SUFFIX_2 = ".jar";
    public static final String ZIP_SUFFIX_1 = RootFolderCreator.ZIP_SUFFIX_1;
    public static final String ZIP_SUFFIX_2 = RootFolderCreator.ZIP_SUFFIX_2;
//    public static final String ZIP_SUFFIX_2 = ".zip"; // forget about jars, but keep another suffix

    public static final String DEFAULT_PROJECT_FOLDER = ".";
    public static final String DEFAULT_GRADING_FOLDER = "C:/Users/dewan/Downloads/GraderData";
    public static final String DEFAULT_TRANSCRIPT_FILE_PREFIX = "transcript";
    public static final String DEFAULT_TRANSCRIPT_FILE_SUFFIX = ".txt";
    public static final String DEFAULT_TRASNCRIPT_FILE_NAME = DEFAULT_TRANSCRIPT_FILE_PREFIX + DEFAULT_TRANSCRIPT_FILE_SUFFIX;
//    public static final String PROJECT_DIRECTORY = "D:/dewan_backup/Java/AmandaKaramFinalUpdated/Final";
//    public static final String PROJECT_ZIPPED_DIRECTORY = "D:/dewan_backup/Java/AmandaKaramFinalUpdated.zip";
    public static final String DEFAULT_CHECK_STYLE_FILE_PREFIX = "checkstyle";
    public static final String DEFAULT_CHECK_STYLE_FILE_SUFFIX = ".txt";
    public static final String DEFAULT_CHECK_STYLE__NAME = DEFAULT_CHECK_STYLE_FILE_PREFIX + DEFAULT_CHECK_STYLE_FILE_SUFFIX;
    String projectFolderName = DEFAULT_PROJECT_FOLDER;
    String gradingProjectFolderName = DEFAULT_GRADING_FOLDER;
    ProxyBasedClassesManager classesManager;
    ClassViewManager classViewManager;
    ClassesTextManager classesTextManager;
    boolean zippedFolder;
    RootCodeFolder rootCodeFolder;
    RootFolderProxy rootFolder;
    ProxyClassLoader proxyClassLoader;
    ClassLoader oldClassLoader;
    String outputFolder = ".";
    String sourceFileName, outputFileName, checkStyleFileName;
    String sourceSuffix = ClassesTextManager.DEFAULT_SOURCES_FILE_SUFFIX;
    String outputSuffix = DEFAULT_TRANSCRIPT_FILE_SUFFIX;
    String checkStyleSuffix = DEFAULT_CHECK_STYLE_FILE_SUFFIX;
    boolean hasBeenRun, canBeRun = true; // strange that initial value is true
    boolean hasBeenCompiled, canBeCompiled; 
    boolean hasBeenLoaded, canBeLoaded; 


    JavaDocBuilder javaDocBuilder;
    MainClassFinder mainClassFinder;
    Checkable currentGradingFeature; // ugly but do not want to change project runner code that has access to project and not grading feature
    String[][] args;
    boolean runChecked;
    StringBuffer currentOutput = new StringBuffer();
    StringBuffer currentInput = new StringBuffer();
    
    TestCase currentTestCase;
    RunningProject currentRunningProject;




	//    Map<String, String> processToOutput = new HashMap();
//    Map<String, String> processToInput = new HashMap();
    String[] currentArgs;
//    FileWriter outputFile ;

    protected Class mainClass;
    protected Method mainMethod;
    protected String mainClassName;
    protected String[] inputFiles;
    protected String[] outputFiles;
    boolean noProjectFolder;
//    List<String> nonCompiledClasses = new ArrayList();
    List<String> classNamesThatCouldNotBeCompiled = new ArrayList();

    List<String> classNamesCompiled = new ArrayList();

    
     boolean filesCompiled = false;
     boolean filesUnzipped = false;

   

//	static boolean forceCompile = false; //compile whether that is needed or not
//	static boolean checkStyle = false; 
	Map<String, String> entryPoints;
	
	ProjectWrapper wrapper;



	

	public AFlexibleProject(String aProjectFolder, String anOutputFolder, boolean aZippedFolder) {
        init(aProjectFolder, anOutputFolder, aZippedFolder);
    }

    public AFlexibleProject(StudentCodingAssignment aStudentCodingAssignment) {
        //init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getAbsoluteName());
        init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getMixedCaseAbsoluteName());
    }

    public AFlexibleProject(StudentCodingAssignment aStudentCodingAssignment, String aSourceSuffix, String anOutputSuffix) {
        sourceSuffix = aSourceSuffix;
        outputSuffix = anOutputSuffix;
        RootFolderProxy aProjectFolder = aStudentCodingAssignment.getProjectFolder();
        FileProxy aFeedbackFolder = aStudentCodingAssignment.getFeedbackFolder();
        if (aFeedbackFolder == null) {
//        	System.err.println("No feedback folder,not creating project");
        	throw new RuntimeException("No feedback folder,not creating project");
        }
        String aFeedbackFolderName = aFeedbackFolder.getMixedCaseAbsoluteName();
        
        //init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getAbsoluteName());
        init(aStudentCodingAssignment.getProjectFolder(), aStudentCodingAssignment.getFeedbackFolder().getMixedCaseAbsoluteName());
        init(aProjectFolder, aFeedbackFolderName);

    }
    public void clear() {
    	if (classesManager != null)
		classesManager.clear();
    	if (proxyClassLoader != null)
		proxyClassLoader.clear();
    }

    public String toString() {
        return "(" + projectFolderName + "," + outputFolder + ")";
    }

//    public AProject(RootFolderProxy aRootFolder, String anOutputFolder) {
//        init(aRootFolder, anOutputFolder);
//    }

    @Override
    public String getOutputFolder() {
        return outputFolder;
    }

    @Override
    public void setOutputFolder(String outputFolder) {
        this.outputFolder = outputFolder;
    }

    protected MainClassFinder createMainClassFinder() {
//        return new AMainClassFinder();
//    	return JavaMainClassFinderSelector.getMainClassFinder();
        return LanguageDependencyManager.getMainClassFinder();

    }

    public void init(String aProjectFolder, String anOutputFolder, boolean aZippedFolder) {
        if (aZippedFolder) {
            rootFolder = new AZippedRootFolderProxy(aProjectFolder);
        } else {
            rootFolder = new AFileSystemRootFolderProxy(aProjectFolder);
        }
        init(rootFolder, anOutputFolder);
    }

    @Override
    public boolean isNoProjectFolder() {
        return noProjectFolder;
    }

    @Override
    public void setNoProjectFolder(boolean noProjectFolder) {
        this.noProjectFolder = noProjectFolder;
    }
    @Override
    public void setNewClassLoader() {
    	if (BasicGradingEnvironment.get().isLoadClasses()) {
            if (rootCodeFolder.hasValidBinaryFolder()) {
                proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder);
            } else {
                proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder); // create class loader in this case also
            }
        }
    }

    public void init(RootFolderProxy aRootFolder, String anOutputFolder) {
        outputFolder = anOutputFolder;

        rootFolder = aRootFolder;
        outputFileName = createFullOutputFileName();
        checkStyleFileName = createFullCheckStyleFileName();

        if (aRootFolder == null) {
            setNoProjectFolder(true);
            return;
        } else {

            //projectFolderName = aRootFolder.getAbsoluteName();
            projectFolderName = aRootFolder.getMixedCaseAbsoluteName();
//        if (projectFolderName.contains("bluong"))
//        	System.out.println("bluoing");
//        outputFolder = anOutputFolder;
            try {
                rootCodeFolder = new ARootCodeFolder(rootFolder);
            } catch (ProjectFolderNotFound e) {
            	FeedbackTextSummaryLogger.logNoSrcFolder(this);
                setNoProjectFolder(true);
                return;
            }
//            if (AProject.isLoadClasses()) {
//                if (rootCodeFolder.hasValidBinaryFolder()) {
//                    proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder);
//                } else {
//                    proxyClassLoader = new AProxyProjectClassLoader(rootCodeFolder); // create class loader in this case also
//                }
//            }
            setNewClassLoader();
            sourceFileName = createFullSourceFileName();
//        outputFileName = createFullOutputFileName();
            classesManager = new AProxyBasedClassesManager();
            mainClassFinder = createMainClassFinder();
        }
    }

    public String createLocalSourceFileName() {
        return classesTextManager.DEFAULT_SOURCES_FILE_PREFIX + sourceSuffix;
    }
    
    

    public String createLocalOutputFileName() {
        return DEFAULT_TRANSCRIPT_FILE_PREFIX + outputSuffix;
    }

    public String createFullSourceFileName() {
        return outputFolder + "/" + createLocalSourceFileName();
    }

    public String createFullOutputFileName() {
        return outputFolder + "/" + createLocalOutputFileName();
    }
    public String createLocalCheckStyleFileName() {
        return DEFAULT_CHECK_STYLE_FILE_PREFIX + checkStyleSuffix;
    }
    
    String checkStyleText = null;
    @Override
    public String getCheckstyleText() {
    	if (checkStyleText == null) { // assume it will never change
			checkStyleText = "";
    		if (!isNoProjectFolder()) {
    			checkStyleText = "";    		
    			String aFileName = getCheckStyleFileName();
    			File aFile = new File(aFileName);
    			if (aFile.exists()) {    	
    			    try {
						checkStyleText = Common.readFile(aFile).toString();
					} catch (IOException e) {
						e.printStackTrace();
					}
    			}
    		}
    	}
    	return checkStyleText;
    }

    public String createFullCheckStyleFileName() {
        return outputFolder + "/" + createLocalCheckStyleFileName();
    }


    boolean madeClassDescriptions;
    List<Class> classesImplicitlyLoaded;

    public List<Class> getImplicitlyLoadedClasses() {
        return classesImplicitlyLoaded;
    }

    public void maybeMakeClassDescriptions() {
    	// earlier it expected class descroptions to be fetched after running
        // but we need the class descriptions to find the main method sometimes
        // so removing this check
//        if (!runChecked && !hasBeenRun)
//            return;
//    	if (!isLoadClasses())
//    		return;
        if (madeClassDescriptions) {
            return;
        }

        makeClassDescriptions();
        madeClassDescriptions = true;

//        try { // Added by Josh: Exceptions can occur when making class descriptions
//            classesManager.makeClassDescriptions(this);
//            classViewManager = new AClassViewManager(classesManager);
//            classesTextManager = new AClassesTextManager(classViewManager);
//            classesTextManager.initializeAllSourcesText();
//            System.out.println("Write sources to:" + sourceFileName);
//            classesTextManager.writeAllSourcesText(sourceFileName);
//            madeClassDescriptions = true;
//        } catch (Exception e) {
//            System.out.println("Error making class descriptions");
//        }
    }

    public void makeClassDescriptions() {
        if (isNoProjectFolder()) {
            return;
        }

        try { // Added by Josh: Exceptions can occur when making class descriptions
            classesManager.makeClassDescriptions(this);
            classViewManager = new AClassViewManager(classesManager);
            classesTextManager = new AClassesTextManager(classViewManager);
            classesTextManager.initializeAllSourcesText();
//            System.out.println("Write sources to:" + sourceFileName);
            classesTextManager.writeAllSourcesText(sourceFileName);
            madeClassDescriptions = true;
        } catch (Exception e) {
            System.out.println("Error making class descriptions");
            e.printStackTrace();
        }
    }

    public String getOutputFileName() {
        return outputFileName;
    }
    

    public String getCheckStyleFileName() {
        return checkStyleFileName;
    }

    public boolean hasBeenRun() {
        return hasBeenRun;
    }

    public void setHasBeenRun(boolean newVal) {
        hasBeenRun = newVal;
        runChecked = true;
        if (hasBeenRun && proxyClassLoader != null) {
            classesImplicitlyLoaded = new ArrayList(proxyClassLoader.getClassesLoaded());
        }
    }

    public boolean hasBeenCompiled() {
		return hasBeenCompiled;
	}

	public void setHasBeenCompiled(boolean hasBeenCompiled) {
		this.hasBeenCompiled = hasBeenCompiled;
	}

	public boolean canBeCompiled() {
		return canBeCompiled;
	}

	public void setCanBeCompiled(boolean canBeCompiled) {
		this.canBeCompiled = canBeCompiled;
	}
	
	 public boolean hasBeenLoaded() {
			return hasBeenLoaded;
		}

		public void setHasBeenLoaded(boolean hasBeenLoaded) {
			this.hasBeenLoaded = hasBeenLoaded;
		}

		public boolean canBeLoaded() {
			return canBeLoaded;
		}

		public void setCanBeLoaded(boolean canBeLoaded) {
			this.canBeLoaded = canBeLoaded;
		}

	@Override()
    public boolean setRunParameters(String aMainClassName, String anArgs[][], String[] anInputFiles, String[] anOutputFiles, MainClassFinder aMainClassFinder) {
        args = anArgs;
        try {
            mainClassName = aMainClassName;
            mainClass = proxyClassLoader.loadClass(mainClassName);
            inputFiles = anInputFiles;
            outputFiles = anOutputFiles;
            if (mainClass == null) {
                mainClass = ((FlexibleMainClassFinder) mainClassFinder).mainClass(rootCodeFolder, proxyClassLoader, mainClassName, this);
            }
            if (mainClass == null) {
//                System.out.println("Missing main class:" + mainClassName + " for student:" + getProjectFolderName());
                setCanBeRun(false);
                MainClassNotFound.newCase(mainClassName, getProjectFolderName(), this);
                return false;
            }

            mainMethod = mainClass.getMethod("main", String[].class);
            if (mainMethod == null) {
//                System.out.println("Missing main method:" + "main");
                MainMethodNotFound.newCase(mainClassName, getProjectFolderName(), this);

                setCanBeRun(false);
                return false;
            }
            MainClassFound.newCase(mainClassName, getProjectFolderName(), this);

            return true;
        } catch (Exception e) {
            System.out.println("cannot  run:" + getProjectFolderName());
            setCanBeRun(false);
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public Thread runProject() {
        try {
            if (!canBeRun()) {
                return null;
            }
            Runnable runnable = ProjectRunnerSelector.createProjectRunner(mainClassName, args, this, inputFiles, outputFiles, mainClass, mainMethod);
            Thread retVal = new Thread(runnable);
            retVal.start();
            System.out.println("started:" + retVal);
            return retVal;
        } catch (Exception e) {
            System.out.println("Could not run:" + getProjectFolderName());
            setCanBeRun(false);
            e.printStackTrace();
            return null;
        }
    }

    public Thread run(String aMainClassName, String[][] anArgs, String[] anInputFiles, String[] anOutputFiles) {
        setRunParameters(aMainClassName, anArgs, anInputFiles, anOutputFiles, mainClassFinder);
        return runProject();
    }

    public AFlexibleProject(String aProjectFolder, String anOutputFolder) {
        init(aProjectFolder, anOutputFolder, aProjectFolder.endsWith(ZIP_SUFFIX_1) || aProjectFolder.endsWith(ZIP_SUFFIX_2) );

    }

    public AFlexibleProject(String aProjectFolder) {
        init(aProjectFolder, outputFolder, aProjectFolder.endsWith(ZIP_SUFFIX_1) || aProjectFolder.endsWith(ZIP_SUFFIX_2));

    }

    public ProxyClassLoader getClassLoader() {
        return proxyClassLoader;
    }

    public ProxyBasedClassesManager getClassesManager() {
        maybeMakeClassDescriptions();
        return classesManager;
    }

    public void setClassesManager(ProxyBasedClassesManager aClassesManager) {
        this.classesManager = aClassesManager;
    }

    public ClassViewManager getClassViewManager() {
        maybeMakeClassDescriptions();
        return classViewManager;
    }

    public void setClassViewManager(ClassViewManager aClassViewManager) {
        this.classViewManager = aClassViewManager;
    }

    public ClassesTextManager getClassesTextManager() {
        maybeMakeClassDescriptions();
        return classesTextManager;
    }

    public void setClassesTextManager(ClassesTextManager aClassesTextManager) {
        this.classesTextManager = aClassesTextManager;
    }

    public void setProjectFolder(String aProjectFolder) {
        this.projectFolderName = aProjectFolder;
    }

    public String getProjectFolderName() {
        return projectFolderName;
    }

    public RootCodeFolder getRootCodeFolder() {
        return rootCodeFolder;
    }

    @Override
    public String getSourceProjectFolderName() {
        return rootCodeFolder.getSourceProjectFolderName();
    }

    @Override
    public String getSourceFileName() {
        return sourceFileName;
    }

    @Override
    public String getBinaryProjectFolderName() {
        return rootCodeFolder.getBinaryProjectFolderName();
    }

    @Override
    public boolean runChecked() {
        return runChecked;
    }

    @Override
    public void setCanBeRun(boolean newVal) {
        runChecked = true;
        canBeRun = newVal;

    }

    @Override
    public boolean canBeRun() {
        return canBeRun;
    }

    @Override
    public JavaDocBuilder getJavaDocBuilder() {
        if (javaDocBuilder == null) {
            javaDocBuilder = new JavaDocBuilder();
        }
        return javaDocBuilder;
    }

    @Override
    public StringBuffer getCurrentOutput() {
        return currentOutput;
    }

    @Override
    public void clearOutput() {
        currentOutput.setLength(0);
        try {
            FileWriter fileWriter = new FileWriter(new File(outputFileName));
            OverallTranscriptCleared.newCase(null, null, (SakaiProject) this, outputFileName, this);
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    @Override
    public void setCurrentOutput(StringBuffer currentOutput) {
        this.currentOutput = currentOutput;
    }

    @Override
    public Checkable getCurrentGradingFeature() {
        return currentGradingFeature;
    }

    @Override
    public void setCurrentGradingFeature(Checkable currentGradingFeature) {
        this.currentGradingFeature = currentGradingFeature;
    }

    @Override
    public String getCurrentInput() {
        return currentInput.toString();
    }

    @Override
    public void setCurrentInput(String aCurrentInput) {
        currentInput.setLength(0);
        appendCurrentInput(aCurrentInput);
    }

    @Override
    public void appendCurrentInput(String aCurrentInput) {
        currentInput.append(aCurrentInput);
    }

//    @Override
//  	public void appendCurrentInput(String aProcess, String aCurrentInput) {
////  		currentInput.append(aCurrentInput);
//    }
    @Override
    public String[] getCurrentArgs() {
        return currentArgs;
    }

    @Override
    public void setCurrentArgs(String[] currentArgs) {
        this.currentArgs = currentArgs;
    }

    @Override
    public String getSourceSuffix() {
        return sourceSuffix;
    }

    @Override
    public boolean hasUnCompiledClasses() {
        // TODO Auto-generated method stub
        return classNamesThatCouldNotBeCompiled.size() > 0;
    }

    @Override
    public List<String> getNonCompiledClasses() {
        return classNamesThatCouldNotBeCompiled;
    }

    @Override
    public void addNonCompiledClass(String newVal) {
        classNamesThatCouldNotBeCompiled.add(newVal);

    }

    @Override
    public boolean hasCompiledClasses() {
        // TODO Auto-generated method stub
        return classNamesCompiled.size() > 0;
    }

    @Override
    public List<String> getCompiledClasses() {
        return classNamesCompiled;
    }

    @Override
    public void addCompiledClass(String newVal) {
        classNamesCompiled.add(newVal);

    }
//    static boolean loadClasses = false;
//
//    static boolean compileMissingObjectCode = false;
//    static boolean unzipFiles = false;
// 
//
//	static boolean preCompileMissingObjectCode = false;
//    public static boolean isLoadClasses() {
//        return loadClasses;
//    }
//
//    public static void setLoadClasses(boolean makeClassDescriptions) {
//        AProject.loadClasses = makeClassDescriptions;
//    }
//
//    public static boolean isCompileMissingObjectCode() {
//        return compileMissingObjectCode;
//    }
//
//    public static void setCompileMissingObjectCode(boolean newVal) {
//        AProject.compileMissingObjectCode = newVal;
//    }
//
//    public static boolean isForceCompile() {
//        return forceCompile;
//    }
//
//    public static void setForceCompile(boolean forceCompile) {
//        AProject.forceCompile = forceCompile;
//    }
//
//    public static boolean isPreCompileMissingObjectCode() {
//        return preCompileMissingObjectCode;
//    }
//
//    public static void setPrecompileMissingObjectCode(
//            boolean preCompileMissingObjectCode) {
//        AProject.preCompileMissingObjectCode = preCompileMissingObjectCode;
//    }
    @Override
    public  boolean isFilesCompiled() {
        return filesCompiled;
    }
    @Override

    public  void setFilesCompiled(boolean filesCompiled) {
        this.filesCompiled = filesCompiled;
    }
    @Override
    public  boolean isFilesUnzipped() {
		return filesUnzipped;
	}
    @Override
	public  void setFilesUnzipped(boolean filesUnzipped) {
		this.filesUnzipped = filesUnzipped;
	}
//	   public static boolean isUnzipFiles() {
//			return unzipFiles;
//		}
//
//		public static void setUnzipFiles(boolean unzipFiles) {
//			AProject.unzipFiles = unzipFiles;
//		}
		public TestCase getCurrentTestCase() {
			return currentTestCase;
		}

		public void setCurrentTestCase(TestCase currentTestCase) {
			this.currentTestCase = currentTestCase;
		}

//	    public static boolean isCheckStyle() {
//			return checkStyle;
//		}

//	    public static void setCheckStyle(boolean checkStyle) {
//			AProject.checkStyle = checkStyle;
//		}
	    public Map<String, String> getEntryPoints() {
	    	if (entryPoints == null) {
				entryPoints = LanguageDependencyManager.getMainClassFinder()
						.getEntryPoints(getWrapper(), StaticConfigurationUtils.getPotentialMainEntryPointNames());

			}
			return entryPoints;
//			return entryPoints;
		}

		public void setEntryPoints(Map<String, String> entryPoints) {
			this.entryPoints = entryPoints;
		}
		@Override
		public RunningProject getCurrentRunningProject() {
			return currentRunningProject;
		}
		@Override

		public void setCurrentRunningProject(RunningProject currentRunningProject) {
			this.currentRunningProject = currentRunningProject;
		}
		  @Override
		     public ProjectWrapper getWrapper() {
		 		return wrapper;
		 	}
		     @Override
		     public void setWrapper(ProjectWrapper newValue) {
		 		this.wrapper = newValue;
		 	}
}
]]></snapshot>
  </Command>
  <Command __id="6363" _type="MoveCaretCommand" caretOffset="460" date="Sat Aug 24 16:30:09 EDT 2019" docOffset="2237" timestamp="102932355" />
  <Command __id="6364" _type="FileOpenCommand" date="Sat Aug 24 16:30:13 EDT 2019" docASTNodeCount="270" docActiveCodeLength="2274" docExpressionCount="185" docLength="3087" projectName="comp110-grader" timestamp="102936307">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\project\flexible\AProxyBasedClassesManager.java]]></filePath>
    <snapshot><![CDATA[package grader.project.flexible;

import grader.basics.settings.BasicGradingEnvironment;
import grader.basics.util.GraderFileUtils;
import grader.execution.ProxyBasedClassesManager;
import grader.execution.ProxyClassLoader;
import grader.file.FileProxy;
import grader.language.LanguageDependencyManager;
import grader.project.folder.RootCodeFolder;

import java.util.List;

import util.misc.Common;

// this makes the class descriptions providing the text to each class
// It uses the file proxy
public class AProxyBasedClassesManager extends AFlexibleClassesManager implements ProxyBasedClassesManager {

    /* (non-Javadoc)
     * @see grader.project.ClassesManager#makeSourceCodeDescriptions(java.lang.String, boolean)
     */
    // ignoring second parameter
    @Override
    public void makeClassDescriptions(String aProjectDirectory, boolean aSeparateSrcBin) {
        FlexibleProject project = new AFlexibleProject(aProjectDirectory);
        makeClassDescriptions(project);
    }

    public void makeClassDescriptions(FlexibleProject aProject) {
//    	RootCodeFolder aRootCodeFolder = aProject.getRootCodeFolder();
    	
        List<FileProxy> entries = aProject.getRootCodeFolder().getFileEntries();
        String projectPath = aProject.getRootCodeFolder().getAbsoluteName();
        ProxyClassLoader classLoader = null;
        // we no longer need this check as we are allowing classes to be loaded before running
//        if (aProject.canBeRun() && aProject.hasBeenRun()) {
        if (BasicGradingEnvironment.get().isLoadClasses())
            classLoader = aProject.getClassLoader();
//        }
        makeClassDescriptions(aProject.getSourceProjectFolderName(), entries, classLoader, aProject);
    }

    /* (non-Javadoc)
     * @see grader.project.ClassesManager#makeClassDescriptions(java.io.File, java.io.File)
     */
    void makeClassDescriptions(String srcFolderName, List<FileProxy> aFiles, ProxyClassLoader aClassLoder, FlexibleProject aProject) {
        for (FileProxy aFile : aFiles) {
            String locaName = aFile.getMixedCaseLocalName();

            if (locaName != null && locaName.endsWith(LanguageDependencyManager.getSourceFileSuffix())) {
//                if (locaName != null && locaName.endsWith(SOURCE_FILE_SUFFIX)) {

        //System.out.println(this.getClass().getName());
                String relativeName = GraderFileUtils.toRelativeName(srcFolderName, aFile.getMixedCaseAbsoluteName());
                String className = Common.projectRelativeNameToClassName(relativeName);
                StringBuffer text = Common.toText(aFile.getInputStream());
                FlexibleClassDescription classDescription = new AClassDescription(className, text, aFile.getTime(), aClassLoder, aProject, aFile);
                put(className, classDescription);

                // Added by Josh: The tag to class description map is never added to. This is doing just that.
                put(classDescription.getTags(), classDescription);
            }
        }
    }
}
]]></snapshot>
  </Command>
  <Command __id="6365" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 16:30:13 EDT 2019" docOffset="0" timestamp="102936466" />
  <Command __id="6366" _type="FileOpenCommand" date="Sat Aug 24 16:30:15 EDT 2019" docASTNodeCount="172" docActiveCodeLength="1137" docExpressionCount="98" docLength="1443" projectName="comp110-grader" timestamp="102938301">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\project\flexible\FlexibleClassDescription.java]]></filePath>
    <snapshot><![CDATA[package grader.project.flexible;

import grader.file.FileProxy;

import java.io.IOException;

import util.javac.SourceClass;
import bus.uigen.reflect.ClassProxy;

import com.github.antlrjavaparser.api.CompilationUnit;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaSource;
// gets source and object file for a class
public interface FlexibleClassDescription {
	public ClassProxy getClassProxy() ;
	public void setClassProxy(ClassProxy classProxy) ;
	public StringBuffer getText() ;
	public void setText(StringBuffer text) ;	
	public long getSourceTime() ;
	public void setSourceTime(long newVal);
	public String getClassName();
	public String getPackageName();
	String[] getTags();
	String getStructurePatternName();
	String[] getPropertyNames();
	String[] getEditablePropertyNames();
	JavaClass getQdoxClass();
	JavaSource getQdoxSource();
	SourceClass getJavacSourceClass();
    Class<?> getJavaClass();

    CompilationUnit getCompilationUnit() throws IOException;
    public FileProxy getSourceFile() ;
	public void setSourceFile(FileProxy sourceFile) ;
	FlexibleProject getProject();
	
	
//	public List<String> getClassNamesThatCouldNotBeCompiled();
//	public void setClassNamesThatCouldNotBeCompiled(List<String> classNamesToCompile) ;
//	public List<String> getClassNamesCompiled();
//	public void setClassNamesCompiled(List<String> classNamesCompiled);

}]]></snapshot>
  </Command>
  <Command __id="6367" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 16:30:15 EDT 2019" docOffset="0" timestamp="102938467" />
  <DocumentChange __id="6476" _type="Insert" date="Sat Aug 24 16:32:46 EDT 2019" docASTNodeCount="916" docActiveCodeLength="6330" docExpressionCount="520" docLength="6615" length="2" offset="1484" timestamp="103089525">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="6477" _type="Insert" date="Sat Aug 24 16:32:46 EDT 2019" docASTNodeCount="916" docActiveCodeLength="6220" docExpressionCount="520" docLength="6617" length="2" offset="1571" timestamp="103089528">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="6478" _type="Insert" date="Sat Aug 24 16:32:46 EDT 2019" docASTNodeCount="914" docActiveCodeLength="6211" docExpressionCount="519" docLength="6619" length="2" offset="1685" timestamp="103089530">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="6479" _type="Insert" date="Sat Aug 24 16:32:46 EDT 2019" docASTNodeCount="912" docActiveCodeLength="6209" docExpressionCount="519" docLength="6621" length="2" offset="1698" timestamp="103089531">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="6480" _type="Insert" date="Sat Aug 24 16:32:46 EDT 2019" docASTNodeCount="912" docActiveCodeLength="6208" docExpressionCount="519" docLength="6623" length="2" offset="1704" timestamp="103089533">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="6481" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.toggle.comment" date="Sat Aug 24 16:32:46 EDT 2019" timestamp="103089547" />
  <Command __id="6482" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sat Aug 24 16:32:47 EDT 2019" timestamp="103090350" />
  <Command __id="6483" _type="MoveCaretCommand" caretOffset="1744" date="Sat Aug 24 16:32:50 EDT 2019" docOffset="1744" timestamp="103093100" />
  <Command __id="6484" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.DebugLast" date="Sat Aug 24 16:32:50 EDT 2019" timestamp="103094065" />
  <Command __id="6485" _type="EclipseCommand" commandID="" date="Sat Aug 24 16:32:50 EDT 2019" repeat="4" timestamp="103094073" timestamp2="103094217" />
  <Command __id="6489" _type="RunCommand" date="Sat Aug 24 16:32:51 EDT 2019" kind="HitBreakPoint" projectName="comp110-grader" timestamp="103094447" type="Run" />
  <Command __id="6490" _type="RunCommand" date="Sat Aug 24 16:32:51 EDT 2019" kind="HitBreakPoint" projectName="comp110-grader" timestamp="103094447" type="Run" />
  <Command __id="6491" _type="RunCommand" date="Sat Aug 24 16:32:51 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103094956" type="Run" />
  <Command __id="6492" _type="RunCommand" date="Sat Aug 24 16:32:51 EDT 2019" kind="StepInto" projectName="(Unknown)" timestamp="103095028" type="Run" />
  <Command __id="6493" _type="RunCommand" date="Sat Aug 24 16:32:52 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103095616" type="Run" />
  <Command __id="6494" _type="EHExceptionCommand" date="Sat Aug 24 16:32:53 EDT 2019" timestamp="103096172" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
]]></outputString>
  </Command>
  <Command __id="6495" _type="RunCommand" date="Sat Aug 24 16:32:53 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103096202" type="Run" />
  <Command __id="6496" _type="FileOpenCommand" date="Sat Aug 24 16:32:53 EDT 2019" docASTNodeCount="75" docActiveCodeLength="615" docExpressionCount="50" docLength="720" projectName="comp110-grader" timestamp="103096660">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\demoAndTest\interpretedSpec\java\AJavaMixedArithmeticIntrepretedInputGraderTester.java]]></filePath>
  </Command>
  <Command __id="6497" _type="MoveCaretCommand" caretOffset="601" date="Sat Aug 24 16:32:53 EDT 2019" docOffset="671" timestamp="103096781" />
  <Command __id="6498" _type="PredictionCommand" date="Sat Aug 24 16:32:53 EDT 2019" prediction_type="MakingProgress" timestamp="103096783" />
  <Command __id="6499" _type="BreakPointCommand" date="Sat Aug 24 16:32:56 EDT 2019" lineNumber="17" timestamp="103099215" type="BreakPointRemoved" />
  <Command __id="6500" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.debug.CompilationUnitEditor.BreakpointRulerActions/org.eclipse.jdt.debug.ui.actions.ManageBreakpointRulerAction" date="Sat Aug 24 16:32:56 EDT 2019" timestamp="103099236" />
  <Command __id="6501" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.Resume" date="Sat Aug 24 16:32:57 EDT 2019" timestamp="103100313" />
  <Command __id="6502" _type="RunCommand" date="Sat Aug 24 16:32:57 EDT 2019" kind="StepInto" projectName="(Unknown)" timestamp="103100313" type="Run" />
  <Command __id="6503" _type="RunCommand" date="Sat Aug 24 16:32:58 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103101485" type="Run" />
  <Command __id="6504" _type="RunCommand" date="Sat Aug 24 16:32:58 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103101486" type="Run" />
  <Command __id="6505" _type="RunCommand" date="Sat Aug 24 16:32:58 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103101487" type="Run" />
  <Command __id="6506" _type="RunCommand" date="Sat Aug 24 16:32:58 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="103101488" type="Run" />
  <Command __id="6507" _type="ShellCommand" date="Sat Aug 24 16:32:58 EDT 2019" timestamp="103101615" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6508" _type="EHExceptionCommand" date="Sat Aug 24 16:32:58 EDT 2019" timestamp="103101642" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="6509" _type="ShellCommand" date="Sat Aug 24 16:32:59 EDT 2019" timestamp="103102103" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6515" _type="FileOpenCommand" date="Sat Aug 24 16:33:23 EDT 2019" docASTNodeCount="912" docActiveCodeLength="6208" docExpressionCount="519" docLength="6623" projectName="GraderBasics" timestamp="103126885">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\requirements\interpreter\specification\ACSVRequirementsSpecification.java]]></filePath>
    <snapshot><![CDATA[package grader.requirements.interpreter.specification;

//import framework.grading.FrameworkProjectRequirements;
import grader.file.FileProxy;
//import grader.sakai.project.SakaiProjectDatabase;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;

import au.com.bytecode.opencsv.CSVReader;
//import bus.uigen.Message;

public class ACSVRequirementsSpecification implements CSVRequirementsSpecification {
	public static final String TYPE_NAME = "Type";
	public static final int TYPE_COLUMN = 0;
	public static final int DESCRIPTION_COLUMN = TYPE_COLUMN+1;
	public static final int MAX_SCORE_COLUMN = DESCRIPTION_COLUMN + 1;
	public static final  int TIMEOUT_COLUMN = MAX_SCORE_COLUMN + 1;
	public static final  int INPUT_COLUMN = TIMEOUT_COLUMN + 1;
	public static final  int MODEL_OUTPUT_COLUMN = INPUT_COLUMN + 1;
	public static final int EXTRA_CREDIT_COLUMN = MODEL_OUTPUT_COLUMN + 1;
	public static final  int CHECKER_COLUMN = EXTRA_CREDIT_COLUMN  + 1;
	public static final  int START_CHECKER_ARGUMENTS_COLUMN = CHECKER_COLUMN + 1;
	
	protected int headerRow = 0;
	protected int numRequirements;
	FileProxy specificationSpreadsheet; // w
	
	List<String[]>  table;
	protected boolean valid;
//	protected FrameworkProjectRequirements projectRequirements;
  


	public ACSVRequirementsSpecification(FileProxy aSpecificationSpreadsheet) {
		specificationSpreadsheet = aSpecificationSpreadsheet;	
		init();
	}
	
//	public ACSVRequirementsSpecification(SakaiProjectDatabase aSakaiProjectDatabase) {
//		specificationSpreadsheet = aSakaiProjectDatabase.getAssignmentDataFolder().getRequirementsSpreadsheetFile();
//		init();
//	}
//	
	protected void init() {
		maybeCreateTable();
		headerRow = getHeaderRowNum(table);
		valid = headerRow >= 0;
		makeRequirements();
		

	}
	
	protected void makeRequirements() {
		if (isValid()) {
			numRequirements = table.size() - (headerRow + 1);
			
		}
		
	}
	
	protected void maybeCreateTable() {
		if (table != null)
			return;
		createTable();
		
	}
	
	protected void createTable() {
		
		try {
			InputStream input = specificationSpreadsheet.getInputStream();
			CSVReader csvReader 	=	new CSVReader(new InputStreamReader(input));
		     table = csvReader.readAll();
			csvReader.close();
			input.close();
			
		   
	    
	    
		} catch (Exception e) {
			e.printStackTrace();
		
			
		}
		
	}
	
	
	
	public int getHeaderRowNum(List<String[]> aSheet) {
		 for (int rowNum = 0; rowNum < aSheet.size(); rowNum ++) {
			 String[] aRow = aSheet.get(rowNum);
			 if (aRow[TYPE_COLUMN].equalsIgnoreCase(TYPE_NAME))
				 return rowNum;
		 }
		 return -1;
		
	}
	
	
	
	
	
	public FileProxy getSpecificationSpreadsheet() {
		return specificationSpreadsheet;
	}

	public String getFileName() {
		return specificationSpreadsheet.getMixedCaseAbsoluteName();
	}

	public boolean isValid() {
		return valid;
	}

	public void setValid(boolean newValue) {
		this.valid = newValue;
	}

	public List<String[]> getTable() {
		return table;
	}
	@Override
	public int getNumberOfRequirements() {
		return numRequirements;
	}
	@Override
	public String getArg(int aRequirementNum, int anArgNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		int aColumnNum = START_CHECKER_ARGUMENTS_COLUMN + anArgNum;
		return table.get(aRowNum)[aColumnNum];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have arg " + anArgNum);
			return null;
		}
	}
	public String getType(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[TYPE_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have type ");
			return null;
		}
	}
	
	public String getDescription(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[DESCRIPTION_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have description ");
			return null;
		}
	}
	@Override
	public Double getMaxScore(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return Double.parseDouble(table.get(aRowNum)[MAX_SCORE_COLUMN]);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score");
			return null;
		}
	}
	
	@Override
	public Integer getTimeOut(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		String aTimeOut = table.get(aRowNum)[TIMEOUT_COLUMN];
		if (aTimeOut == null || aTimeOut.isEmpty())
			return null;
		return Integer.parseInt(aTimeOut);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have timeout");
			return null;
		}
	}
	@Override
	public boolean isExtraCredit(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[EXTRA_CREDIT_COLUMN].replaceAll("\\s+", "");
			return !aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have extra credit");
				return false;
			}
	}
	
	
	@Override
	public boolean isManual(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[CHECKER_COLUMN].replaceAll("\\s+", "");
			return aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have checker column");
				return false;
			}
	}

	
	public String getInput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[INPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score ");
			return null;
		}
	}
	public String getModelOutput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[MODEL_OUTPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have model output");
			return null;
		}
	}
	public String getChecker(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[CHECKER_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have a function");
			return null;
		}
	}
	

}
]]></snapshot>
  </Command>
  <Command __id="6916" _type="MoveCaretCommand" caretOffset="4263" date="Sat Aug 24 17:05:41 EDT 2019" docOffset="4468" timestamp="105064789" />
  <Command __id="6917" _type="EclipseCommand" commandID="org.eclipse.debug.ui.commands.DebugLast" date="Sat Aug 24 17:05:43 EDT 2019" timestamp="105066338" />
  <Command __id="6918" _type="RunCommand" date="Sat Aug 24 17:05:43 EDT 2019" kind="HitBreakPoint" projectName="PL_Java" timestamp="105066581" type="Run" />
  <Command __id="6919" _type="RunCommand" date="Sat Aug 24 17:05:43 EDT 2019" kind="HitBreakPoint" projectName="PL_Java" timestamp="105066581" type="Run" />
  <Command __id="6920" _type="RunCommand" date="Sat Aug 24 17:05:43 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105066800" type="Run" />
  <Command __id="6921" _type="RunCommand" date="Sat Aug 24 17:05:43 EDT 2019" kind="StepInto" projectName="(Unknown)" timestamp="105066917" type="Run" />
  <Command __id="6922" _type="RunCommand" date="Sat Aug 24 17:05:43 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105067070" type="Run" />
  <Command __id="6923" _type="EHExceptionCommand" date="Sat Aug 24 17:05:44 EDT 2019" timestamp="105067156" type="Exception">
    <outputString><![CDATA[I***Tracer: showInfo = true
Buffer traced nessages =false
]]></outputString>
  </Command>
  <Command __id="6924" _type="RunCommand" date="Sat Aug 24 17:05:44 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105067992" type="Run" />
  <Command __id="6925" _type="RunCommand" date="Sat Aug 24 17:05:44 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105067993" type="Run" />
  <Command __id="6926" _type="RunCommand" date="Sat Aug 24 17:05:44 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105067994" type="Run" />
  <Command __id="6927" _type="RunCommand" date="Sat Aug 24 17:05:44 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105067995" type="Run" />
  <Command __id="6928" _type="EHExceptionCommand" date="Sat Aug 24 17:05:45 EDT 2019" timestamp="105068367" type="Exception">
    <outputString><![CDATA[ObjectEditor(Version 22, built on Thu Dec 06 16:26:09 EST 2018). Copyright Prasun Dewan, 2012, All rights reserved. US Patent Appl. No.: 12/532,327
]]></outputString>
  </Command>
  <Command __id="6929" _type="ShellCommand" date="Sat Aug 24 17:05:46 EDT 2019" timestamp="105069233" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6930" _type="ShellCommand" date="Sat Aug 24 17:06:22 EDT 2019" timestamp="105105501" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6931" _type="RunCommand" date="Sat Aug 24 17:06:22 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105105662" type="Debug" />
  <Command __id="6932" _type="RunCommand" date="Sat Aug 24 17:06:22 EDT 2019" kind="HitBreakPoint" projectName="(Unknown)" timestamp="105105662" type="Debug" />
  <Command __id="6933" _type="RunCommand" date="Sat Aug 24 17:06:22 EDT 2019" kind="HitBreakPoint" projectName="PL_Java" timestamp="105105662" type="Run" />
  <Command __id="6935" _type="SelectTextCommand" caretOffset="1418" date="Sat Aug 24 17:08:01 EDT 2019" end="1418" start="1400" timestamp="105204884" />
  <Command __id="6937" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 17:08:14 EDT 2019" docOffset="0" timestamp="105217413" />
  <Command __id="6939" _type="MoveCaretCommand" caretOffset="0" date="Sat Aug 24 17:08:18 EDT 2019" docOffset="0" timestamp="105221675" />
  <Command __id="6940" _type="ShellCommand" date="Sat Aug 24 17:10:30 EDT 2019" timestamp="105353352" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6941" _type="ShellCommand" date="Sat Aug 24 17:10:37 EDT 2019" timestamp="105360788" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="6945" _type="ShellCommand" date="Sat Aug 24 17:12:01 EDT 2019" timestamp="105444937" type="ECLIPSE_MINIMIZED" />
  <Command __id="6972" _type="MoveCaretCommand" caretOffset="326" date="Sat Aug 24 17:17:50 EDT 2019" docOffset="1291" timestamp="105793817" />
  <Command __id="6973" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sat Aug 24 17:17:52 EDT 2019" timestamp="105795226" />
  <Command __id="6974" _type="MoveCaretCommand" caretOffset="223" date="Sat Aug 24 17:18:20 EDT 2019" docOffset="1188" timestamp="105823409" />
  <Command __id="6976" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 17:18:21 EDT 2019" timestamp="105824656" />
  <Command __id="6977" _type="SelectTextCommand" caretOffset="185" date="Sat Aug 24 17:18:21 EDT 2019" end="185" start="178" timestamp="105824736" />
  <Command __id="6979" _type="SelectTextCommand" caretOffset="16444" date="Sat Aug 24 17:18:45 EDT 2019" end="16444" start="16432" timestamp="105848147" />
  <Command __id="6981" _type="MoveCaretCommand" caretOffset="2717" date="Sat Aug 24 17:19:20 EDT 2019" docOffset="3569" timestamp="105883137" />
  <Command __id="6983" _type="SelectTextCommand" caretOffset="16444" date="Sat Aug 24 17:19:22 EDT 2019" end="16444" start="16432" timestamp="105885941" />
  <Command __id="6984" _type="MoveCaretCommand" caretOffset="2237" date="Sat Aug 24 17:19:33 EDT 2019" docOffset="3202" timestamp="105896440" />
  <Command __id="6985" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 17:19:34 EDT 2019" timestamp="105897431" />
  <Command __id="6986" _type="MoveCaretCommand" caretOffset="7690" date="Sat Aug 24 17:20:03 EDT 2019" docOffset="8655" timestamp="105926776" />
  <Command __id="6987" _type="MoveCaretCommand" caretOffset="199" date="Sat Aug 24 17:20:10 EDT 2019" docOffset="1164" timestamp="105933593" />
  <Command __id="6988" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.type.hierarchy" date="Sat Aug 24 17:20:13 EDT 2019" timestamp="105936717" />
  <Command __id="6990" _type="MoveCaretCommand" caretOffset="238" date="Sat Aug 24 17:20:33 EDT 2019" docOffset="861" timestamp="105956922" />
  <Command __id="6992" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 17:20:35 EDT 2019" timestamp="105958802" />
  <Command __id="6993" _type="SelectTextCommand" caretOffset="113" date="Sat Aug 24 17:20:35 EDT 2019" end="113" start="103" timestamp="105958882" />
  <Command __id="6995" _type="MoveCaretCommand" caretOffset="460" date="Sat Aug 24 17:21:49 EDT 2019" docOffset="2237" timestamp="106032502" />
  <Command __id="6997" _type="ShellCommand" date="Sat Aug 24 17:22:06 EDT 2019" timestamp="106049339" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="6998" _type="FindCommand" caseSensitive="true" date="Sat Aug 24 17:22:13 EDT 2019" forward="true" matchWord="false" offset="2237" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="106056771" wrapSearch="true">
    <searchString><![CDATA[source]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="6999" _type="FindCommand" caseSensitive="true" date="Sat Aug 24 17:22:20 EDT 2019" forward="true" matchWord="false" offset="6098" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="106063227" wrapSearch="true">
    <searchString><![CDATA[source]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="7000" _type="ShellCommand" date="Sat Aug 24 17:22:26 EDT 2019" timestamp="106069746" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="7001" _type="MoveCaretCommand" caretOffset="8450" date="Sat Aug 24 17:22:38 EDT 2019" docOffset="10227" timestamp="106081567" />
  <Command __id="7002" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sat Aug 24 17:22:39 EDT 2019" timestamp="106082557" />
  <Command __id="7003" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sat Aug 24 17:22:48 EDT 2019" timestamp="106091720" />
  <Command __id="8168" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:07:44 EDT 2019" timestamp="162787729" />
  <Command __id="8169" _type="SelectTextCommand" caretOffset="35386" date="Sun Aug 25 09:07:44 EDT 2019" end="35386" start="35341" timestamp="162787810" />
  <Command __id="8170" _type="MoveCaretCommand" caretOffset="35514" date="Sun Aug 25 09:08:04 EDT 2019" docOffset="35918" timestamp="162807984" />
  <Command __id="8171" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:08:05 EDT 2019" timestamp="162808781" />
  <Command __id="8173" _type="ShellCommand" date="Sun Aug 25 09:08:12 EDT 2019" timestamp="162815748" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8174" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:08:20 EDT 2019" forward="true" matchWord="false" offset="32820" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162823083" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfiguration]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8175" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:08:23 EDT 2019" forward="true" matchWord="false" offset="33652" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162826808" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfiguration]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8176" _type="ShellCommand" date="Sun Aug 25 09:08:26 EDT 2019" timestamp="162829841" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8177" _type="ShellCommand" date="Sun Aug 25 09:08:30 EDT 2019" timestamp="162833849" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8178" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:08:30 EDT 2019" forward="true" matchWord="false" offset="34255" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162834007" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfiguration]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8179" _type="ShellCommand" date="Sun Aug 25 09:08:37 EDT 2019" timestamp="162840300" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8180" _type="MoveCaretCommand" caretOffset="337" date="Sun Aug 25 09:08:46 EDT 2019" docOffset="741" timestamp="162849653" />
  <Command __id="8181" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.type.hierarchy" date="Sun Aug 25 09:08:48 EDT 2019" timestamp="162851893" />
  <Command __id="8183" _type="SelectTextCommand" caretOffset="586" date="Sun Aug 25 09:08:51 EDT 2019" end="586" start="562" timestamp="162854800" />
  <Command __id="8185" _type="ShellCommand" date="Sun Aug 25 09:09:56 EDT 2019" timestamp="162919807" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8186" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:00 EDT 2019" forward="true" matchWord="false" offset="1651" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162923130" wrapSearch="true">
    <searchString><![CDATA[Driver]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8187" _type="ShellCommand" date="Sun Aug 25 09:10:11 EDT 2019" timestamp="162934124" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8188" _type="ShellCommand" date="Sun Aug 25 09:10:13 EDT 2019" timestamp="162936334" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8189" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:25 EDT 2019" forward="true" matchWord="false" offset="51122" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162948236" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8190" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:29 EDT 2019" forward="true" matchWord="false" offset="1037" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162952576" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8191" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:42 EDT 2019" forward="true" matchWord="false" offset="7142" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162965211" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8192" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:42 EDT 2019" forward="true" matchWord="false" offset="7409" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162965771" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8193" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:43 EDT 2019" forward="true" matchWord="false" offset="7545" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162966250" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8194" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:45 EDT 2019" forward="true" matchWord="false" offset="7997" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162968360" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8195" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:46 EDT 2019" forward="true" matchWord="false" offset="8696" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162970073" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8196" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:47 EDT 2019" forward="true" matchWord="false" offset="9054" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162970639" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8197" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:48 EDT 2019" forward="true" matchWord="false" offset="9431" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162971918" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8198" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:49 EDT 2019" forward="true" matchWord="false" offset="9795" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162972549" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8199" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:10:55 EDT 2019" forward="true" matchWord="false" offset="10157" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162978546" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8200" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:11:00 EDT 2019" forward="true" matchWord="false" offset="11040" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162983908" wrapSearch="true">
    <searchString><![CDATA[PropertiesConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8201" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:11:10 EDT 2019" forward="true" matchWord="false" offset="11391" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="162993410" wrapSearch="true">
    <searchString><![CDATA[getInher]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8202" _type="ShellCommand" date="Sun Aug 25 09:11:27 EDT 2019" timestamp="163010476" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8203" _type="MoveCaretCommand" caretOffset="11989" date="Sun Aug 25 09:11:27 EDT 2019" docOffset="11989" timestamp="163010576" />
  <Command __id="8204" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:11:28 EDT 2019" timestamp="163011987" />
  <Command __id="8205" _type="ShellCommand" date="Sun Aug 25 09:11:53 EDT 2019" timestamp="163036105" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8206" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:11:59 EDT 2019" forward="true" matchWord="false" offset="12939" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="163042139" wrapSearch="true">
    <searchString><![CDATA[courseConfi]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8207" _type="ShellCommand" date="Sun Aug 25 09:12:29 EDT 2019" timestamp="163072616" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8208" _type="MoveCaretCommand" caretOffset="36611" date="Sun Aug 25 09:12:29 EDT 2019" docOffset="36611" timestamp="163072690" />
  <Command __id="8210" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:12:36 EDT 2019" timestamp="163080014" />
  <Command __id="8211" _type="SelectTextCommand" caretOffset="548" date="Sun Aug 25 09:12:37 EDT 2019" end="548" start="526" timestamp="163080104" />
  <Command __id="8212" _type="ShellCommand" date="Sun Aug 25 09:12:40 EDT 2019" timestamp="163083920" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8213" _type="ShellCommand" date="Sun Aug 25 09:12:41 EDT 2019" timestamp="163084104" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8214" _type="MoveCaretCommand" caretOffset="516" date="Sun Aug 25 09:12:42 EDT 2019" docOffset="574" timestamp="163085780" />
  <Command __id="8215" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.type.hierarchy" date="Sun Aug 25 09:12:43 EDT 2019" timestamp="163086441" />
  <Command __id="8216" _type="MoveCaretCommand" caretOffset="111" date="Sun Aug 25 09:12:53 EDT 2019" docOffset="169" timestamp="163096556" />
  <Command __id="8217" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.type.hierarchy" date="Sun Aug 25 09:12:54 EDT 2019" timestamp="163097726" />
  <Command __id="8219" _type="SelectTextCommand" caretOffset="106" date="Sun Aug 25 09:12:57 EDT 2019" end="106" start="85" timestamp="163100526" />
  <Command __id="8221" _type="ShellCommand" date="Sun Aug 25 09:12:59 EDT 2019" timestamp="163102517" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8117" _type="FileOpenCommand" date="Sun Aug 25 09:03:14 EDT 2019" docASTNodeCount="916" docActiveCodeLength="6216" docExpressionCount="523" docLength="6524" projectName="GraderBasics" timestamp="162517391">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\requirements\interpreter\specification\ACSVRequirementsSpecification.java]]></filePath>
    <snapshot><![CDATA[package grader.basics.requirements.interpreter.specification;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;

import au.com.bytecode.opencsv.CSVReader;
//import bus.uigen.Message;
import grader.basics.file.FileProxy;

public class ACSVRequirementsSpecification implements CSVRequirementsSpecification {
	public static final String TYPE_NAME = "Type";
	public static final int TYPE_COLUMN = 0;
	public static final int DESCRIPTION_COLUMN = TYPE_COLUMN+1;
	public static final int MAX_SCORE_COLUMN = DESCRIPTION_COLUMN + 1;
	public static final  int TIMEOUT_COLUMN = MAX_SCORE_COLUMN + 1;
	public static final  int INPUT_COLUMN = TIMEOUT_COLUMN + 1;
	public static final  int MODEL_OUTPUT_COLUMN = INPUT_COLUMN + 1;
	public static final int EXTRA_CREDIT_COLUMN = MODEL_OUTPUT_COLUMN + 1;
	public static final  int CHECKER_COLUMN = EXTRA_CREDIT_COLUMN  + 1;
	public static final  int START_CHECKER_ARGUMENTS_COLUMN = CHECKER_COLUMN + 1;
	
	protected int headerRow = 0;
	protected int numRequirements;
	FileProxy specificationSpreadsheet; // w
	
	List<String[]>  table;
	protected boolean valid;
//	protected FrameworkProjectRequirements projectRequirements;
  


	public ACSVRequirementsSpecification(FileProxy aSpecificationSpreadsheet) {
		specificationSpreadsheet = aSpecificationSpreadsheet;	
		init();
	}
	
//	public ACSVRequirementsSpecification(SakaiProjectDatabase aSakaiProjectDatabase) {
//		specificationSpreadsheet = aSakaiProjectDatabase.getAssignmentDataFolder().getRequirementsSpreadsheetFile();
//		init();
//	}
//	
	protected void init() {
		maybeCreateTable();
		headerRow = getHeaderRowNum(table);
		valid = headerRow >= 0;
		makeRequirements();
		

	}
	
	protected void makeRequirements() {
		if (isValid()) {
			numRequirements = table.size() - (headerRow + 1);
			
		}
		
	}
	
	protected void maybeCreateTable() {
		if (table != null)
			return;
		createTable();
		
	}
	
	protected void createTable() {
		
		try {
			InputStream input = specificationSpreadsheet.getInputStream();
			CSVReader csvReader 	=	new CSVReader(new InputStreamReader(input));
		     table = csvReader.readAll();
			csvReader.close();
			input.close();
			
		   
	    
	    
		} catch (Exception e) {
			e.printStackTrace();
		
			
		}
		
	}
	
	
	
	public int getHeaderRowNum(List<String[]> aSheet) {
		 for (int rowNum = 0; rowNum < aSheet.size(); rowNum ++) {
			 String[] aRow = aSheet.get(rowNum);
			 if (aRow[TYPE_COLUMN].equalsIgnoreCase(TYPE_NAME))
				 return rowNum;
		 }
		 return -1;
		
	}
	
	
	
	
	
	public FileProxy getSpecificationSpreadsheet() {
		return specificationSpreadsheet;
	}

	public String getFileName() {
		return specificationSpreadsheet.getMixedCaseAbsoluteName();
	}

	public boolean isValid() {
		return valid;
	}

	public void setValid(boolean newValue) {
		this.valid = newValue;
	}

	public List<String[]> getTable() {
		return table;
	}
	@Override
	public int getNumberOfRequirements() {
		return numRequirements;
	}
	@Override
	public String getArg(int aRequirementNum, int anArgNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		int aColumnNum = START_CHECKER_ARGUMENTS_COLUMN + anArgNum;
		return table.get(aRowNum)[aColumnNum];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have arg " + anArgNum);
			return null;
		}
	}
	public String getType(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[TYPE_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have type ");
			return null;
		}
	}
	
	public String getDescription(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[DESCRIPTION_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have description ");
			return null;
		}
	}
	@Override
	public Double getMaxScore(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return Double.parseDouble(table.get(aRowNum)[MAX_SCORE_COLUMN]);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score");
			return null;
		}
	}
	
	@Override
	public Integer getTimeOut(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		String aTimeOut = table.get(aRowNum)[TIMEOUT_COLUMN];
		if (aTimeOut == null || aTimeOut.isEmpty())
			return null;
		return Integer.parseInt(aTimeOut);
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have timeout");
			return null;
		}
	}
	@Override
	public boolean isExtraCredit(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[EXTRA_CREDIT_COLUMN].replaceAll("\\s+", "");
			return !aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have extra credit");
				return false;
			}
	}
	
	
	@Override
	public boolean isManual(int aRequirementNum) {
		try {
			int aRowNum = headerRow + 1 + aRequirementNum;
			String aSpec = table.get(aRowNum)[CHECKER_COLUMN].replaceAll("\\s+", "");
			return aSpec.isEmpty();
			
			} catch (Exception e) {
				System.out.println("Requirement " + aRequirementNum + " does not have checker column");
				return false;
			}
	}

	
	public String getInput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[INPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have max score ");
			return null;
		}
	}
	public String getModelOutput(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[MODEL_OUTPUT_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have model output");
			return null;
		}
	}
	public String getChecker(int aRequirementNum) {
		try {
		int aRowNum = headerRow + 1 + aRequirementNum;
		return table.get(aRowNum)[CHECKER_COLUMN];
		} catch (Exception e) {
			System.out.println("Requirement " + aRequirementNum + " does not have a function");
			return null;
		}
	}
	

}
]]></snapshot>
  </Command>
  <Command __id="8119" _type="FileOpenCommand" date="Sun Aug 25 09:03:31 EDT 2019" docASTNodeCount="77" docActiveCodeLength="563" docExpressionCount="42" docLength="563" projectName="GraderBasics" timestamp="162534822">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\gradingTools\interpreter\AnInterpretingGradableJUnitTopLevelSuite.java]]></filePath>
    <snapshot><![CDATA[package gradingTools.interpreter;

import java.io.File;

import grader.basics.junit.AGradableJUnitTopLevelSuite;
import grader.basics.project.BasicProject;

public class AnInterpretingGradableJUnitTopLevelSuite extends AGradableJUnitTopLevelSuite{

	public AnInterpretingGradableJUnitTopLevelSuite(String aFileName) {
		super(null);
	}
	public static String searchForAssignmentData(File aParentFolder, BasicProject aProject) {
		File[] aFiles = aParentFolder.listFiles();
		
		
		
		
		
	}
	public static void main (String[] args) {
	}

}
]]></snapshot>
  </Command>
  <DocumentChange __id="8122" _type="Insert" date="Sun Aug 25 09:03:33 EDT 2019" docASTNodeCount="79" docActiveCodeLength="579" docExpressionCount="43" docLength="579" length="16" offset="484" repeat="13" timestamp="162537045" timestamp2="162539653">
    <text><![CDATA[
		return null;]]></text>
  </DocumentChange>
  <Command __id="8149" _type="FileOpenCommand" date="Sun Aug 25 09:05:52 EDT 2019" docASTNodeCount="3023" docActiveCodeLength="23744" docExpressionCount="1687" docLength="40229" projectName="GraderBasics" timestamp="162675863">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\config\BasicStaticConfigurationUtils.java]]></filePath>
    <snapshot><![CDATA[package grader.basics.config;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.configuration.PropertiesConfiguration;

import grader.basics.BasicLanguageDependencyManager;
import grader.basics.project.Project;
import grader.basics.settings.BasicGradingEnvironment;
import util.trace.Tracer;
/**
 * 
 *This serves two purposes.
 *It defines defaults for configurable properties.
 *It also reads project-based properties to be used in localchecks on student
 *computer.
 *Ultimate authority over properties in localchecks mode is ABasicExecution
 *
 */
public class BasicStaticConfigurationUtils {
	public static final String PRIVACY = "privacy";
	public static final String EXECUTION_COMMAND = "execution";

	public static final String LANGUAGE = "language";
	
	public static final String ENTRY_POINT = "entryPoint";
	public static final String BUILD_FOLDER = "buildFolder";
	public static final String PERMISSIONS = "permissions";

	public static final String CLASS_PATH = "classPath";
	public static final String OE_PATH = "oePath";
	public static final String JUNIT_PATH = "junitPath";
	public static final String LOCAL_GRADER_PATH = "localGraderPath";
	public static final String OE_AND_CLASS_PATH = "oeAndClassPath";
	public static final String CLASS_PATH_SEPARATOR = ":";

	public static final String PROCESS_TEAMS = "processTeams";

	public static final String ENTRY_TAG = "entryTag";
	public static final String ENTRY_TAGS = "entryTags";
	public static final String RESOURCE_RELEASE_TIME = "sleepTime";
	public static final String ARGS = "args";
	public static final String START_TAGS = "startTags";
	public static final String TERMINATING = "terminating";
	public static final String GENERATE_TRACE_FILES = "trace";

//	public static final String JAVA = "Java";

	public static final String CLASS_PATH_VAR = toVariable(CLASS_PATH);
	public static final String CLASS_PATH_SEPARATOR_VAR = toVariable(CLASS_PATH_SEPARATOR);
	public static final String OE_PATH_VAR = toVariable(OE_PATH);
	public static final String LOCAL_GRADER_PATH_VAR = toVariable(LOCAL_GRADER_PATH);

	public static final String JUNIT_PATH_VAR = toVariable(JUNIT_PATH);
	public static final String OE_AND_CLASS_PATH_VAR = toVariable(OE_AND_CLASS_PATH );
	public static final String PERMISSIONS_VAR = toVariable(PERMISSIONS);
	public static final String BUILD_FOLDER_VAR = toVariable(BUILD_FOLDER);
	public static final String IMPLICIT_REQUIRMENTS_ROOT = "implicitRequirementsRoot";
	public static final String DEFAULT_IMPLICIT_REQUIRMENTS_ROOT = "gradingTools";
	public static final String USE_EXECEUTOR = "useExecutor";
	public static final boolean DEFAULT_USE_EXECUTOR = false;
	public static final String EXECUTOR = "executor";
	// this makes no sense, but it is consistent with config file
	public static final String DEFAULT_EXECUTOR = "D:/dewan_backup/Java/Grader/executor";
	public static final String C_OBJ = "language.C.obj";
	public static final String DEFAULT_C_OBJ = "o";
	public static final String MODULES = "modules";
	public static final String DEFAULT_MODULE = "Comp101";
	public static final String FORK_MAIN = "forkMain";
	public static final Boolean DEFAULT_FORK_MAIN = true;
	public static final String GRADABLE_PROJECT_LOCATION = "gradableProjectLocation";
	public static final String SOURCE_LOCATION = "sourceLocation";
	public static final String BINARY_LOCATION = "binaryLocation";
	public static final String OBJECT_LOCATION = "objectLocation";
	public static final String OUTPUT_WAIT_TIME = "outputWaitTime";
	public static final String TEAM_OUTPUT_WAIT_TIME = "teamOutputWaitTime";
	public static final String WAIT_FOR_RESORT = "waitForResort";
	public static final String RESORT_TIME = "resortTime";
	public static final String PROCESS_TIMEOUT = "processTimeout";
	public static final String METHOD_TIMEOUT = "methodTimeout";
	public static final String CONSTRUCTOR_TIMEOUT = "constructorTimeout";
	public static final String USE_METHOD_CONSTRUCTOR_TIMEOUT = "useMethodConstructorTimeout";
	public static final String USE_PROCESS_TIMEOUT = "useProcessTimeout";
	public static final String WAIT_FOR_METHOD_CONSTRUCTOR_AND_PROCESSES = "waitFotMethodConstructorAndProcesses";
	public static final String USE_PROJECT_CONFIGURATION = "useProjectConfiguration";
	public static final boolean DEFAULT_USE_PROJECT_CONFIGURATION = false;






//	private static  List<String> basicCommand;
//	private static Map<String, List<String>> processToBasicCommand = new HashMap();
	private static String duplicatedClassPathSeparator;
	private static List<String> graderProcessTeams;

	private static boolean useProjectConfiguration;
	protected static String module;
	
	protected static String problem;
	protected static String test;
	protected static String testSuite;
	protected static List<String> emptyList = new ArrayList();


//	Comp533s18.execution = java, -cp, .{:}..{:}{classPath}{:}{oePath}{:}{junitPath}, {entryTags}, {args}


	//	public static final String[] DEFAULT_JAVA_BASIC_COMMAND_ARRAY = {
//			"java", "-cp", ".{:}..{:}{classPath}{:}{:}{junitPath}{:}{localGraderPath}", "{entryTags}", "{args}"
//	};
	public static final String[] DEFAULT_JAVA_BASIC_COMMAND_ARRAY = {
			"java", "-cp", ".{:}..{:}{classPath}{:}{:}{junitPath}{:}{localGraderPath}", "{entryPoint}", "{args}"
	};
	public static final String[] DEFAULT_OE_BASIC_COMMAND_ARRAY = {
			"java", "-cp", ".{:}..{:}{classPath}{:}{oePath}{:}{junitPath}{:}{localGraderPath}", "{entryTags}", "{args}"
	};

	public static final List<String> DEFAULT_JAVA_BASIC_COMMAND =
			Arrays.asList(DEFAULT_JAVA_BASIC_COMMAND_ARRAY);
	public static final List<String> DEFAULT_OE_BASIC_COMMAND =
			Arrays.asList(DEFAULT_OE_BASIC_COMMAND_ARRAY);
	public static final int DEFAULT_RESOURCE_RELEASE_TIME = 2000;
	public static final int DEFAULT_CONSTRUCTOR_TIME_OUT = 2000;// in
	// milliseconds
public static final int DEFAULT_METHOD_TIME_OUT = 2000; // in milliseconds
public static final int DEFAULT_PROCESS_TIME_OUT = 4; // in seconds
public static final  String CHECK_ALL_SPECIFIED_TAGS = "checkAllSpecifiedTags";
public static final  boolean DEFAULT_CHECK_ALL_SPECIFIED_TAGS = false;


	
	public static String toVariable(String aVariableName) {
		return "{" + aVariableName + "}";
	}
	public static void setBasicCommandToDefaultEntryPointCommand() {
		BasicExecutionSpecificationSelector.getBasicExecutionSpecification().setGraderBasicCommand(DEFAULT_JAVA_BASIC_COMMAND);
//		basicCommand = DEFAULT_JAVA_BASIC_COMMAND;
	}
	public static void setBasicCommandToDefaultEntryTagCommand() {
		BasicExecutionSpecificationSelector.getBasicExecutionSpecification().setGraderBasicCommand(DEFAULT_OE_BASIC_COMMAND);
//		basicCommand =  DEFAULT_OE_BASIC_COMMAND;
	}
	public static List<String> getBasicCommand() {
		return BasicExecutionSpecificationSelector.getBasicExecutionSpecification().getBasicCommand();
//		if (basicCommand == null) {
//			basicCommand = DEFAULT_OE_BASIC_COMMAND;
//		}
//////		return getInheritedListModuleProblemProperty(EXECUTION_COMMAND);
//		return basicCommand;
	}
	public static boolean hasClassPath() {
//		getBasicCommand();
		return hasClassPath(getBasicCommand());
//		if (basicCommand == null) {
//			return false;
//		}
//		for (String aCommand:basicCommand) {
//			if (aCommand.contains(CLASS_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
//				return true;
//			}
//		}
//		return false;	
	}
	public static boolean hasClassPath(List<String> basicCommand) {
//		getBasicCommand();
		if (basicCommand == null) {
			return false;
		}
		for (String aCommand:basicCommand) {
			if (aCommand.contains(CLASS_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
				return true;
			}
		}
		return false;	
	}
	
	public static boolean hasOEClassPath() {
		return hasOEClassPath(getBasicCommand());
//		getBasicCommand();
//		if (basicCommand == null) {
//			return false;
//		}
//		for (String aCommand:basicCommand) {
//			if (aCommand.contains(OE_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
//				return true;
//			}
//		}
//		return false;	
	}
	public static boolean hasOEClassPath(List<String> basicCommand) {
//		getBasicCommand();
		if (basicCommand == null) {
			return false;
		}
		for (String aCommand:basicCommand) {
			if (aCommand.contains(OE_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
				return true;
			}
		}
		return false;	
	}
	
	public static boolean hasOEOrClassPath() {
		return hasClassPath(getBasicCommand()) || hasOEClassPath(getBasicCommand());
	}
	public static boolean hasOEOrClassPath(List<String> basicCommand) {
		return hasClassPath(basicCommand) || hasOEClassPath(basicCommand);
	}
	protected static String[] emptyEntryPoints = {};
	protected static String[] potentialMainEntryPoints;
//	public static String[] getPotentialMainEntryPointNames() {
//		String retVal = getInheritedStringModuleProblemProperty(ENTRY_POINT, null);
//		if (retVal != null) {
//			GraderSettingsManager manager = GraderSettingsManagerSelector.getGraderSettingsManager();
//			retVal = manager.replaceModuleProblemVars(retVal);
//			return new String[]{retVal.replaceAll(" ", "")};
//		}
//		return emptyEntryPoints;
//	}
	public static String[] getPotentialMainEntryPointNames() {
		return potentialMainEntryPoints;
//		if (potentialMainEntryPoints == null) {
//		String retVal = getInheritedStringModuleProblemProperty(ENTRY_POINT, null);
//		if (retVal != null) {
//			GraderSettingsManager manager = GraderSettingsManagerSelector.getGraderSettingsManager();
//			retVal = manager.replaceModuleProblemVars(retVal);
//			potentialMainEntryPoints = new String[]{retVal.replaceAll(" ", "")};
//		} else {
//			potentialMainEntryPoints = emptyEntryPoints;
//		}
//		}
//		return potentialMainEntryPoints;
	}
	
	public static void setPotentialMainEntryPointNames(String[] aNames) {
		potentialMainEntryPoints = aNames;
	}
	// we really do not need this method, for backwards compatibility
	public static List<String> getBasicCommand(String aProcessName) {	
		return BasicExecutionSpecificationSelector.getBasicExecutionSpecification().getBasicCommand(aProcessName);
//		List<String> retVal = processToBasicCommand.get(aProcessName);
//		if (retVal == null) {
////			retVal = getBasicCommand();
//			retVal = BasicExecutionSpecificationSelector.getBasicExecutionSpecification().getBasicCommand();
//		}
//		
//		return retVal;
		
	}
	public static void setBasicCommand(String aProcessName, List<String> aCommand) {
		BasicExecutionSpecificationSelector.getBasicExecutionSpecification().setGraderBasicCommand(aProcessName, aCommand);
//		processToBasicCommand.put(aProcessName, aCommand);
	
	}
	public static boolean hasEntryPoint(List<String> aCommand) {
		return hasSubString(aCommand, ENTRY_POINT);
	}

	public static boolean hasSubString(List<String> aCommand, String aSubString) {
		for (String aCommmandComponent : aCommand) {
			if (aCommmandComponent.contains(aSubString)) {
				return true;
			}
		}
		return false;
	}

	public static boolean hasEntryTag(List<String> aProcessCommand) {
		return hasSubString(aProcessCommand, ENTRY_TAG);
	}

	public static boolean hasEntryTags(List<String> aProcessCommand) {
		return hasSubString(aProcessCommand, ENTRY_TAGS);
	}

	public static boolean haArgs(String aProcessCommand) {
		return aProcessCommand.contains(ARGS);
	}
	
//	public static final String FILE_SEPARATOR = System.getProperty("file.separator");
	public static final String FILE_SEPARATOR = "/";


	public static String quotePath(String path) {
		if (!path.contains(" ")) return path;
	    boolean startSlash = path.startsWith("\\") || path.startsWith("/");
	    boolean endSlash = path.endsWith("\\") || path.endsWith("/");
	    String[] split = path.split("[\\\\/]+");

	    StringBuilder quotPath = new StringBuilder(path.length());

	    if (startSlash) {
	        quotPath.append(FILE_SEPARATOR);
	    }
	    
	    for(int i = 0; i < split.length; i ++) {
	    	String s = split[i];
	        if (s.contains(" ")) {
//	            s = "\"" + s + "\"";
	            s = "\\\"" + s + "\\\"";

	        }
	        quotPath.append(s);
	        if (i+1 < split.length) {
	            quotPath.append(FILE_SEPARATOR);
	        }
	    }
	    
	    if (endSlash) {
	        quotPath.append(FILE_SEPARATOR);
	    }
	    
	    return quotPath.toString();
	}
	
	public static int getClassPathFlagIndex(List<String> aBasicCommand) {
		int aCpIndex = aBasicCommand.indexOf("-cp");
		if (aCpIndex < 0) 
			aCpIndex = aBasicCommand.indexOf("-classpath");
		return aCpIndex;
	}
	public static String getExecutionCommandRawClassPath() {
		return getExecutionCommandRawClassPath(getBasicCommand());
//		List<String> aBasicCommand = getBasicCommand();
//		int aCpIndex = getClassPathFlagIndex(aBasicCommand);
//		if (aCpIndex < 0)
//			return null;
//		if (aCpIndex + 1 >= aBasicCommand.size())
//			return null;
//		return getReplacedRawClassPath(aBasicCommand.get(aCpIndex + 1));
		
	}
	public static String getExecutionCommandRawClassPath(List<String> aBasicCommand) {
//		List<String> aBasicCommand = getBasicCommand();
		int aCpIndex = getClassPathFlagIndex(aBasicCommand);
		if (aCpIndex < 0)
			return null;
		if (aCpIndex + 1 >= aBasicCommand.size())
			return null;
		return getReplacedRawClassPath(aBasicCommand.get(aCpIndex + 1));
		
	}
	
	public static String getReplacedRawClassPath (String command) {
		// do we really need all of these ifs, more efficient without them? - debugging will be easier
					// all of these will be in the same command
					if (command.contains(CLASS_PATH_VAR)) {

						command = command.replace(CLASS_PATH_VAR,
								BasicGradingEnvironment.get().getClassPath());
					}

					if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
						command = command.replace(CLASS_PATH_SEPARATOR_VAR,
								BasicGradingEnvironment.get().getClassPathSeparator());
					}
					 
					if (command.contains(LOCAL_GRADER_PATH_VAR)) { // the config property does not have this, I suppose it is to allow student code to invoke api calls in grader

						command = command.replace(LOCAL_GRADER_PATH_VAR,
						// BasicGradingEnvironment.get().getClasspath());
								BasicGradingEnvironment.get().getLocalGraderClassPath());

					} 
					if (command.contains(OE_PATH_VAR)) {
						if (command.toLowerCase().contains("local")) { // we already have oeall
							command = command.replace(OE_PATH_VAR,
									// BasicGradingEnvironment.get().getClasspath());
									"");
						} else {
						command = command.replace(OE_PATH_VAR,
						// BasicGradingEnvironment.get().getClasspath());
								BasicGradingEnvironment.get().getOEClassPath());
						}

					}

					if (command.contains(JUNIT_PATH_VAR)) {
						command = command.replace(JUNIT_PATH_VAR,
								BasicGradingEnvironment.get().getJUnitClassPath());
						// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
						// command = command.replace(OE_AND_CLASS_PATH_VAR,
						// BasicGradingEnvironment.get().getClassPath());
					} 
					String aClassPathSeparator = BasicGradingEnvironment.get().getClassPathSeparator();
					if (duplicatedClassPathSeparator == null) {
						//just avoding new String creation
						duplicatedClassPathSeparator = aClassPathSeparator + aClassPathSeparator;
					}
					// certain libraries may not exist, specially in the server, see what happens without them
					command = command.replaceAll(duplicatedClassPathSeparator, aClassPathSeparator);
					return command;
					// javac wants no quotes!
//					String anOSPath = BasicGradingEnvironment.get().toOSClassPath(command);
//					return anOSPath;
	}
	public static void replaceClassPathVars (List<String> basicCommand) {
		int aCpIndex = getClassPathFlagIndex(basicCommand);
		if (aCpIndex < 0)
			return ;
		
		if (aCpIndex + 1 >= basicCommand.size()) {
			Tracer.warning("Nothing follows classpath flag");
			return ;
		}
		String aReplacement = getReplacedRawClassPath(basicCommand.get(aCpIndex + 1));
		String anOSPath = BasicGradingEnvironment.get().toOSClassPath(aReplacement);
		basicCommand.set(aCpIndex + 1, anOSPath);

		
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			
////			// do we really need all of these ifs, more efficient without them? - debugging will be easier
////			// all of these will be in the same command
////			if (command.contains(CLASS_PATH_VAR)) {
////
////				command = command.replace(CLASS_PATH_VAR,
////						BasicGradingEnvironment.get().getClassPath());
////			}
////
////			if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
////				command = command.replace(CLASS_PATH_SEPARATOR_VAR,
////						BasicGradingEnvironment.get().getClassPathSeparator());
////			}
////			if (command.contains(OE_PATH_VAR)) {
////
////				command = command.replace(OE_PATH_VAR,
////				// BasicGradingEnvironment.get().getClasspath());
////						BasicGradingEnvironment.get().getOEClassPath());
////
////			} 
////			if (command.contains(JUNIT_PATH_VAR)) {
////				command = command.replace(JUNIT_PATH_VAR,
////						BasicGradingEnvironment.get().getJUnitClassPath());
////				// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
////				// command = command.replace(OE_AND_CLASS_PATH_VAR,
////				// BasicGradingEnvironment.get().getClassPath());
////			} 
//			command = getReplacedClassPath(command);
//			basicCommand.set(aCommandIndex, command);
//		}
	}
	
//	public static void replacePermissionVariables(List<String> basicCommand, Project aProject) {
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			if (doPermissions && command.contains(PERMISSIONS_VAR)) {
//
//				String aPolicyFilePath = JavaProjectToPermissionFile
//						.getPermissionFile(aProject).getAbsolutePath();
//				try {
//					aPolicyFilePath = JavaProjectToPermissionFile
//							.getPermissionFile(aProject).getCanonicalPath();
//				} catch (IOException e1) {
//					e1.printStackTrace();
//				}
//				aPolicyFilePath = aPolicyFilePath.replace("\\", "/");
//
//				aPolicyFilePath = quotePath(aPolicyFilePath);
//
//				command = command.replace(PERMISSIONS_VAR, aPolicyFilePath);
//				basicCommand.set(aCommandIndex, command);
//
//			}
//		}
//	}
	
	public static void replaceEntryPoint(List<String> basicCommand,  String anEntryPoint,
			String anEntryTagTarget) {
		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {

			String command = basicCommand.get(aCommandIndex);
			if (anEntryPoint != null) {
				command = command
						.replace(toVariable(ENTRY_POINT), anEntryPoint);
				
			}
			if (anEntryTagTarget != null) {
				command = command.replace(toVariable(ENTRY_TAGS),
						anEntryTagTarget);
				command = command.replace(toVariable(ENTRY_TAG),
						anEntryTagTarget); // will match tags also

			}
			// check if entryTagTarget is empty and replace it with entry point
			basicCommand.set(aCommandIndex, command);
		}
	}
	public static void replaceBuildFolder(List<String> basicCommand,  File aBuildFolder) {
		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {

			String command = basicCommand.get(aCommandIndex);
			// we should always have a build folder I suppose
			// this is meant for C like programs
			if (command.contains(BUILD_FOLDER_VAR)) {
			command = command.replace(BUILD_FOLDER_VAR,
					aBuildFolder.getAbsolutePath());
			basicCommand.set(aCommandIndex, command);

			}
		}
	}
	public static void replaceArgs(List<String> basicCommand,  String[] anArgs) {
		int argsIndex = basicCommand.indexOf(toVariable(ARGS));
		if (argsIndex >= 0) {
			basicCommand.remove(argsIndex);
			if (anArgs != null) {
			for (int i = 0; i < anArgs.length; i++) {
				basicCommand.add(argsIndex + i, anArgs[i]);
			}
			}

		}
	}
//	public static String[] getExecutionCommand(Project aProject,
//			String aProcessName, File aBuildFolder, String anEntryPoint,
//			String anEntryTagTarget, String[] anArgs) {
//
//		List<String> basicCommand = null;
//		if (aProcessName == null || aProcessName.isEmpty()) {
//		    if (anEntryPoint != null) {
//		    	basicCommand = getBasicCommand();
////		    	basicCommand = DEFAULT_JAVA_BASIC_COMMAND;
//
//		    } else {
//			basicCommand = getBasicCommand();
//		    }
//		} else {
//		
//			basicCommand = getBasicCommand(aProcessName);
//
//		}
//		return getExecutionCommand(basicCommand, aProject, aProcessName, aBuildFolder, anEntryPoint, anEntryTagTarget, anArgs);
//////		List<String> retVal = new ArrayList(basicCommand.size());
////		List<String> retVal = new ArrayList(basicCommand.size() + 5); // to accommodate args
////		retVal.addAll(basicCommand);
////		replaceClassPathVars(retVal);
//////		replacePermissionVariables(retVal, aProject);
////		replaceEntryPoint(retVal, anEntryPoint, anEntryTagTarget);
////		replaceBuildFolder(retVal, aBuildFolder);
////		replaceArgs(retVal, anArgs);
////		return retVal.toArray(new String[0]);
//
//
////		
////		
////		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
////
////			String command = basicCommand.get(aCommandIndex);
////			if (command.contains(CLASS_PATH_VAR)) {
////
////				command = command.replace(CLASS_PATH_VAR,
////						BasicGradingEnvironment.get().getClassPath());
////
////			} else if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
////				command = command.replace(CLASS_PATH_SEPARATOR_VAR,
////						BasicGradingEnvironment.get().getClassPathSeparator());
////			} else if (command.contains(OE_PATH_VAR)) {
////
////				command = command.replace(OE_PATH_VAR,
////				// BasicGradingEnvironment.get().getClasspath());
////						BasicGradingEnvironment.get().getOEClassPath());
////
////			} else if (command.contains(JUNIT_PATH_VAR)) {
////				command = command.replace(JUNIT_PATH_VAR,
////						BasicGradingEnvironment.get().getJUnitClassPath());
////				// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
////				// command = command.replace(OE_AND_CLASS_PATH_VAR,
////				// BasicGradingEnvironment.get().getClassPath());
////			} else if (doPermissions && command.contains(PERMISSIONS_VAR)) {
////
////				String aPolicyFilePath = JavaProjectToPermissionFile
////						.getPermissionFile(aProject).getAbsolutePath();
////				try {
////					aPolicyFilePath = JavaProjectToPermissionFile
////							.getPermissionFile(aProject).getCanonicalPath();
////				} catch (IOException e1) {
////					e1.printStackTrace();
////				}
////				aPolicyFilePath = aPolicyFilePath.replace("\\", "/");
////
////				aPolicyFilePath = quotePath(aPolicyFilePath);
////
////				command = command.replace(PERMISSIONS_VAR, aPolicyFilePath
////
////				);
////			}
////
////			if (anEntryPoint != null) {
////				command = command
////						.replace(toVariable(ENTRY_POINT), anEntryPoint);
////			}
////			if (anEntryTagTarget != null) {
////				command = command.replace(toVariable(ENTRY_TAGS),
////						anEntryTagTarget);
////				command = command.replace(toVariable(ENTRY_TAG),
////						anEntryTagTarget); // will match tags also
////
////			}
////
////			command = command.replace(toVariable(BUILD_FOLDER),
////					aBuildFolder.getAbsolutePath());
////
////			retVal.add(command);
////		}
////		int argsIndex = retVal.indexOf(toVariable(ARGS));
////		if (argsIndex >= 0) {
////			retVal.remove(argsIndex);
////			for (int i = 0; i < anArgs.length; i++) {
////				retVal.add(argsIndex + i, anArgs[i]);
////			}
////
////		}
////		return retVal.toArray(new String[0]);
//
//	}
	public static String[] getExecutionCommand(Project aProject,
			String aProcessName, File aBuildFolder, String anEntryPoint,
			String anEntryTagTarget, String[] anArgs) {

		List<String> basicCommand = null;
		if (aProcessName == null || aProcessName.isEmpty()) {
			basicCommand = BasicExecutionSpecificationSelector.getBasicExecutionSpecification().getBasicCommand();
//		    if (anEntryPoint != null) {
//		    	basicCommand = getBasicCommand();
////		    	basicCommand = DEFAULT_JAVA_BASIC_COMMAND;
//
//		    } else {
//			basicCommand = getBasicCommand();
//		    }
		} else {
		
			basicCommand = getBasicCommand(aProcessName);

		}
		return getExecutionCommand(basicCommand, aProject, aProcessName, aBuildFolder, anEntryPoint, anEntryTagTarget, anArgs);
////		List<String> retVal = new ArrayList(basicCommand.size());
//		List<String> retVal = new ArrayList(basicCommand.size() + 5); // to accommodate args
//		retVal.addAll(basicCommand);
//		replaceClassPathVars(retVal);
////		replacePermissionVariables(retVal, aProject);
//		replaceEntryPoint(retVal, anEntryPoint, anEntryTagTarget);
//		replaceBuildFolder(retVal, aBuildFolder);
//		replaceArgs(retVal, anArgs);
//		return retVal.toArray(new String[0]);


//		
//		
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			if (command.contains(CLASS_PATH_VAR)) {
//
//				command = command.replace(CLASS_PATH_VAR,
//						BasicGradingEnvironment.get().getClassPath());
//
//			} else if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
//				command = command.replace(CLASS_PATH_SEPARATOR_VAR,
//						BasicGradingEnvironment.get().getClassPathSeparator());
//			} else if (command.contains(OE_PATH_VAR)) {
//
//				command = command.replace(OE_PATH_VAR,
//				// BasicGradingEnvironment.get().getClasspath());
//						BasicGradingEnvironment.get().getOEClassPath());
//
//			} else if (command.contains(JUNIT_PATH_VAR)) {
//				command = command.replace(JUNIT_PATH_VAR,
//						BasicGradingEnvironment.get().getJUnitClassPath());
//				// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
//				// command = command.replace(OE_AND_CLASS_PATH_VAR,
//				// BasicGradingEnvironment.get().getClassPath());
//			} else if (doPermissions && command.contains(PERMISSIONS_VAR)) {
//
//				String aPolicyFilePath = JavaProjectToPermissionFile
//						.getPermissionFile(aProject).getAbsolutePath();
//				try {
//					aPolicyFilePath = JavaProjectToPermissionFile
//							.getPermissionFile(aProject).getCanonicalPath();
//				} catch (IOException e1) {
//					e1.printStackTrace();
//				}
//				aPolicyFilePath = aPolicyFilePath.replace("\\", "/");
//
//				aPolicyFilePath = quotePath(aPolicyFilePath);
//
//				command = command.replace(PERMISSIONS_VAR, aPolicyFilePath
//
//				);
//			}
//
//			if (anEntryPoint != null) {
//				command = command
//						.replace(toVariable(ENTRY_POINT), anEntryPoint);
//			}
//			if (anEntryTagTarget != null) {
//				command = command.replace(toVariable(ENTRY_TAGS),
//						anEntryTagTarget);
//				command = command.replace(toVariable(ENTRY_TAG),
//						anEntryTagTarget); // will match tags also
//
//			}
//
//			command = command.replace(toVariable(BUILD_FOLDER),
//					aBuildFolder.getAbsolutePath());
//
//			retVal.add(command);
//		}
//		int argsIndex = retVal.indexOf(toVariable(ARGS));
//		if (argsIndex >= 0) {
//			retVal.remove(argsIndex);
//			for (int i = 0; i < anArgs.length; i++) {
//				retVal.add(argsIndex + i, anArgs[i]);
//			}
//
//		}
//		return retVal.toArray(new String[0]);

	}
	public static String[] getExecutionCommand(List<String> basicCommand, Project aProject,
			String aProcessName, File aBuildFolder, String anEntryPoint,
			String anEntryTagTarget, String[] anArgs) {

//		List<String> basicCommand = null;
//		if (aProcessName == null || aProcessName.isEmpty()) {
//		
//			basicCommand = getBasicCommand();
//		} else {
//		
//			basicCommand = getBasicCommand(aProcessName);
//
//		}
//		List<String> retVal = new ArrayList(basicCommand.size());
		List<String> retVal = new ArrayList(basicCommand.size() + 5); // to accommodate args
		retVal.addAll(basicCommand);
		replaceClassPathVars(retVal);
//		replacePermissionVariables(retVal, aProject);
		replaceEntryPoint(retVal, anEntryPoint, anEntryTagTarget);
		replaceBuildFolder(retVal, aBuildFolder);
		replaceArgs(retVal, anArgs);
		return retVal.toArray(new String[0]);


//		
//		
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			if (command.contains(CLASS_PATH_VAR)) {
//
//				command = command.replace(CLASS_PATH_VAR,
//						BasicGradingEnvironment.get().getClassPath());
//
//			} else if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
//				command = command.replace(CLASS_PATH_SEPARATOR_VAR,
//						BasicGradingEnvironment.get().getClassPathSeparator());
//			} else if (command.contains(OE_PATH_VAR)) {
//
//				command = command.replace(OE_PATH_VAR,
//				// BasicGradingEnvironment.get().getClasspath());
//						BasicGradingEnvironment.get().getOEClassPath());
//
//			} else if (command.contains(JUNIT_PATH_VAR)) {
//				command = command.replace(JUNIT_PATH_VAR,
//						BasicGradingEnvironment.get().getJUnitClassPath());
//				// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
//				// command = command.replace(OE_AND_CLASS_PATH_VAR,
//				// BasicGradingEnvironment.get().getClassPath());
//			} else if (doPermissions && command.contains(PERMISSIONS_VAR)) {
//
//				String aPolicyFilePath = JavaProjectToPermissionFile
//						.getPermissionFile(aProject).getAbsolutePath();
//				try {
//					aPolicyFilePath = JavaProjectToPermissionFile
//							.getPermissionFile(aProject).getCanonicalPath();
//				} catch (IOException e1) {
//					e1.printStackTrace();
//				}
//				aPolicyFilePath = aPolicyFilePath.replace("\\", "/");
//
//				aPolicyFilePath = quotePath(aPolicyFilePath);
//
//				command = command.replace(PERMISSIONS_VAR, aPolicyFilePath
//
//				);
//			}
//
//			if (anEntryPoint != null) {
//				command = command
//						.replace(toVariable(ENTRY_POINT), anEntryPoint);
//			}
//			if (anEntryTagTarget != null) {
//				command = command.replace(toVariable(ENTRY_TAGS),
//						anEntryTagTarget);
//				command = command.replace(toVariable(ENTRY_TAG),
//						anEntryTagTarget); // will match tags also
//
//			}
//
//			command = command.replace(toVariable(BUILD_FOLDER),
//					aBuildFolder.getAbsolutePath());
//
//			retVal.add(command);
//		}
//		int argsIndex = retVal.indexOf(toVariable(ARGS));
//		if (argsIndex >= 0) {
//			retVal.remove(argsIndex);
//			for (int i = 0; i < anArgs.length; i++) {
//				retVal.add(argsIndex + i, anArgs[i]);
//			}
//
//		}
//		return retVal.toArray(new String[0]);

	}
	public static List<String> getProcessTeams() {
		return graderProcessTeams;
	}
	public static void setProcessTeams(List<String> newVal) {
		 graderProcessTeams = newVal;;
	}
	public static boolean isTeamProcess() {
		return graderProcessTeams != null && graderProcessTeams.isEmpty();
	}
	public static boolean isUseProjectConfiguration() {
		return BasicExecutionSpecificationSelector.getBasicExecutionSpecification().isUseProjectConfiguration();
//		return useProjectConfiguration;
	}
	public static void setUseProjectConfiguration(boolean newVal) {
//		BasicStaticConfigurationUtils.useProjectConfiguration = useProjectConfiguration;
		BasicExecutionSpecificationSelector.getBasicExecutionSpecification().setUseProjectConfiguration(newVal);
	}
	public static Boolean getInheritedBooleanModuleProblemProperty(
			PropertiesConfiguration configuration, String module,
			String problem, String aTest, String property, Boolean defaultValue) {
		if (configuration == null) {
			return defaultValue;
		}
	
		Boolean retVal = configuration.getBoolean(module + "." + problem + "."
				+ property, null);
	
		if (retVal == null) {
			retVal = configuration.getBoolean(module + "." + property, null);
		}
		if (retVal == null) {
			retVal = configuration.getBoolean(DEFAULT + "." + property,
					defaultValue);
		}
	
		return retVal;
	
	}
	public static final String DEFAULT = "default";
	
	public static Integer getInheritedIntegerModuleProblemProperty(
			PropertiesConfiguration configuration, String module,
			String problem, String test, String property, Integer defaultValue) {
		if (configuration == null) {
			return defaultValue;
		}
	
		Integer retVal = configuration.getInteger(module + "." + problem + "."
				+ property, null);
	
		if (retVal == null) {
			retVal = configuration.getInteger(module + "." + property, null);
		}
		if (retVal == null) {
			retVal = configuration.getInteger(DEFAULT + "." + property,
					defaultValue);
		}
	
		return retVal;
	
	}
	
	public static String getConfigurationBasicDirectString (String property, String defaultValue) {
		
			if (!isUseProjectConfiguration()) {
				 // cannot use project configuration before location is known to create project
				return defaultValue;
			}
		 PropertiesConfiguration aConfiguration = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration();
		 if (aConfiguration == null) {
			 return defaultValue;
		 }
		 return aConfiguration.getString(property, defaultValue);
		
	}
	public static List getConfigurationBasicDirectList (String property, List  defaultValue) {
		
		if (property == BasicStaticConfigurationUtils.MODULES || // infinite recursion
			!isUseProjectConfiguration()) {
			 // cannot use project configuration before location is known to create project
			return defaultValue;
		}
	 PropertiesConfiguration aConfiguration = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration();
	 if (aConfiguration == null) {
		 return defaultValue;
	 }
	 List retVal = aConfiguration.getList(property);
	 if (retVal == null) {
		 return defaultValue;
	 }
	 return retVal;
	
}
	public static String getBasicInheritedStringModuleProblemProperty(
			String property, String defaultValue) {
		if (
			// cannot use project configuration before location is known to create project
			property == BasicStaticConfigurationUtils.GRADABLE_PROJECT_LOCATION || // can do == as we are using named constants
			!isUseProjectConfiguration() ) {
//			property == BasicStaticConfigurationUtils.USE_PROJECT_CONFIGURATION){ 
			return defaultValue;
		}

	 return getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), module, problem, test, property, defaultValue);
	}
	public static Boolean getBasicInheritedBooleanModuleProblemProperty(
			String property, Boolean defaultValue) {
		if (
			property == BasicStaticConfigurationUtils.USE_PROJECT_CONFIGURATION || // avoiding recursion
			!isUseProjectConfiguration() ) {			  
			return defaultValue;
		}

	 return getInheritedBooleanModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), module, problem, test, property, defaultValue);
	}
	public static Integer getBasicInheritedIntegerModuleProblemProperty(
			String property, Integer defaultValue) {
		if (!isUseProjectConfiguration()) {
			return defaultValue;
		}

	 return getInheritedIntegerModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), module, problem, test, property, defaultValue);
	}
	public static List getBasicInheritedListModuleProblemProperty(
			String property, List defaultValue) {
		if (!isUseProjectConfiguration() ) { // can do == as we are using named constants
			return defaultValue;
		}

	 return getInheritedListModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), module, problem, test, property, defaultValue);
	}
	public static String getInheritedStringModuleProblemProperty(
			PropertiesConfiguration configuration, String module, 
			String problem, String aTest, String property, String defaultValue) {
		if (configuration == null) {
			System.err.println("Null configuration, returning " + defaultValue + " for " + property);
			return defaultValue;
		}
		String retVal = configuration.getString(module + "." + problem + "." + aTest + "."
				+ property, null);
		if (retVal != null) {
			return retVal;
		}
		retVal = configuration.getString(module + "." + problem + "."
				+ property, null);
	
//		String retVal = configuration.getString(module + "." + problem + "."
//				+ property, null);
		if (retVal != null) {
			return retVal;
		}
			retVal = configuration.getString(module + "." + property, null);
		if (retVal != null) {
			return retVal;
		}
//		if (retVal == null) {
			retVal = configuration.getString(DEFAULT + "." + property,
					defaultValue);
//		}
	
		return retVal;
	
	}
	public static List getInheritedListModuleProblemProperty(
			PropertiesConfiguration configuration, String module,
			String problem, String aTest, String property, List<String> aDefaultValue) {
		if (configuration == null) {
			return aDefaultValue;
		}
		List retVal = configuration.getList(module + "." + problem + "." + aTest + "."
				+ property);
	
		if (retVal.isEmpty()) {
			retVal = configuration.getList(module + "." + problem + "."
					+ property);
		}
		
	
//		List retVal = configuration.getList(module + "." + problem + "."
//				+ property);
	
		if (retVal.isEmpty()) {
			retVal = configuration.getList(module + "." + property);
		}
		if (retVal.isEmpty()) {
			retVal = configuration.getList(DEFAULT + "." + property);
		}
		if (retVal.isEmpty()) {
			retVal = aDefaultValue;
		}
	
		return retVal;
	
	}
	public static String getModule() {
		return module;
	}
	public static void setTest(Class aTest) {
		test = aTest.getSimpleName();
	}
	public static void setModuleProblemAndSuite(Class aSuiteClass) {
		testSuite = aSuiteClass.getSimpleName();
		Package aPackage = aSuiteClass.getPackage();
		String aPackageName = aPackage.getName();
		String[] aPackageComponents = aPackageName.split("\\.");
		if (aPackageComponents.length < 3) {
			System.err.println(aPackageName + " has < 3 components, cannot set module and problem ");
		}
		String aRawModuleName = aPackageComponents[1];
		String aRawProblemName = aPackageComponents[2];
		module = firstCharacterUpperCase(aRawModuleName);
		problem = firstCharacterUpperCase(aRawProblemName);
		
	}
	public static String firstCharacterUpperCase(String aLowerCaseString) {
		return Character.toUpperCase (aLowerCaseString.charAt(0)) + aLowerCaseString.substring(1);
	}
	public static void setModule(String module) {
		BasicStaticConfigurationUtils.module = module;
	}
	public static String getProblem() {
		return problem;
	}
	public static void setProblem(String problem) {
		BasicStaticConfigurationUtils.problem = problem;
	}
	public static String getTest() {
		return test;
	}
	public static void settest(String newVal) {
		test = newVal;
	}
	
	
	public static String getLanguage() {
		if (!isUseProjectConfiguration())
//			return JAVA;
			return BasicLanguageDependencyManager.JAVA_LANGUAGE;

		return getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), module, problem, test, LANGUAGE, BasicLanguageDependencyManager.JAVA_LANGUAGE);

	}
	public static String toCompoundProperty(String aParent, String aChild) {
		return aParent + "." + aChild;
	}
}
]]></snapshot>
  </Command>
  <Command __id="8151" _type="FileOpenCommand" date="Sun Aug 25 09:06:45 EDT 2019" docASTNodeCount="2381" docActiveCodeLength="20765" docExpressionCount="1479" docLength="31053" projectName="GraderBasics" timestamp="162729031">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\config\ABasicExecutionSpecification.java]]></filePath>
    <snapshot><![CDATA[package grader.basics.config;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.apache.commons.configuration.resolver.EntityRegistry;

import grader.basics.BasicLanguageDependencyManager;
import grader.basics.execution.BasicRunningProject;
import grader.basics.project.CurrentProjectHolder;
import grader.basics.project.Project;
import jdk.internal.dynalink.beans.StaticClass;
import util.trace.Tracer;
import static grader.basics.config.BasicStaticConfigurationUtils.*;
/*
 * We are duplicating code in BasicStaticConfigiration and keeping the same kind of state.
 * So we do not really need BasicStaticConfigiration
 * Let us keep them consistent
 * 
 * Actually we need all of this so we can override instance methods, which you cannot in
 * BasicStaticSpecification.
 */
public class ABasicExecutionSpecification implements BasicExecutionSpecification {
	protected List<String> emptyList = new ArrayList();
//	protected List<String> processTeams = new ArrayList<>();
//	protected List<String> processTeams = new ArrayList<>();

//	protected Map<String, List<String>> graderProcessTeamToProcesses = new HashMap<>();
//	protected Map<String, List<String>> graderProcessTeamToTerminatingProcesses = new HashMap<>();
//	protected Map<String, Integer> graderProcessToSleepTime = new HashMap<>();
//	protected Map<String, Integer> studentProcessToSleepTime = new HashMap<>();
//	protected Map<String, String> graderProcessToEntryTag = new HashMap<>();
//	protected Map<String, String> studentProcessToEntryTag = new HashMap<>();
//	protected Map<String, List<String>> graderProcessToEntryTags = new HashMap<>();
//	protected Map<String, List<String>> studentProcessToEntryTags = new HashMap<>();
//	protected Map<String, String> graderProcessToEntryPoint = new HashMap<>();
//	protected Map<String, String> studentProcessToEntryPoint = new HashMap<>();
//	protected Map<String, List<String>> graderProcessToArgs = new HashMap<>();
//	protected Map<String, List<String>> studentProcessToArgs = new HashMap<>();
//	protected Map<String, List<String>> graderProcessToStartTags = new HashMap<>();
//	protected Map<String, List<String>> studentProcessToStartTags = new HashMap<>();

	protected Map<String, String> runtimeGraderStringProperties = new HashMap<>();
	protected Map<String, String> runtimeStudentStringProperties = new HashMap<>();
	protected Map<String, Integer> runtimeGraderIntegerProperties = new HashMap<>();
	protected Map<String, Integer> runtimeStudentIntegerProperties = new HashMap<>();
	protected Map<String, Boolean> runtimeGraderBooleanProperties = new HashMap<>();
	protected Map<String, Boolean> runtimeStudentBooleanProperties = new HashMap<>();
	protected Map<String, List> runtimeGraderListProperties = new HashMap<>();
	protected Map<String, List> runtimeStudentListProperties = new HashMap<>();
	
	@Override
    public Integer getIntegerProperty(String aProperty, Integer aDefault) {
    	Integer retVal = getInheritedIntegerModuleProblemProperty(aProperty, null);
//		retVal = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration().getString(aProperty);  
		if (retVal != null) {
			return retVal;
		}
    	 retVal = runtimeStudentIntegerProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
//    	if (BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
    		    
//    	}
    	retVal = runtimeGraderIntegerProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
    	return aDefault;
    }
    @Override
    public Boolean getBooleanProperty(String aProperty, Boolean aDefault) {
    	Boolean retVal = getInheritedBooleanModuleProblemProperty(aProperty, null);
//		retVal = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration().getString(aProperty);  
		if (retVal != null) {
			return retVal;
		}
    	 retVal = runtimeStudentBooleanProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
//    	if (BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
    		    
//    	}
    	retVal = runtimeGraderBooleanProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
    	return aDefault;
    }
    
    @Override
    public String getStringProperty(String aProperty, String aDefault) {
    	String retVal = getInheritedStringModuleProblemProperty(aProperty, null);
//		retVal = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration().getString(aProperty);  
		if (retVal != null) {
			return retVal;
		}
    	 retVal = runtimeStudentStringProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
//    	if (BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
    		    
//    	}
    	retVal = runtimeGraderStringProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
    	return aDefault;
    }
    protected String getConfigurationDirectString(String aProperty, String aDefault) {
    	return BasicStaticConfigurationUtils.getConfigurationBasicDirectString(aProperty, aDefault);
    }
    protected List getConfigurationDirectList(String aProperty, List aDefault) {
    	return BasicStaticConfigurationUtils.getConfigurationBasicDirectList(aProperty, aDefault);
    }
    public String getDirectStringProperty(String aProperty, String aDefault) {
    	String retVal = getConfigurationDirectString(aProperty, null);
//		retVal = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration().getString(aProperty);  
		if (retVal != null) {
			return retVal;
		}
    	 retVal = runtimeStudentStringProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
//    	if (BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
    		    
//    	}
    	retVal = runtimeGraderStringProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
    	return aDefault;
    }
    public List<String> getDirectListProperty(String aProperty, List<String> aDefault) {
    	List<String> retVal = getConfigurationDirectList(aProperty, null);
//		retVal = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration().getString(aProperty);  
		if (retVal != null) {
			return retVal;
		}
    	 retVal = runtimeStudentListProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
//    	if (BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
    		    
//    	}
    	retVal = runtimeGraderListProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
    	return aDefault;
    }
    @Override
    public List getListProperty(String aProperty, List aDefault) {
    	List retVal = getInheritedListModuleProblemProperty(aProperty, null);
//		retVal = BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration().getString(aProperty);  
		if (retVal != null) {
			return retVal;
		}
    	retVal = runtimeStudentListProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
//    	if (BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
    		    
//    	}
    	retVal = runtimeGraderListProperties.get(aProperty);
    	if (retVal != null) {
    		return retVal;
    	}
    	return aDefault;
    }
    @Override
    public void setStudentStringProperty(String aProperty, String aValue) {
    	runtimeStudentStringProperties.put(aProperty, aValue);
    }
   
    @Override
    public void setGraderStringProperty(String aProperty, String aValue) {
    	runtimeGraderStringProperties.put(aProperty, aValue);
    }
    public  Integer getInheritedIntegerModuleProblemProperty(
			
			String aProperty, Integer defaultValue) {
    	return BasicStaticConfigurationUtils.getBasicInheritedIntegerModuleProblemProperty(aProperty, defaultValue);
//    	if (!BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
//    		return defaultValue;
//    	}
//		return BasicStaticConfigurationUtils.getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), BasicStaticConfigurationUtils.getModule(), BasicStaticConfigurationUtils.getProblem(), aProperty, defaultValue);

		
	}
    public  List getInheritedListModuleProblemProperty(
			
			String aProperty, List<String> defaultValue) {
    	return BasicStaticConfigurationUtils.getBasicInheritedListModuleProblemProperty(aProperty, defaultValue);
//    	if (!BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
//    		return defaultValue;
//    	}
//		return BasicStaticConfigurationUtils.getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), BasicStaticConfigurationUtils.getModule(), BasicStaticConfigurationUtils.getProblem(), aProperty, defaultValue);

		
	}
    public  String getInheritedStringModuleProblemProperty(
			
			String aProperty, String defaultValue) {
    	return BasicStaticConfigurationUtils.getBasicInheritedStringModuleProblemProperty(aProperty, defaultValue);
//    	if (!BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
//    		return defaultValue;
//    	}
//		return BasicStaticConfigurationUtils.getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), BasicStaticConfigurationUtils.getModule(), BasicStaticConfigurationUtils.getProblem(), aProperty, defaultValue);

		
	}
    public  Boolean getInheritedBooleanModuleProblemProperty(
			
			String aProperty, Boolean defaultValue) {
    	return BasicStaticConfigurationUtils.getBasicInheritedBooleanModuleProblemProperty(aProperty, defaultValue);
//    	if (!BasicStaticConfigurationUtils.isUseProjectConfiguration()) {
//    		return defaultValue;
//    	}
//		return BasicStaticConfigurationUtils.getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), BasicStaticConfigurationUtils.getModule(), BasicStaticConfigurationUtils.getProblem(), aProperty, defaultValue);

		
	}
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#getProcessTeams()
	 */
	@Override
	public List<String> getProcessTeams() {
		
		return getListProperty(BasicStaticConfigurationUtils.PROCESS_TEAMS, emptyList);
//		return processTeams;
	}
	@Override
	public void resetProcessTeams() {
		Tracer.info(this, "resetting process team: " );
		runtimeGraderListProperties.put(BasicStaticConfigurationUtils.PROCESS_TEAMS, emptyList);
//		processTeams = new ArrayList<>();
//		BasicStaticConfigurationUtils.setProcessTeams(processTeams);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setProcessTeams(java.util.List)
	 */
	@Override
	public void setProcessTeams(List<String> aProcessTeamNames) {
		Tracer.info(this, "Setting process team: " + aProcessTeamNames);
		runtimeGraderListProperties.put(BasicStaticConfigurationUtils.PROCESS_TEAMS, aProcessTeamNames);
//		processTeams = aProcessTeamNames;
//		BasicStaticConfigurationUtils.setProcessTeams(processTeams);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#getProcesses(java.lang.String)
	 */
	@Override
	public List<String> getProcesses(String aProcessTeam) {
		return getListProperty(aProcessTeam, emptyList);
//		return graderProcessTeamToProcesses.get(aProcessTeam);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setProcesses(java.lang.String, java.util.List)
	 */
	@Override
	public void setProcesses(String aProcessTeam, List<String> aProcesses) {
		Tracer.info(this, "Setting processes: " + aProcessTeam + " = " + aProcesses);
		runtimeGraderListProperties.put(aProcessTeam, aProcesses);
//		graderProcessTeamToProcesses.put(aProcessTeam, aProcesses);
	}
	
	@Override
	public List<String> getTerminatingProcesses(String aProcessTeam) {
		return getListProperty(
				BasicStaticConfigurationUtils.toCompoundProperty(
						aProcessTeam, BasicStaticConfigurationUtils.TERMINATING), emptyList);
//		return graderProcessTeamToTerminatingProcesses.get(aProcessTeam);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setProcesses(java.lang.String, java.util.List)
	 */
	@Override
	public void setTerminatingProcesses(String aProcessTeam, List<String> aProcesses) {
		Tracer.info(this, "Setting terminating processes: " + aProcessTeam + " - " + aProcesses);
		runtimeGraderListProperties.put(
				BasicStaticConfigurationUtils.toCompoundProperty(aProcessTeam, BasicStaticConfigurationUtils.TERMINATING),
				aProcesses);
		
//		graderProcessTeamToTerminatingProcesses.put(aProcessTeam, aProcesses);
	}
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#getSleepTime(java.lang.String)
	 */
	@Override
	public Integer getResourceReleaseTime(String aProcess) {
		Integer aRetVal = getIntegerProperty(
				toCompoundProperty(aProcess, RESOURCE_RELEASE_TIME), 
				null);
		if (aRetVal != null)
			return aRetVal;
		return getResourceReleaseTime();
				
//		return graderProcessToSleepTime.get(aProcess);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setSleepTime(java.lang.String, int)
	 */
	@Override
	public void setGraderResourceReleaseTime(String aProcess, int aSleepTime) {
		Tracer.info(this, "Setting grader resource release time for process " + aProcess + " to " + aSleepTime);
//		 graderProcessToSleepTime.put(aProcess, aSleepTime);
		runtimeGraderIntegerProperties.put(
				toCompoundProperty(aProcess, RESOURCE_RELEASE_TIME), 
				aSleepTime);
	}
	@Override
	public void setStudentResourceReleaseTime(String aProcess, int aSleepTime) {
		Tracer.info(this, "Setting grader resource release time for process " + aProcess + " to " + aSleepTime);
//		 graderProcessToSleepTime.put(aProcess, aSleepTime);
		runtimeStudentIntegerProperties.put(
				toCompoundProperty(aProcess, RESOURCE_RELEASE_TIME), 
				aSleepTime);
	}
	@Override
	public Integer getResourceReleaseTime() {
		return getIntegerProperty(
				RESOURCE_RELEASE_TIME, 
				DEFAULT_RESOURCE_RELEASE_TIME);
				
//		return graderProcessToSleepTime.get(aProcess);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setSleepTime(java.lang.String, int)
	 */
	@Override
	public void setGraderResourceReleaseTime(int aSleepTime) {
		Tracer.info(this, "Setting grader resource release time to " + aSleepTime);
//		 graderProcessToSleepTime.put(aProcess, aSleepTime);
		runtimeGraderIntegerProperties.put(
				RESOURCE_RELEASE_TIME, 
				aSleepTime);
	}
	@Override
	public void setStudentResourceReleaseTime (int aSleepTime) {
		Tracer.info(this, "Setting grader resource release time to " + aSleepTime);
//		 graderProcessToSleepTime.put(aProcess, aSleepTime);
		runtimeStudentIntegerProperties.put(
				RESOURCE_RELEASE_TIME, 
				aSleepTime);
	}
	
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#getEntrytag(java.lang.String)
	 */
	@Override
	public String getEntryTag(String aProcess) {
		return getStringProperty(
				toCompoundProperty(aProcess, ENTRY_TAG), null);
		
//		return graderProcessToEntryTag.get(aProcess);
		
	}
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setEntryTag(java.lang.String, java.lang.String)
	 */
	@Override
	public void setEntryTag(String aProcess, String anEntryTag) {
		Tracer.info(this, "Setting entry tag processes: " + aProcess + " - " + anEntryTag);
		runtimeGraderStringProperties.put(toCompoundProperty(aProcess, ENTRY_TAG), anEntryTag);
//		 graderProcessToEntryTag.put(aProcess, anEntryTag);
	}
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#getArgs(java.lang.String)
	 */
	@Override
	public List<String> getArgs(String aProcess) {
		return getListProperty(toCompoundProperty(aProcess, ARGS), emptyList);
//		return graderProcessToArgs.get(aProcess);
	}
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setArgs(java.lang.String, java.util.List)
	 */
	@Override
	public void setArgs(String aProcess, List<String> anArgs) {
		Tracer.info(this, "Setting processes args: " + aProcess + " - " + anArgs);
		runtimeGraderListProperties.put(toCompoundProperty(aProcess, ARGS), anArgs);
//		 graderProcessToArgs.put(aProcess, anEntryArgs);
	}
	
	@Override
	public List<String> getStartTags(String aProcess) {
		return getListProperty(toCompoundProperty(aProcess, START_TAGS), emptyList);

//		return graderProcessToStartTags.get(aProcess);
	}
	/* (non-Javadoc)
	 * @see grader.execution.ExecutionSpecification#setArgs(java.lang.String, java.util.List)
	 */
	@Override
	public void setStartTags(String aProcess, List<String> newVal) {
		Tracer.info(this, "Setting start tag processes: " + aProcess + " - " + newVal);
		runtimeGraderListProperties.put(toCompoundProperty(aProcess, START_TAGS), newVal);
//		graderProcessToStartTags.put(aProcess, aStartTags);
	}
	@Override
	public String getEntryPoint() {
		return getStringProperty(ENTRY_POINT, null);

//		return graderProcessToEntryPoint.get(aProcess);
	}
	@Override
	public void setEntryPoint(String anEntryPoint) {
		runtimeGraderStringProperties.put(ENTRY_POINT, anEntryPoint);
//		graderProcessToEntryPoint.put(aProcess, anEntryPoint);
	}

	@Override
	public String getEntryPoint(String aProcess) {
		return getStringProperty(toCompoundProperty(aProcess, ENTRY_POINT), null);

//		return graderProcessToEntryPoint.get(aProcess);
	}

	@Override
	public void setEntryPoint(String aProcess, String anEntryPoint) {
		Tracer.info(this, "Setting entry point processes: " + aProcess + " - " + anEntryPoint);
		runtimeGraderStringProperties.put(toCompoundProperty(aProcess, ENTRY_POINT), anEntryPoint);
//		graderProcessToEntryPoint.put(aProcess, anEntryPoint);
	}

	@Override
	public List<String> getEntryTags(String aProcess) {
		return getListProperty(toCompoundProperty(aProcess, ENTRY_TAGS), emptyList);
//		return graderProcessToEntryTags.get(aProcess);
	}

	@Override
	public void setEntryTags(String aProcess, List<String> anEntryTags) {
		Tracer.info(this, "Setting entry tags processes: " + aProcess + " - " + anEntryTags);
		runtimeGraderListProperties.put(toCompoundProperty(aProcess, ENTRY_TAGS), anEntryTags);
//		graderProcessToEntryTags.put(aProcess, anEntryTags);
		
	}
	
	public static int RESORT_TIME = 100;
	public static boolean WAIT_FOR_RESORT = true;

//	protected  long resortTime = RESORT_TIME;
//    protected  boolean waitForResort = true;
    @Override
    public   void setGraderResortTime(Integer aResortTime) {
//    	resortTime = aResortTime;
    	runtimeGraderIntegerProperties.put(BasicStaticConfigurationUtils.RESORT_TIME, aResortTime);
    	
    }
    @Override
    public void setGraderProcessOutputWaitTime(Integer newVal) {
//    	resortTime = aResortTime;
    	runtimeGraderIntegerProperties.put(BasicStaticConfigurationUtils.OUTPUT_WAIT_TIME, newVal);
    	
    }
    @Override
    public void setGraderProcessTeamOutputWaitTime(Integer newVal) {
//    	resortTime = aResortTime;
    	runtimeGraderIntegerProperties.put(BasicStaticConfigurationUtils.TEAM_OUTPUT_WAIT_TIME, newVal);
    	
    }
    @Override
    public  long getResortTime() {
    	return getIntegerProperty(BasicStaticConfigurationUtils.RESORT_TIME, RESORT_TIME);
    }
    @Override
    public  Integer getProcessOutputSleepTime() {
    	return getIntegerProperty(BasicStaticConfigurationUtils.OUTPUT_WAIT_TIME, BasicRunningProject.PROCESS_OUTPUT_SLEEP_TIME);
    }
    @Override
	public  Integer getProcessTeamOutputSleepTime() {
    	return getIntegerProperty(BasicStaticConfigurationUtils.TEAM_OUTPUT_WAIT_TIME, BasicRunningProject.PROCESS_TEAM_OUTPUT_OUTPUT_SLEEP_TIME);

	}
    @Override
    public  boolean isWaitForResort() {
//    	return BasicStaticConfigurationUtils.isTeamProcess() && waitForResort;
    	return BasicStaticConfigurationUtils.isTeamProcess() && getWaitForResortProperty();

    }
    @Override
    public  void setGraderWaitForResort(boolean newVal) {
//    	waitForResort = newVal;
    	runtimeGraderBooleanProperties.put(BasicStaticConfigurationUtils.WAIT_FOR_RESORT, newVal);

    }
    @Override
    public boolean getWaitForResortProperty() {
    	return getBooleanProperty(BasicStaticConfigurationUtils.WAIT_FOR_RESORT, WAIT_FOR_RESORT);
    }
    
 
    protected String gradableProjectLocation = null;
    @Override
    public String getGradableProjectLocation() {
    	if (gradableProjectLocation == null) {
    		gradableProjectLocation = getStringProperty(BasicStaticConfigurationUtils.GRADABLE_PROJECT_LOCATION, ".");
    	}
    	return gradableProjectLocation;
//    	return getStringProperty(BasicStaticConfigurationUtils.GRADABLE_PROJECT_LOCATION, ".");
    }
    @Override
    public void setStudentGradableProjectLocation(String aValue) {
    	runtimeStudentStringProperties.put(BasicStaticConfigurationUtils.GRADABLE_PROJECT_LOCATION, aValue);
    }
    protected String sourceFolderLocation = null;

    
    @Override
    // the default value is null, so this caching will not really help
    public String getSourceFolderLocation() {
    	if (sourceFolderLocation == null) {
    		sourceFolderLocation = getStringProperty(BasicStaticConfigurationUtils.SOURCE_LOCATION, null);
    	}
    	return sourceFolderLocation;
//    	return getStringProperty(BasicStaticConfigurationUtils.SOURCE_LOCATION, null);
    }
    protected String binaryFolderLocation = null;

    @Override
    public String getBinaryFolderLocation() {
    	if (binaryFolderLocation == null) {
    		binaryFolderLocation = getStringProperty(BasicStaticConfigurationUtils.BINARY_LOCATION, null);
    	}
    	return binaryFolderLocation;
//    	return getStringProperty(BasicStaticConfigurationUtils.BINARY_LOCATION, null);
    }
    protected String objectFolderLocation = null;

    @Override
    public String getObjectFolderLocation() {
    	if (objectFolderLocation == null) {
    		objectFolderLocation = getStringProperty(BasicStaticConfigurationUtils.OBJECT_LOCATION, null);
    	}
    	return objectFolderLocation;
//    	return getStringProperty(BasicStaticConfigurationUtils.BINARY_LOCATION, null);
    }
    // should we cache these values?
//    protected String language;
    @Override
    // no caching as each project can have different language
    public String getLanguage() {
    	return getStringProperty(BasicStaticConfigurationUtils.LANGUAGE,BasicLanguageDependencyManager.JAVA_LANGUAGE);
//    	if (language == null) {
//    		language = getStringProperty(BasicStaticConfigurationUtils.LANGUAGE,BasicLanguageDependencyManager.JAVA_LANGUAGE);
//    	}
//    	return language;
//    	return getStringProperty(BasicStaticConfigurationUtils.LANGUAGE,BasicLanguageDependencyManager.JAVA_LANGUAGE);
    }
//    // no caching as 
//    @Override
//    public List<String> getBasicCommand() {
//    	List<String> aCommand = getInheritedListModuleProblemProperty(BasicStaticConfigurationUtils.EXECUTION_COMMAND, null);
//    	if (aCommand != null && !aCommand.isEmpty()) {
//    		return aCommand;
//    	}
////    	String aLangugage = getLanguage();
//    	return BasicLanguageDependencyManager.getMainClassFinder().getDefaultCommand();
//    	
//    }
    @Override
    public List<String> getBasicCommand(String aProcess) {
    	String aProperty = toCompoundProperty(aProcess, BasicStaticConfigurationUtils.EXECUTION_COMMAND);
    	List<String> aCommand = getListProperty(aProperty, null);
    	if (aCommand != null && !aCommand.isEmpty()) {
    		return aCommand;
    	}
    	aCommand = getBasicCommand(); // more inheritance
    	if (aCommand != null && !aCommand.isEmpty()) {
    		return aCommand;
    	}
//    	String aLangugage = getLanguage();
    	return BasicLanguageDependencyManager.getMainClassFinder().getDefaultCommand();
    	
    }
    @Override
    public void setGraderBasicCommand(String aProcess, List<String> aCommand) {
    	String aProperty = toCompoundProperty(aProcess, BasicStaticConfigurationUtils.EXECUTION_COMMAND);
    	runtimeGraderListProperties.put(aProperty, aCommand);
    }
    // no caching as 
    @Override
    public List<String> getBasicCommand() {
    	List<String> aCommand = getListProperty(BasicStaticConfigurationUtils.EXECUTION_COMMAND, null);
    	if (aCommand != null && !aCommand.isEmpty()) {
    		return aCommand;
    	}
//    	String aLangugage = getLanguage();
    	return BasicLanguageDependencyManager.getMainClassFinder().getDefaultCommand();
    	
    }
    @Override
    public void setGraderBasicCommand(List<String> aCommand) {
    	runtimeGraderListProperties.put(BasicStaticConfigurationUtils.EXECUTION_COMMAND, aCommand);
    }
    @Override
    public  Integer getConstructorTimeOut() {
		return getIntegerProperty(CONSTRUCTOR_TIMEOUT, DEFAULT_CONSTRUCTOR_TIME_OUT);
	}
    @Override
	public  void setConstructorTimeOut(int constructorTimeOut) {
		runtimeGraderIntegerProperties.put(CONSTRUCTOR_TIMEOUT, constructorTimeOut);
//		BasicProjectExecution.constructorTimeOut = constructorTimeOut;
	}
    @Override
	public  int getMethodTimeOut() {
		return getIntegerProperty(METHOD_TIMEOUT, DEFAULT_METHOD_TIME_OUT);
	}
	@Override
	public  void setMethodTimeOut(int methodTimeOut) {
		runtimeGraderIntegerProperties.put(METHOD_TIMEOUT, methodTimeOut);

	}
	@Override
	public  int getProcessTimeOut() {
		 return getIntegerProperty(PROCESS_TIMEOUT, DEFAULT_PROCESS_TIME_OUT);
	}	
	
	@Override
	public  void setGraderProcessTimeOut(int newVal) {
		runtimeGraderIntegerProperties.put(PROCESS_TIMEOUT, newVal);

	}
	@Override
	public  void setStudentProcessTimeOut(int newVal) {
		runtimeStudentIntegerProperties.put(PROCESS_TIMEOUT, newVal);

	}
	@Override
	public  boolean isUseExecutor() {
		return getBooleanProperty(BasicStaticConfigurationUtils.USE_EXECEUTOR, BasicStaticConfigurationUtils.DEFAULT_USE_EXECUTOR);
//		return useMethodAndConstructorTimeOut;
	}
	@Override
	public  boolean isUseMethodAndConstructorTimeOut() {
		return getBooleanProperty(USE_METHOD_CONSTRUCTOR_TIMEOUT, true);
//		return useMethodAndConstructorTimeOut;
	}
	@Override
	public void setGraderUseMethodAndConstructorTimeOut(
			boolean useMethodAndConstructorTimeOut) {
		runtimeGraderBooleanProperties.put(USE_METHOD_CONSTRUCTOR_TIMEOUT, useMethodAndConstructorTimeOut);
//		BasicProjectExecution.useMethodAndConstructorTimeOut = useMethodAndConstructorTimeOut;
	}
	public void setStudentUseMethodAndConstructorTimeOut(
			boolean useMethodAndConstructorTimeOut) {
		runtimeStudentBooleanProperties.put(USE_METHOD_CONSTRUCTOR_TIMEOUT, useMethodAndConstructorTimeOut);
//		BasicProjectExecution.useMethodAndConstructorTimeOut = useMethodAndConstructorTimeOut;
	}
	@Override
	public  boolean isCheckAllSpecifiedTags() {
		return getBooleanProperty(CHECK_ALL_SPECIFIED_TAGS, DEFAULT_CHECK_ALL_SPECIFIED_TAGS);
//		return useMethodAndConstructorTimeOut;
	}
	@Override
	public void setGraderCheckAllSpecifiedTags(
			boolean newVal) {
		runtimeGraderBooleanProperties.put(CHECK_ALL_SPECIFIED_TAGS, newVal);
	}
//		BasicProjectEx
	@Override
	public  boolean isUseProcessTimeOut() {
		return getBooleanProperty(USE_PROCESS_TIMEOUT, true);
	}
	@Override
	public  void setGraderUseProcessTimeOut(
			boolean newVal) {
		runtimeGraderBooleanProperties.put(USE_PROCESS_TIMEOUT, newVal);
	}
	@Override
	public  boolean isForkMain() {
		return getBooleanProperty(FORK_MAIN, DEFAULT_FORK_MAIN);
	}
	@Override
	public  void setGraderForkMain(
			boolean newVal) {
		runtimeGraderBooleanProperties.put(FORK_MAIN, newVal);
	}
	@Override
	public  boolean isUseProjectConfiguration() {
		return getBooleanProperty(USE_PROJECT_CONFIGURATION, DEFAULT_USE_PROJECT_CONFIGURATION);
	}
	@Override
	public  void setUseProjectConfiguration(
			boolean newVal) {
		runtimeGraderBooleanProperties.put(USE_PROJECT_CONFIGURATION, newVal);
	}
	@Override
	public  void setStudentForkMain(
			boolean newVal) {
		runtimeStudentBooleanProperties.put(FORK_MAIN, newVal);
	}
	@Override
	public  boolean isWaitForMethodConstructorAndProcesses() {
		return getBooleanProperty(WAIT_FOR_METHOD_CONSTRUCTOR_AND_PROCESSES, true);
//		return useMethodAndConstructorTimeOut;
	}
	@Override
	public void setWaitForMethodConstructorAndProcesses(
			boolean newVal) {
		runtimeGraderBooleanProperties.put(WAIT_FOR_METHOD_CONSTRUCTOR_AND_PROCESSES, newVal);
//		BasicProjectExecution.useMethodAndConstructorTimeOut = useMethodAndConstructorTimeOut;
	}
//	@Override
//	public String getDynamicExecutionFileName() {
////		return StaticConfigurationUtils.getInheritedStringModuleProblemProperty(AConfigurationManager.DYNAMIC_CONFIG_PROPERTY, AConfigurationManager.DYNAMIC_CONFIGURATION_FILE_NAME);
//		return StaticConfigurationUtils.getDynamicExecutionFileName();
//	}
	 

	@Override
	public String getCObjSuffix() {
		return getDirectStringProperty(BasicStaticConfigurationUtils.C_OBJ, BasicStaticConfigurationUtils.DEFAULT_C_OBJ);
//		return  StaticConfigurationUtils.getInheritedStringModuleProblemProperty(StaticConfigurationUtils.C_OBJ, StaticConfigurationUtils.DEFAULT_C_OBJ);
	}

	@Override
	public String getExecutorDirectory() {
		return getDirectStringProperty(BasicStaticConfigurationUtils.EXECUTOR, BasicStaticConfigurationUtils.DEFAULT_EXECUTOR);
	}
	
	
	
	@Override
    public   void setGraderModules(List<String> aModules) {
//    	resortTime = aResortTime;
    	runtimeGraderListProperties.put(BasicStaticConfigurationUtils.MODULES, aModules);
    	
    }
	@Override
    public   void setGraderModule(String aModule) {
		List<String> aModules = new ArrayList();
		aModules.add(aModule);
//    	resortTime = aResortTime;
    	runtimeGraderListProperties.put(BasicStaticConfigurationUtils.MODULES, aModules);
    	
    }
//	@Override
//	public String getCObjSuffix() {
//		return getDirectStringProperty(BasicStaticConfigurationUtils.C_OBJ, BasicStaticConfigurationUtils.DEFAULT_C_OBJ);
//
////		return  StaticConfigurationUtils.getInheritedStringModuleProblemProperty(StaticConfigurationUtils.C_OBJ, StaticConfigurationUtils.DEFAULT_C_OBJ);
//	}
	@Override
	public List<String> getModules() {
		return getDirectListProperty(BasicStaticConfigurationUtils.MODULES, null);
	}

    
}
]]></snapshot>
  </Command>
  <Command __id="8156" _type="FileOpenCommand" date="Sun Aug 25 09:07:00 EDT 2019" docASTNodeCount="3023" docActiveCodeLength="23744" docExpressionCount="1687" docLength="40229" projectName="GraderBasics" timestamp="162743105">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\config\BasicStaticConfigurationUtils.java]]></filePath>
  </Command>
  <Command __id="8164" _type="FileOpenCommand" date="Sun Aug 25 09:07:32 EDT 2019" docASTNodeCount="2381" docActiveCodeLength="20765" docExpressionCount="1479" docLength="31053" projectName="GraderBasics" timestamp="162775342">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\config\ABasicExecutionSpecification.java]]></filePath>
  </Command>
  <Command __id="8167" _type="FileOpenCommand" date="Sun Aug 25 09:07:44 EDT 2019" docASTNodeCount="3023" docActiveCodeLength="23744" docExpressionCount="1687" docLength="40229" projectName="GraderBasics" timestamp="162787656">
    <filePath><![CDATA[D:\dewan_backup\Java\GraderBasics\src\grader\basics\config\BasicStaticConfigurationUtils.java]]></filePath>
  </Command>
  <Command __id="8182" _type="FileOpenCommand" date="Sun Aug 25 09:08:51 EDT 2019" docASTNodeCount="3043" docActiveCodeLength="27733" docExpressionCount="1824" docLength="51409" projectName="comp110-grader" timestamp="162854678">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\config\StaticConfigurationUtils.java]]></filePath>
    <snapshot><![CDATA[package grader.config;

import framework.grading.ProjectRequirements;
import grader.assignment.AnAssignmenDataFolder;
import grader.basics.BasicLanguageDependencyManager;
import grader.basics.config.BasicConfigurationManagerSelector;
import grader.basics.config.BasicStaticConfigurationUtils;
import grader.basics.project.Project;
import grader.basics.requirements.interpreter.specification.CSVRequirementsSpecification;
import grader.basics.settings.BasicGradingEnvironment;
import grader.permissions.java.JavaProjectToPermissionFile;
import grader.requirements.interpreter.AnInterpretedRequirements;
import grader.sakai.project.ASakaiProjectDatabase;
import grader.sakai.project.SakaiProjectDatabase;
import grader.settings.GraderSettingsManager;
import grader.settings.GraderSettingsManagerSelector;
import gradingTools.Driver;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.configuration.PropertiesConfiguration;
import org.junit.experimental.theories.PotentialAssignment;

import util.trace.Tracer;
/**
 * The class is used by AnExecutionSpecification
 * It acceses course and general confguration and define inheritance relationship
 * between them.
 * 
 * 
 * Do not cache any previously looked up values, as dynamic configuration may
 * change.
 * 
 * Execution specification caches the values.
 * 
 * It must be reloaded when dynamic configuration changes.
 * 
 * Its superclass caches in private variables, as it does not read configuration
 * files
 */
public class StaticConfigurationUtils extends BasicStaticConfigurationUtils{

	public static final String VISIT_ACTIONS = "visitActions";
	public static final String AUTO_GRADE = "autoGrade";
	public static final String AUTO_RUN = "autoRun";
//	public static final String[] DEFAULT_VISIT_ACTIONS_ARRAY = {AUTO_GRADE};

	public static final List<String> DEFAULT_VISIT_ACTIONS = new ArrayList(Arrays.asList(new String[]{AUTO_GRADE}));
	public static final String LOAD_CLASSES = "loadClasses";
	public static final boolean DEFAULT_LOAD_CLASSES = false;

	public static final String COMPILE_MISSING_CLASSES = "compileMissingObjectCode";
	public static final boolean DEFAULT_COMPILE_MISSING_CLASSES = true;;

	public static final String PRE_COMPILE_MISSING_CLASSES = "precompileMissingObjectCode";
	public static final boolean DEFAULT_PRE_COMPILE_CLASSES = false;

	public static final String FORCE_COMPILE_CLASSES = "forceCompile";
	public static final boolean DEFAULT_FORCE_COMPILE_CLASSES = false;

	public static final String UNZIP_FILES = "unzipFiles";
	public static final boolean DEFAULT_UNZIP_FILES = true;

	
	public static final String CHECK_STYLE = "checkStyle";
	public static final boolean DEFAULT_CHECK_STYLE = false;

	
	public static final String CHECK_STYLE_FILE = "checkStyleFile";
	
	public static final String EDITOR = "editor";
	public static final String DIFF = "diff";
	public static final String MODULE = "currentModule";
	public static final String PROBLEM_PATH = "path";
	public static final String PROBLEM_NAME = "problem";
	public static final String START_ONYEN = "start";
	public static final String END_ONYEN = "end";
	public static final String WORD_PATH = "Word.path";
	public static final String C_COMPILER_PATH = "CCompiler.path";
	public static final String DEFAULT_C_COMPILER_PATH = "gcc";

	public static final String PYTHON_INTERPRETER_PATH = "PythonInterpreter.path";
	public static final String ASSIGNMENTS_DATA_FOLDER = "grader.defaultAssignmentsDataFolderName";
	public static final String INTERACTION_LOG_DIRECTORY= "grader.logger.interactionLogDirectory";
	public static final String DEFAULT_INTERACTION_LOG_DIRECTORY = "./log/AssignmentsData/interactionLogs";
	public static final String DEFAULT_ASSIGNMENTS_DATA_FOLDER = "./log/AssignmentsData/{moduleName}";
	public static final String SPREADSHEET_LOG_FILE = "grader.logger.spreadsheetFilename";
	public static final String DEFAULT_SPREADSHEET_LOG_FILE = "./log/{moduleName}/{problemName}/grades.xlsx";
	public static final String LOGGERS = "grader.logger";
	public static final String DEFAULT_LOGGERS = "csv + feedback";	
	public static final String REQUIREMENTS = "requirements";
	public static final String DEFAULT_REQUIREMENTS = "gradingTools.{modulename}.{problemname}.{problemName}Requirements";
	
	protected static boolean doPermissions = true;



//	public static final String PRIVACY = "privacy";
//	public static final String EXECUTION_COMMAND = "execution";
//
//	public static final String LANGUAGE = "language";
//	public static final String REQUIREMENTS = "requirements";
//	public static final String ENTRY_POINT = "entryPoint";
//	public static final String BUILD_FOLDER = "buildFolder";
//	public static final String PERMISSIONS = "permissions";
//
//	public static final String CLASS_PATH = "classPath";
//	public static final String OE_PATH = "oePath";
//	public static final String JUNIT_PATH = "junitPath";
//	public static final String LOCAL_GRADER_PATH = "localGraderPath";
//	public static final String OE_AND_CLASS_PATH = "oeAndClassPath";
//	public static final String CLASS_PATH_SEPARATOR = ":";
//
//	public static final String PROCESS_TEAMS = "processTeams";
//
//	public static final String ENTRY_TAG = "entryTag";
//	public static final String ENTRY_TAGS = "entryTags";
//	public static final String SLEEP_TIME = "sleepTime";
//	public static final String ARGS = "args";
//	public static final String START_TAGS = "startTags";
//	public static final String TERMINATING = "terminating";
//	public static final String GENERATE_TRACE_FILES = "trace";
//
//	public static final String JAVA = "Java";
//
//	public static final String CLASS_PATH_VAR = toVariable(CLASS_PATH);
//	public static final String CLASS_PATH_SEPARATOR_VAR = toVariable(CLASS_PATH_SEPARATOR);
//	public static final String OE_PATH_VAR = toVariable(OE_PATH);
//	public static final String LOCAL_GRADER_PATH_VAR = toVariable(LOCAL_GRADER_PATH);
//
//	public static final String JUNIT_PATH_VAR = toVariable(JUNIT_PATH);
//	public static final String OE_AND_CLASS_PATH_VAR = toVariable(OE_AND_CLASS_PATH );
//	public static final String PERMISSIONS_VAR = toVariable(PERMISSIONS);
//	public static final String BUILD_FOLDER_VAR = toVariable(BUILD_FOLDER);
//	public static final String IMPLICIT_REQUIRMENTS_ROOT = "implicitRequirementsRoot";
//	public static final String DEFAULT_IMPLICIT_REQUIRMENTS_ROOT = "gradingTools";
//	public static final String USE_EXECEUTOR = "useExecutor";
//	public static final String EXECUTOR = "executor";
//	public static final String C_OBJ = "language.C.obj";	
//	public static final String FORK_MAIN = "forkMain";
//	public static  List<String> basicCommand;

	// public static final String ENTRY_TAG_VAR = toVariable(ENTRY_TAG);

	public static String toVariable(String aVariableName) {
		return "{" + aVariableName + "}";
	}

	public static String getImplicitRequirementsRoot(
			PropertiesConfiguration configuration) {
		return configuration.getString(IMPLICIT_REQUIRMENTS_ROOT,
				DEFAULT_IMPLICIT_REQUIRMENTS_ROOT);
	}
	@Deprecated
	public static List<String> autoVisitActions(
			
			GraderSettingsManager graderSettingsManager) {
		PropertiesConfiguration staticConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getStaticConfiguration();
		PropertiesConfiguration courseConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getCourseConfiguration();
		List<String> retVal = autoVisitActions(courseConfiguration, graderSettingsManager);
		if (retVal ==null)
			retVal = autoVisitActions(staticConfiguration, graderSettingsManager);
		if (retVal == null)
			retVal = new ArrayList();
		return retVal;
		 

	}

	public static List<String> autoVisitActions(
			PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {
		String module = graderSettingsManager.getModule();
		String problem = graderSettingsManager.getNormalizedProblem(module);
		List retVal = configuration.getList(module + "." + problem + "."
				+ VISIT_ACTIONS, null);
//		if (retVal == null)
//			return null;
		if (retVal == null || retVal.isEmpty()) {
			retVal = configuration.getList(module + "." + VISIT_ACTIONS, null);
		}
		if (retVal == null || retVal.isEmpty()) {
			retVal = configuration.getList(BasicStaticConfigurationUtils.DEFAULT + "." + VISIT_ACTIONS, null);
		}

		return retVal;

	}

	public static boolean getLoadClasses(PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

//		return getInheritedBooleanModuleProblemProperty(configuration,
//				graderSettingsManager, LOAD_CLASSES, false);
		return ExecutionSpecificationSelector.getExecutionSpecification().isLoadClasses();

	}

	public static boolean getAllowCompileClasses(
			PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

//		return getInheritedBooleanModuleProblemProperty(configuration,
//				graderSettingsManager, COMPILE_MISSING_CLASSES, false);
		return ExecutionSpecificationSelector.getExecutionSpecification().isCompileMissingClasses();

	}

	public static boolean getPrecompileClasses(
			PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

//		return getInheritedBooleanModuleProblemProperty(configuration,
//				graderSettingsManager, PRE_COMPILE_CLASSES, false);
		return ExecutionSpecificationSelector.getExecutionSpecification().isPreCompileMissingClasses();

	}

	public static boolean getUnzipFiles(PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

//		return getInheritedBooleanModuleProblemProperty(configuration,
//				graderSettingsManager, UNZIP_FILES, true); // unzip by default
		return ExecutionSpecificationSelector.getExecutionSpecification().isUnzipFiles();

	}
	
	public static boolean getCheckStyle(PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

		return getInheritedBooleanModuleProblemProperty(configuration,
				graderSettingsManager, CHECK_STYLE, false);

	}
	public static boolean getCheckStyle() {

//		return getInheritedBooleanModuleProblemProperty(
//				 CHECK_STYLE, false);
		return ExecutionSpecificationSelector.getExecutionSpecification().isCheckStyle();

	}
	
	public static boolean isForkMainProcess (){
//		return getInheritedBooleanModuleProblemProperty(
//				 FORK_MAIN, true);
		return ExecutionSpecificationSelector.getExecutionSpecification().isForkMain();
	}
	
	public static String getCheckStyleFile() {

		return getInheritedStringModuleProblemProperty(
				 CHECK_STYLE_FILE, AnAssignmenDataFolder.DEFAULT_CONFIGURATION_FILE);

	}

	public static boolean getForceCompileClasses(
			PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

//		return getInheritedBooleanModuleProblemProperty(configuration,
//				graderSettingsManager, FORCE_COMPILE_CLASSES, false);
		return ExecutionSpecificationSelector.getExecutionSpecification().isForceCompile();

	}

	public static boolean getPrivacy(PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {
		// String module = graderSettingsManager.getModule();
		// String problem = graderSettingsManager.getNormalizedProblem(module);
		// Boolean retVal = configuration.getBoolean(module+"." + problem + "."
		// + MAKE_CLASS_DESCRIPTION, null);
		//
		// if (retVal == null)
		// retVal = configuration.getBoolean(module+"." +
		// MAKE_CLASS_DESCRIPTION, null);
		// if (retVal == null)
		// retVal = configuration.getBoolean(DEFAULT+"." +
		// MAKE_CLASS_DESCRIPTION, false);
		//
		// return retVal;
		return getInheritedBooleanModuleProblemProperty(configuration,
				graderSettingsManager, PRIVACY, false);

	}

	public static boolean getPrivacy(PropertiesConfiguration configuration,
			String aModule, String aProblem) {
		// String module = graderSettingsManager.getModule();
		// String problem = graderSettingsManager.getNormalizedProblem(module);
		// Boolean retVal = configuration.getBoolean(module+"." + problem + "."
		// + MAKE_CLASS_DESCRIPTION, null);
		//
		// if (retVal == null)
		// retVal = configuration.getBoolean(module+"." +
		// MAKE_CLASS_DESCRIPTION, null);
		// if (retVal == null)
		// retVal = configuration.getBoolean(DEFAULT+"." +
		// MAKE_CLASS_DESCRIPTION, false);
		//
		// return retVal;
		return BasicStaticConfigurationUtils.getInheritedBooleanModuleProblemProperty(configuration, aModule,
				aProblem, test, PRIVACY, false);

	}

	public static Boolean getInheritedBooleanModuleProblemProperty(
			PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager, String property,
			Boolean defaultValue) {
		String module = graderSettingsManager.getModule();
		String problem = graderSettingsManager.getNormalizedProblem(module);

		return BasicStaticConfigurationUtils.getInheritedBooleanModuleProblemProperty(configuration, module,
				problem, test, property, defaultValue);
		// Boolean retVal = configuration.getBoolean(module+"." + problem + "."
		// + property, null);
		//
		// if (retVal == null)
		// retVal = configuration.getBoolean(module+"." + property, null);
		// if (retVal == null)
		// retVal = configuration.getBoolean(DEFAULT+"." + property,
		// defaultValue);
		//
		// return retVal;

	}

	public static Boolean getInheritedBooleanModuleProblemProperty(
			String module,
			String problem, String property, Boolean aDefaultValue) {

		Boolean retVal = getCourseOrStaticBoolean(module + "." + problem + "."
				+ property, null);

		if (retVal == null) {
			retVal = getCourseOrStaticBoolean(module + "." + property, null);
		}
		if (retVal == null) {
			retVal = getCourseOrStaticBoolean(BasicStaticConfigurationUtils.DEFAULT + "." + property,
					aDefaultValue);
		}

		return retVal;

	}
	public static Integer getInheritedIntegerModuleProblemProperty(
			String module,
			String problem, String property, Integer aDefaultValue) {

		Integer retVal = getCourseOrStaticInteger(module + "." + problem + "."
				+ property, null);

		if (retVal == null) {
			retVal = getCourseOrStaticInteger(module + "." + property, null);
		}
		if (retVal == null) {
			retVal = getCourseOrStaticInteger(BasicStaticConfigurationUtils.DEFAULT + "." + property,
					aDefaultValue);
		}

		return retVal;

	}
	public static String[] getExecutionCommand(Project aProject,
			File aBuildFolder) {
		String anEntryPoint = getInheritedStringModuleProblemProperty(
				toVariable(ENTRY_POINT), null);

		return getExecutionCommand(aProject, aBuildFolder, anEntryPoint);
	}

	public static String[] getExecutionCommand(Project aProject,
			File aBuildFolder, String anEntryPoint) {

		return getExecutionCommand(aProject, null, aBuildFolder, anEntryPoint,
				"", new String[0]);

	}
	public static String[] getExecutionCommand(Project aProject,
			File aBuildFolder, String anEntryPoint, String[] anArgs) {

		return getExecutionCommand(aProject, null, aBuildFolder, anEntryPoint,
				"", anArgs);

	}
	// renamed from getBasicCommand to getExecutionCommand to not confuse with superclass
	// getBasicCommand
	// but it seems to be returning basic command
	public static List<String> getExecutionCommand() {
//		return getInheritedListModuleProblemProperty(EXECUTION_COMMAND, emptyList);
//		return ExecutionSpecificationSelector.getExecutionSpecification().getBasicCommand();
		return BasicStaticConfigurationUtils.getBasicCommand();

	}
//	public static void setBasicCommand(List<String> newVal) {
//		basicCommand = newVal;
//	}
	public static boolean hasClassPath() {
//		getBasicCommand();
		return hasClassPath(getExecutionCommand());
//		if (basicCommand == null) {
//			return false;
//		}
//		for (String aCommand:basicCommand) {
//			if (aCommand.contains(CLASS_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
//				return true;
//			}
//		}
//		return false;	
	}
//	public static boolean hasClassPath() {
//		getBasicCommand();
//		if (basicCommand == null) {
//			return false;
//		}
//		for (String aCommand:basicCommand) {
//			if (aCommand.contains(CLASS_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
//				return true;
//			}
//		}
//		return false;	
//	}
	public static boolean hasOEClassPath() {
		return hasOEClassPath(getExecutionCommand());
//		getBasicCommand();
//		if (basicCommand == null) {
//			return false;
//		}
//		for (String aCommand:basicCommand) {
//			if (aCommand.contains(OE_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
//				return true;
//			}
//		}
//		return false;	
	}
	
//	
//	public static boolean hasOEClassPath() {
//		getBasicCommand();
//		if (basicCommand == null) {
//			return false;
//		}
//		for (String aCommand:basicCommand) {
//			if (aCommand.contains(OE_PATH_VAR) || aCommand.contains(OE_AND_CLASS_PATH_VAR)) {
//				return true;
//			}
//		}
//		return false;	
//	}
	public static boolean hasOEOrClassPath() {
		return hasClassPath(getExecutionCommand()) || hasOEClassPath(getExecutionCommand());
	}
//	
//	public static boolean hasOEOrClassPath() {
//		return hasClassPath() || hasOEClassPath();
//	}
	
//	static String[] emptyEntryPoints = {};
//	protected static String[] potentialMainEntryPoints;
////	public static String[] getPotentialMainEntryPointNames() {
////		String retVal = getInheritedStringModuleProblemProperty(ENTRY_POINT, null);
////		if (retVal != null) {
////			GraderSettingsManager manager = GraderSettingsManagerSelector.getGraderSettingsManager();
////			retVal = manager.replaceModuleProblemVars(retVal);
////			return new String[]{retVal.replaceAll(" ", "")};
////		}
////		return emptyEntryPoints;
////	}
//	
//	public static void setPotentialMainEntryPointNames(String[] aNames) {
//		potentialMainEntryPoints = aNames;
//	}
	
	public static String[] getPotentialMainEntryPointNames() {
		if (potentialMainEntryPoints == null) {
		String retVal = getInheritedStringModuleProblemProperty(ENTRY_POINT, null);
		if (retVal != null) {
			GraderSettingsManager manager = GraderSettingsManagerSelector.getGraderSettingsManager();
			retVal = manager.replaceModuleProblemVars(retVal);
			potentialMainEntryPoints = new String[]{retVal.replaceAll(" ", "")};
		} else {
			potentialMainEntryPoints = emptyEntryPoints;
		}
		}
		return BasicStaticConfigurationUtils.getPotentialMainEntryPointNames();
//		return potentialMainEntryPoints;
	}


//	public static List<String> getBasicCommand(String aProcessName) {
//		List<String> retVal = getInheritedListModuleProblemProperty(aProcessName
//				+ "." + EXECUTION_COMMAND);
//		if (retVal.isEmpty()) {
//			return getBasicCommand();
//		} else {
//			return retVal;
//		}
//	}
//	public static List<String> getBasicCommand(String aProcessName) {
//		List<String> retVal = getInheritedListModuleProblemProperty(aProcessName
//				+ "." + EXECUTION_COMMAND);
//		if (retVal.isEmpty()) {
//			return getBasicCommand();
//		} else {
//			return retVal;
//		}
//	}
	public static List<String> getBasicCommand(String aProcessName) {
//		List<String> retVal = processToBasicCommand.get(aProcessName);
//		if (retVal != null) {
//			return retVal;
//		}
		List<String> retVal = getInheritedListModuleProblemProperty(aProcessName
				+ "." + EXECUTION_COMMAND, null);
		if (retVal.isEmpty()) {
			return getExecutionCommand();
		} else {
			return retVal;
		}
	}
//	public static boolean hasEntryPoint(List<String> aCommand) {
//		return hasSubString(aCommand, ENTRY_POINT);
//	}
//
//	public static boolean hasSubString(List<String> aCommand, String aSubString) {
//		for (String aCommmandComponent : aCommand) {
//			if (aCommmandComponent.contains(aSubString)) {
//				return true;
//			}
//		}
//		return false;
//	}
//
//	public static boolean hasEntryTag(List<String> aProcessCommand) {
//		return hasSubString(aProcessCommand, ENTRY_TAG);
//	}
//
//	public static boolean hasEntryTags(List<String> aProcessCommand) {
//		return hasSubString(aProcessCommand, ENTRY_TAGS);
//	}
//
//	public static boolean haArgs(String aProcessCommand) {
//		return aProcessCommand.contains(ARGS);
//	}
	
//	static boolean doPermissions = true;
//	
////	public static final String FILE_SEPARATOR = System.getProperty("file.separator");
//	public static final String FILE_SEPARATOR = "/";
//
//
//	public static String quotePath(String path) {
//		if (!path.contains(" ")) return path;
//	    boolean startSlash = path.startsWith("\\") || path.startsWith("/");
//	    boolean endSlash = path.endsWith("\\") || path.endsWith("/");
//	    String[] split = path.split("[\\\\/]+");
//
//	    StringBuilder quotPath = new StringBuilder(path.length());
//
//	    if (startSlash) {
//	        quotPath.append(FILE_SEPARATOR);
//	    }
//	    
//	    for(int i = 0; i < split.length; i ++) {
//	    	String s = split[i];
//	        if (s.contains(" ")) {
////	            s = "\"" + s + "\"";
//	            s = "\\\"" + s + "\\\"";
//
//	        }
//	        quotPath.append(s);
//	        if (i+1 < split.length) {
//	            quotPath.append(FILE_SEPARATOR);
//	        }
//	    }
//	    
//	    if (endSlash) {
//	        quotPath.append(FILE_SEPARATOR);
//	    }
//	    
//	    return quotPath.toString();
//	}
//	
//	public static int getClassPathFlagIndex(List<String> aBasicCommand) {
//		int aCpIndex = aBasicCommand.indexOf("-cp");
//		if (aCpIndex < 0) 
//			aCpIndex = aBasicCommand.indexOf("-classpath");
//		return aCpIndex;
//	}
//	
	public static String getExecutionCommandRawClassPath() {
		return getExecutionCommandRawClassPath(getExecutionCommand());
//		List<String> aBasicCommand = getBasicCommand();
//		int aCpIndex = getClassPathFlagIndex(aBasicCommand);
//		if (aCpIndex < 0)
//			return null;
//		if (aCpIndex + 1 >= aBasicCommand.size())
//			return null;
//		return getReplacedRawClassPath(aBasicCommand.get(aCpIndex + 1));
		
	}
//	public static String getExecutionCommandRawClassPath(List<String> aBasicCommand) {
////		List<String> aBasicCommand = getBasicCommand();
//		int aCpIndex = getClassPathFlagIndex(aBasicCommand);
//		if (aCpIndex < 0)
//			return null;
//		if (aCpIndex + 1 >= aBasicCommand.size())
//			return null;
//		return getReplacedRawClassPath(aBasicCommand.get(aCpIndex + 1));
//		
//	}
//	
//	public static String getReplacedRawClassPath (String command) {
//		// do we really need all of these ifs, more efficient without them? - debugging will be easier
//					// all of these will be in the same command
//					if (command.contains(CLASS_PATH_VAR)) {
//
//						command = command.replace(CLASS_PATH_VAR,
//								BasicGradingEnvironment.get().getClassPath());
//					}
//
//					if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
//						command = command.replace(CLASS_PATH_SEPARATOR_VAR,
//								BasicGradingEnvironment.get().getClassPathSeparator());
//					}
//					 
//					if (command.contains(LOCAL_GRADER_PATH_VAR)) {
//
//						command = command.replace(LOCAL_GRADER_PATH_VAR,
//						// BasicGradingEnvironment.get().getClasspath());
//								BasicGradingEnvironment.get().getLocalGraderClassPath());
//
//					} 
//					if (command.contains(OE_PATH_VAR)) {
//						if (command.toLowerCase().contains("local")) { // we already have oeall
//							command = command.replace(OE_PATH_VAR,
//									// BasicGradingEnvironment.get().getClasspath());
//									"");
//						} else {
//						command = command.replace(OE_PATH_VAR,
//						// BasicGradingEnvironment.get().getClasspath());
//								BasicGradingEnvironment.get().getOEClassPath());
//						}
//
//					}
//
//					if (command.contains(JUNIT_PATH_VAR)) {
//						command = command.replace(JUNIT_PATH_VAR,
//								BasicGradingEnvironment.get().getJUnitClassPath());
//						// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
//						// command = command.replace(OE_AND_CLASS_PATH_VAR,
//						// BasicGradingEnvironment.get().getClassPath());
//					} 
//					String aClassPathSeparator = BasicGradingEnvironment.get().getClassPathSeparator();
//					if (duplicatedClassPathSeparator == null) {
//						//just avoding new String creation
//						duplicatedClassPathSeparator = aClassPathSeparator + aClassPathSeparator;
//					}
//					// certain libraries may not exist, specially in the server, see what happens without them
//					command = command.replaceAll(duplicatedClassPathSeparator, aClassPathSeparator);
//					return command;
//					// javac wants no quotes!
////					String anOSPath = BasicGradingEnvironment.get().toOSClassPath(command);
////					return anOSPath;
//	}
//	static String duplicatedClassPathSeparator;
//	public static void replaceClassPathVars (List<String> basicCommand) {
//		int aCpIndex = getClassPathFlagIndex(basicCommand);
//		if (aCpIndex < 0)
//			return ;
//		
//		if (aCpIndex + 1 >= basicCommand.size()) {
//			Tracer.warning("Nothing follows classpath flag");
//			return ;
//		}
//		String aReplacement = getReplacedRawClassPath(basicCommand.get(aCpIndex + 1));
//		String anOSPath = BasicGradingEnvironment.get().toOSClassPath(aReplacement);
//		basicCommand.set(aCpIndex + 1, anOSPath);
//
//		
////		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
////
////			String command = basicCommand.get(aCommandIndex);
////			
//////			// do we really need all of these ifs, more efficient without them? - debugging will be easier
//////			// all of these will be in the same command
//////			if (command.contains(CLASS_PATH_VAR)) {
//////
//////				command = command.replace(CLASS_PATH_VAR,
//////						BasicGradingEnvironment.get().getClassPath());
//////			}
//////
//////			if (command.contains(CLASS_PATH_SEPARATOR_VAR)) {
//////				command = command.replace(CLASS_PATH_SEPARATOR_VAR,
//////						BasicGradingEnvironment.get().getClassPathSeparator());
//////			}
//////			if (command.contains(OE_PATH_VAR)) {
//////
//////				command = command.replace(OE_PATH_VAR,
//////				// BasicGradingEnvironment.get().getClasspath());
//////						BasicGradingEnvironment.get().getOEClassPath());
//////
//////			} 
//////			if (command.contains(JUNIT_PATH_VAR)) {
//////				command = command.replace(JUNIT_PATH_VAR,
//////						BasicGradingEnvironment.get().getJUnitClassPath());
//////				// } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
//////				// command = command.replace(OE_AND_CLASS_PATH_VAR,
//////				// BasicGradingEnvironment.get().getClassPath());
//////			} 
////			command = getReplacedClassPath(command);
////			basicCommand.set(aCommandIndex, command);
////		}
//	}
//	
	public static void replacePermissionVariables(List<String> basicCommand, Project aProject) {
		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {

			String command = basicCommand.get(aCommandIndex);
			if (doPermissions && command.contains(PERMISSIONS_VAR)) {

				String aPolicyFilePath = JavaProjectToPermissionFile
						.getPermissionFile(aProject).getAbsolutePath();
				try {
					aPolicyFilePath = JavaProjectToPermissionFile
							.getPermissionFile(aProject).getCanonicalPath();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
				aPolicyFilePath = aPolicyFilePath.replace("\\", "/");

				aPolicyFilePath = quotePath(aPolicyFilePath);

				command = command.replace(PERMISSIONS_VAR, aPolicyFilePath);
				basicCommand.set(aCommandIndex, command);

			}
		}
	}
//	
//	public static void replaceEntryPoint(List<String> basicCommand,  String anEntryPoint,
//			String anEntryTagTarget) {
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			if (anEntryPoint != null) {
//				command = command
//						.replace(toVariable(ENTRY_POINT), anEntryPoint);
//			}
//			if (anEntryTagTarget != null) {
//				command = command.replace(toVariable(ENTRY_TAGS),
//						anEntryTagTarget);
//				command = command.replace(toVariable(ENTRY_TAG),
//						anEntryTagTarget); // will match tags also
//
//			}
//			basicCommand.set(aCommandIndex, command);
//		}
//	}
//	public static void replaceBuildFolder(List<String> basicCommand,  File aBuildFolder) {
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			// we should always have a build folder I suppose
//			// this is meant for C like programs
//			if (command.contains(BUILD_FOLDER_VAR)) {
//			command = command.replace(BUILD_FOLDER_VAR,
//					aBuildFolder.getAbsolutePath());
//			basicCommand.set(aCommandIndex, command);
//
//			}
//		}
//	}
//	public static void replaceArgs(List<String> basicCommand,  String[] anArgs) {
//		int argsIndex = basicCommand.indexOf(toVariable(ARGS));
//		if (argsIndex >= 0) {
//			basicCommand.remove(argsIndex);
//			for (int i = 0; i < anArgs.length; i++) {
//				basicCommand.add(argsIndex + i, anArgs[i]);
//			}
//
//		}
//	}
	/*
	 * Should be called only by AnExecutionSpecification
	 */
	public static String[] getExecutionCommand(Project aProject,
			String aProcessName, File aBuildFolder, String anEntryPoint,
			String anEntryTagTarget, String[] anArgs) {
	

			List<String> basicCommand = null;
			if (aProcessName == null || aProcessName.isEmpty()) {
			
				basicCommand = getExecutionCommand();
			} else {
			
				basicCommand = getBasicCommand(aProcessName);

			}
			System.out.println("Basic Command:" + basicCommand);
		String[] retVal = BasicStaticConfigurationUtils.getExecutionCommand(basicCommand, aProject, aProcessName, aBuildFolder, anEntryPoint, anEntryTagTarget, anArgs);
		List<String> aListRetVal = Arrays.asList(retVal);
		
		replacePermissionVariables(aListRetVal, aProject);
		System.out.println("Execution Command:" + aListRetVal);

		return aListRetVal.toArray(new String[0]);


//		List<String> basicCommand = null;
//		if (aProcessName == null || aProcessName.isEmpty()) {
//		
//			basicCommand = getBasicCommand();
//		} else {
//		
//			basicCommand = getBasicCommand(aProcessName);
//
//		}
////		List<String> retVal = new ArrayList(basicCommand.size());
//		List<String> retVal = new ArrayList(basicCommand.size() + 5); // to accommodate args
//		retVal.addAll(basicCommand);
//		replaceClassPathVars(retVal);
//		replacePermissionVariables(retVal, aProject);
//		replaceEntryPoint(retVal, anEntryPoint, anEntryTagTarget);
//		replaceBuildFolder(retVal, aBuildFolder);
//		replaceArgs(retVal, anArgs);
//		return retVal.toArray(new String[0]);




	}
	// this stuff worked with oritinal class path stuff
//	public static String[] getExecutionCommand(Project aProject,
//			String aProcessName, File aBuildFolder, String anEntryPoint,
//			String anEntryTagTarget, String[] anArgs) {
//
//		List<String> basicCommand = null;
//		if (aProcessName == null || aProcessName.isEmpty()) {
//			// basicCommand =
//			// getInheritedListModuleProblemProperty(EXECUTION_COMMAND);
//			basicCommand = getBasicCommand();
//		} else {
//			// basicCommand = getInheritedListModuleProblemProperty(aProcessName
//			// + "." + EXECUTION_COMMAND);
//			basicCommand = getBasicCommand(aProcessName);
//
//		}
//		List<String> retVal = new ArrayList(basicCommand.size());
//		// for (int aCommandIndex = 0; aCommandIndex < basicCommand.size();
//		// aCommandIndex++) {
//		//
//		// String command =
//		// basicCommand.get(aCommandIndex).replace(toVariable(CLASS_PATH),
//		// GradingEnvironment.get().getClasspath());
//		// command = command.replace(toVariable(PERMISSIONS),
//		// "\"" +
//		// JavaProjectToPermissionFile.getPermissionFile(aProject).getAbsolutePath()
//		// + "\"");
//		// if (anEntryPoint != null) {
//		// command = command.replace(toVariable(ENTRY_POINT), anEntryPoint);
//		// }
//		// if (anEntryTagTarget != null) {
//		// command = command.replace(toVariable(ENTRY_TAGS), anEntryTagTarget);
//		// command = command.replace(toVariable(ENTRY_TAG), anEntryTagTarget);
//		// // will match tags also
//		//
//		// }
//		//
//		// // if (anEntryTagTarget != null)
//		// command = command.replace(toVariable(BUILD_FOLDER),
//		// aBuildFolder.getAbsolutePath());
//		//
//		// retVal.add(command);
//		// }
//
//		for (int aCommandIndex = 0; aCommandIndex < basicCommand.size(); aCommandIndex++) {
//
//			String command = basicCommand.get(aCommandIndex);
//			if (command.contains(CLASS_PATH_VAR)) {
////				command = command.replace(CLASS_PATH_VAR, "\""
////						+ GradingEnvironment.get().getClasspath() + "\"");
//				command = command.replace(CLASS_PATH_VAR, 
//						BasicGradingEnvironment.get().getClasspath());
//
//				// } else if (command.contains(PERMISSIONS_VAR)) {
//				// command = command.replace(PERMISSIONS_VAR,
//				// "\"" +
//				// JavaProjectToPermissionFile.getPermissionFile(aProject).getAbsolutePath()
//				// + "\"");
//				// }
//			} else if (command.contains(OE_PATH_VAR)) {
////				command = command.replace(CLASS_PATH_VAR, "\""
////				+ GradingEnvironment.get().getClasspath() + "\"");
//		         command = command.replace(OE_PATH_VAR, 
//				BasicGradingEnvironment.get().getClasspath());
//
//	      } else if (command.contains(OE_AND_CLASS_PATH_VAR)) {
//	    	   command = command.replace(OE_AND_CLASS_PATH_VAR, 
//	   				BasicGradingEnvironment.get().getClasspath());
//	      }
//			else if (doPermissions && command.contains(PERMISSIONS_VAR)) {
//				// URL policyFileURL =
//				// Class.class.getResource("/server/model/easy.policy");
//				String aPolicyFilePath = JavaProjectToPermissionFile
//						.getPermissionFile(aProject).getAbsolutePath();
//				try {
//					aPolicyFilePath = JavaProjectToPermissionFile
//							.getPermissionFile(aProject).getCanonicalPath();
//				} catch (IOException e1) {
//					// TODO Auto-generated catch block
//					e1.printStackTrace();
//				}
//				aPolicyFilePath = aPolicyFilePath.replace("\\", "/");
//
////				aPolicyFilePath = "C:/Users/dewan/Downloads/A7/\"Assignment 7\"/permissions0.txt";
//				
//				aPolicyFilePath = quotePath(aPolicyFilePath);
//
////				try {
////					URL aPermissionFileURL = Class.class
////							.getResource(aPolicyFilePath);
////
////					aPolicyFilePath = URLDecoder.decode(
////							aPermissionFileURL.getFile(), "UTF-8");
////				} catch (Exception e) {
////					System.err.println("Could not decode: " + e.getMessage());
////				}
//				command = command.replace(
//						PERMISSIONS_VAR,
////						"\"" +
//								aPolicyFilePath
////								JavaProjectToPermissionFile
////										.getPermissionFile(aProject)
////										.getAbsolutePath() + 
////										+ "\""
//								);
//			}
//
//			if (anEntryPoint != null) {
//				command = command
//						.replace(toVariable(ENTRY_POINT), anEntryPoint);
//			}
//			if (anEntryTagTarget != null) {
//				command = command.replace(toVariable(ENTRY_TAGS),
//						anEntryTagTarget);
//				command = command.replace(toVariable(ENTRY_TAG),
//						anEntryTagTarget); // will match tags also
//
//			}
//
//			// if (anEntryTagTarget != null)
//			command = command.replace(toVariable(BUILD_FOLDER),
//					aBuildFolder.getAbsolutePath());
//
//			retVal.add(command);
//		}
//		int argsIndex = retVal.indexOf(toVariable(ARGS));
//		if (argsIndex >= 0) {
//			retVal.remove(argsIndex);
//			for (int i = 0; i < anArgs.length; i++) {
//				retVal.add(argsIndex + i, anArgs[i]);
//			}
//
//		}
//		return retVal.toArray(new String[0]);
//
//	}
	public static List getCourseOrStaticList(String aProperty, List aDefault) {
		PropertiesConfiguration staticConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getStaticConfiguration();
		PropertiesConfiguration courseConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getCourseConfiguration();
		 List aRetVal = null;
		 if (courseConfiguration != null) {
		 aRetVal = courseConfiguration.getList(aProperty, aDefault);
		 }
         if (aRetVal == null) {
        	 if (staticConfiguration == null) {
        		 return aDefault;
        	 }
         	aRetVal = staticConfiguration.getList(aProperty, aDefault);
         }
         return aRetVal;		
	}
	
	public static String getDynamicInheritedStringModuleProblemProperty(String aProperty, String aDefault) {
		PropertiesConfiguration aDynamicConfiguration =  ConfigurationManagerSelector.getConfigurationManager().getDynamicConfiguration();

		return getInheritedStringModuleProblemProperty(
				aDynamicConfiguration, module, problem, test, aProperty, aDefault);
		
	}
	public static Integer getDynamicInheritedIntegerModuleProblemProperty(String aProperty, Integer aDefault) {
		PropertiesConfiguration aDynamicConfiguration =  ConfigurationManagerSelector.getConfigurationManager().getDynamicConfiguration();

		return getInheritedIntegerModuleProblemProperty(
				aDynamicConfiguration, module, problem, test, aProperty, aDefault);
		
	}
	public static Boolean getDynamicInheritedIBooleanModuleProblemProperty(String aProperty, Boolean aDefault) {
		PropertiesConfiguration aDynamicConfiguration =  ConfigurationManagerSelector.getConfigurationManager().getDynamicConfiguration();

		return getInheritedBooleanModuleProblemProperty(
				aDynamicConfiguration, module, problem, test, aProperty, aDefault);
		
	}
	public static List getDynamicInheritedListModuleProblemProperty(String aProperty, List aDefault) {
		PropertiesConfiguration aDynamicConfiguration =  ConfigurationManagerSelector.getConfigurationManager().getDynamicConfiguration();

		return getInheritedListModuleProblemProperty(
				aDynamicConfiguration, module, problem, test, aProperty, aDefault);
		
	}
	
	public static String getCourseOrStaticString(String aProperty, String aDefault) {
//		PropertiesConfiguration aDynamicConfiguration =  ConfigurationManagerSelector.getConfigurationManager().getDynamicConfiguration();
		PropertiesConfiguration staticConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getStaticConfiguration();
		PropertiesConfiguration courseConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getCourseConfiguration();
		 String aRetVal = null;
//		 if (aDynamicConfiguration != null) {// should never be null
//			 aRetVal = aDynamicConfiguration.getString(aProperty, null);
//		 }
//		 if (aRetVal != null)
//			 return aRetVal;
		 if (courseConfiguration != null) {
		 aRetVal = courseConfiguration.getString(aProperty, null);
		 }
         if (aRetVal == null) {
        	 if (staticConfiguration == null) {
        		 return aDefault;
        	 }
         	aRetVal = staticConfiguration.getString(aProperty, aDefault);
         }
         return aRetVal;		
	}
	
	public static Boolean getCourseOrStaticBoolean(String aProperty, Boolean aDefault) {
		PropertiesConfiguration staticConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getStaticConfiguration();
		PropertiesConfiguration courseConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getCourseConfiguration();
		 Boolean aRetVal = null;
		 	if (courseConfiguration != null) {
		 		aRetVal = courseConfiguration.getBoolean(aProperty, aDefault);
		 	}
         if (aRetVal == null) {
        	 if (staticConfiguration == null) {
        		 return aDefault;
        	 }
         	aRetVal = staticConfiguration.getBoolean(aProperty, aDefault);
         }
         return aRetVal;		
	}
	
	public static Integer getCourseOrStaticInteger(String aProperty, Integer aDefault) {
		PropertiesConfiguration staticConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getStaticConfiguration();
		PropertiesConfiguration courseConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getCourseConfiguration();
		 Integer aRetVal = null;
		 if (courseConfiguration != null) {
		 aRetVal = courseConfiguration.getInteger(aProperty, aDefault);
		 }
         if (aRetVal == null) {
        	 if (staticConfiguration == null) {
        		 return aDefault;
        	 }
         	aRetVal = staticConfiguration.getInteger(aProperty, aDefault);
         }
         return aRetVal;		
	}
	public static String getInheritedStringModuleProblemProperty(
			String module,
			String problem, String property, String aDefaultValue) {
	
		String retVal = StaticConfigurationUtils.getCourseOrStaticString(module + "." + problem + "."
				+ property, null);
	
		if (retVal == null) {
			retVal = StaticConfigurationUtils.getCourseOrStaticString(module + "." + property, null);
		}
		if (retVal == null) {
			retVal = StaticConfigurationUtils.getCourseOrStaticString(DEFAULT + "." + property,
					aDefaultValue);
		}
	
		return retVal;
	
	}
	public static String getInheritedStringModuleProblemProperty(
			String property, String defaultValue) {
//		PropertiesConfiguration configuration = ConfigurationManagerSelector
//				.getConfigurationManager().getStaticConfiguration();
		GraderSettingsManager graderSettingsManager = GraderSettingsManagerSelector
				.getGraderSettingsManager();
		String aModule = graderSettingsManager.getModule();
		String aProblem = graderSettingsManager.getNormalizedProblem(aModule);
//		return getInheritedStringModuleProblemProperty(configuration, aModule,
//				aProblem, property, defaultValue);
		return getInheritedStringModuleProblemProperty(aModule,
				aProblem, property, defaultValue);

	}

	public static Boolean getInheritedBooleanModuleProblemProperty(
			String property, Boolean defaultValue) {
//		PropertiesConfiguration configuration = ConfigurationManagerSelector
//				.getConfigurationManager().getStaticConfiguration();
		GraderSettingsManager graderSettingsManager = GraderSettingsManagerSelector
				.getGraderSettingsManager();
		if (graderSettingsManager == null) {
			return null;
		}
		String aModule = graderSettingsManager.getModule();
		if (aModule ==null) {
			System.err.println("Null module:");
			return defaultValue;
		}
		String aProblem = graderSettingsManager.getNormalizedProblem(aModule);
//		return getInheritedBooleanModuleProblemProperty(configuration, aModule,
//				aProblem, property, defaultValue);
		return getInheritedBooleanModuleProblemProperty(aModule,
				aProblem, property, defaultValue);

	}

	public static Integer getInheritedIntegerModuleProblemProperty(
			String property, Integer defaultValue) {
//		PropertiesConfiguration configuration = ConfigurationManagerSelector
//				.getConfigurationManager().getStaticConfiguration();
		GraderSettingsManager graderSettingsManager = GraderSettingsManagerSelector
				.getGraderSettingsManager();
		String aModule = graderSettingsManager.getModule();
		String aProblem = graderSettingsManager.getNormalizedProblem(aModule);
//		return getInheritedIntegerModuleProblemProperty(configuration, aModule,
//				aProblem, property, defaultValue);
		return getInheritedIntegerModuleProblemProperty( aModule,
		aProblem, property, defaultValue);

	}
	/*
	 * This should not b c alled directly
	 */
	public static String getLanguage() {
		String retVal = null;
		if (isUseProjectConfiguration()) {
			 retVal = getInheritedStringModuleProblemProperty(BasicConfigurationManagerSelector.getConfigurationManager().getOrCreateProjectConfiguration(), getModule(), getProblem(), LANGUAGE, null);
			 
		}
		if (retVal == null) {
			retVal = getInheritedStringModuleProblemProperty(LANGUAGE, BasicLanguageDependencyManager.JAVA_LANGUAGE);
		}
		return retVal;
	}

	public static List<String> getInheritedListModuleProblemProperty(
			String property, List<String> aDefaultValue) {
		PropertiesConfiguration configuration = ConfigurationManagerSelector
				.getConfigurationManager().getStaticConfiguration();
		PropertiesConfiguration courseConfiguration = ConfigurationManagerSelector
				.getConfigurationManager().getCourseConfiguration();
		GraderSettingsManager graderSettingsManager = GraderSettingsManagerSelector
				.getGraderSettingsManager();
		String aModule = graderSettingsManager.getModule();
		String aProblem = graderSettingsManager.getNormalizedProblem(aModule);
		String aTest = test;
		List<String> retVal = BasicStaticConfigurationUtils.getInheritedListModuleProblemProperty(courseConfiguration, aModule,
				aProblem, test, property, null);
		if (retVal == null || retVal.isEmpty())
			retVal =  BasicStaticConfigurationUtils.getInheritedListModuleProblemProperty(configuration, aModule,
					aProblem, test, property, null);
		if (retVal == null || retVal.isEmpty())
			retVal = aDefaultValue;
		return retVal;

	}

	// public static String getInheritedStringModuleProblemProperty( String
	// property, String defaultValue) {
	// PropertiesConfiguration configuration =
	// ConfigurationManagerSelector.getConfigurationManager().getStaticConfiguration();
	// GraderSettingsManager graderSettingsManager =
	// GraderSettingsManagerSelector.getGraderSettingsManager();
	// String aModule = graderSettingsManager.getModule();
	// String aProblem = graderSettingsManager.getNormalizedProblem(aModule);
	// return getInheritedStringModuleProblemProperty(configuration, aModule ,
	// aProblem, property, null);
	//
	// }
	public static String getInheritedStringModuleProblemProperty(
			PropertiesConfiguration configuration, String module,
			String problem, String property, String defaultValue) {

		String retVal = configuration.getString(module + "." + problem + "."
				+ property, null);

		if (retVal == null) {
			retVal = configuration.getString(module + "." + property, null);
		}
		if (retVal == null) {
			retVal = configuration.getString(BasicStaticConfigurationUtils.DEFAULT + "." + property,
					defaultValue);
		}

		return retVal;

	}

	public static List getInheritedListModuleProblemProperty(
			String module,
			String problem, String property) {

		List retVal = getCourseOrStaticList(module + "." + problem + "."
				+ property, null);

		if (retVal.isEmpty()) {
			retVal = getCourseOrStaticList(module + "." + property, null);
		}
		if (retVal.isEmpty()) {
			retVal = getCourseOrStaticList(BasicStaticConfigurationUtils.DEFAULT + "." + property, null);
		}

		return retVal;

	}

	public static ProjectRequirements getProjectRequirements(
			PropertiesConfiguration configuration,
			GraderSettingsManager graderSettingsManager) {

		ProjectRequirements requirements = null;

		String requirementsSpec = "";
		String normalizedRequirementsSpec = "";

		try {
//			requirementsSpec = getInheritedStringModuleProblemProperty(
//					REQUIREMENTS,
//					configuration.getString("project.requirements"));
			requirementsSpec = ExecutionSpecificationSelector.getExecutionSpecification().getRequirementsFormat();

			
			 normalizedRequirementsSpec = graderSettingsManager
					.replaceModuleProblemVars(requirementsSpec);

			
			Class<?> _class = Class.forName(normalizedRequirementsSpec);

			requirements = (ProjectRequirements) _class.newInstance();
		} catch (ClassNotFoundException e) {
			requirements = getInterpretedRequirements();
			if (requirements == null)
				System.err.println("Could not find project requirements:"
						+ requirementsSpec + " -->" + normalizedRequirementsSpec);
			// System.err.println(e.getMessage());
		} catch (InstantiationException e) {
			System.err.println("Could not create project requirements."
					+ requirements);
			System.err.println(e.getMessage());
		} catch (IllegalAccessException e) {
			System.err.println("Could not create project requirements."
					+ requirements);
			System.err.println(e.getMessage());
		}
		return requirements;

	}

	public static ProjectRequirements getInterpretedRequirements() {
		// SakaiProjectDatabase aDatabase = null;

		SakaiProjectDatabase aDatabase = ASakaiProjectDatabase
				.getCurrentSakaiProjectDatabase();
		try {
			CSVRequirementsSpecification aSpecification = aDatabase
					.getCSVRequirementsSpecification();
			return new AnInterpretedRequirements(aSpecification);

		} catch (Exception e) {
			System.out
					.println("Could not find interpreted requirements "
							+ AnAssignmenDataFolder.DEFAULT_REQUIREMENTS_SPREADHEET_NAME
							+ " in assignment data folder:"
							+ aDatabase.getAssignmentDataFolder()
									.getMixedCaseAbsoluteName());
			return null;
			// e.printStackTrace();
		}

	}

	public static List<String> getProcessTeams() {
//		if (processTeams != null) {
//			return processTeams;
//		}
		return getInheritedListModuleProblemProperty(PROCESS_TEAMS, emptyList);
	}

	public static List<String> getProcessArgs(String aProcess) {
		return getInheritedListModuleProblemProperty(aProcess + "." + ARGS, emptyList);
	}

	public static List<String> getProcessStartTags(String aProcess) {
		return getInheritedListModuleProblemProperty(aProcess + "."
				+ START_TAGS, emptyList);
	}

	public static Boolean getTrace() {
		return getInheritedBooleanModuleProblemProperty(GENERATE_TRACE_FILES,
				false);
	}

//	public static final int DEFAULT_SLEEP_TIME = 2000;

	public static Integer getResourceReleaseTime(String aProcess) {
		return getInheritedIntegerModuleProblemProperty(aProcess + "."
				+ RESOURCE_RELEASE_TIME, DEFAULT_RESOURCE_RELEASE_TIME);
	}

	public static String getEntryTag(String aProcess) {
		return getInheritedStringModuleProblemProperty(aProcess + "."
				+ ENTRY_TAG, null);
	}

	public static List<String> getEntryTags(String aProcess) {
		return getInheritedListModuleProblemProperty(aProcess + "."
				+ ENTRY_TAGS, emptyList);
	}

	public static String getEntryPoint(String aProcess) {
		return getInheritedStringModuleProblemProperty(aProcess + "."
				+ ENTRY_POINT, null);
	}

	public static List<String> getProcesses(String aProcessTeam) {
		return getInheritedListModuleProblemProperty(aProcessTeam, emptyList);
	}

	public static List<String> getTerminatingProcesses(String aProcessTeam) {
		return getInheritedListModuleProblemProperty(aProcessTeam + "."
				+ TERMINATING, emptyList);
	}
	
	
	
	public static String getDynamicExecutionFileName() {
		if (Driver.getConfiguration() != null) {
            return  Driver.getConfiguration().getString(AConfigurationManager.DYNAMIC_CONFIG_PROPERTY, AConfigurationManager.DYNAMIC_CONFIGURATION_FILE_NAME);

		}
		
		return AConfigurationManager.DYNAMIC_CONFIGURATION_FILE_NAME;
	}
	


	

}
]]></snapshot>
  </Command>
  <Command __id="8209" _type="FileOpenCommand" date="Sun Aug 25 09:12:36 EDT 2019" docASTNodeCount="84" docActiveCodeLength="808" docExpressionCount="44" docLength="808" projectName="comp110-grader" timestamp="163079926">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\config\ConfigurationManager.java]]></filePath>
    <snapshot><![CDATA[package grader.config;

import org.apache.commons.configuration.PropertiesConfiguration;

import grader.basics.config.BasicConfigurationManager;

public interface ConfigurationManager extends BasicConfigurationManager{
	public  PropertiesConfiguration getStaticConfiguration() ;
	public  void setStaticConfiguration(
			PropertiesConfiguration staticConfiguration) ;
	public  PropertiesConfiguration getDynamicConfiguration() ;
	public  void setDynamicConfiguration(
			PropertiesConfiguration dynamicConfiguration) ;
	void init(String[] args);
	PropertiesConfiguration getCourseConfiguration();
	void setCourseConfiguration(PropertiesConfiguration newVal);
	PropertiesConfiguration getDynamicModuleConfiguration();
	void setDynamicModuleConfiguration(PropertiesConfiguration newVal);

}
]]></snapshot>
  </Command>
  <Command __id="8218" _type="FileOpenCommand" date="Sun Aug 25 09:12:57 EDT 2019" docASTNodeCount="889" docActiveCodeLength="9101" docExpressionCount="553" docLength="11656" projectName="comp110-grader" timestamp="163100402">
    <filePath><![CDATA[D:\dewan_backup\Java\Grader\src\main\java\grader\config\AConfigurationManager.java]]></filePath>
    <snapshot><![CDATA[package grader.config;

import framework.utils.UserPropertyWriter;
import grader.basics.config.ABasicConfigurationManager;
import grader.basics.project.CurrentProjectHolder;
import grader.executor.ExecutorSelector;
import grader.language.LanguageDependencyManager;
import grader.trace.config.DynamicConfigurationFileCreated;
import grader.trace.config.DynamicConfigurationFileRead;
import grader.trace.config.StaticConfigurationFileNotRead;
import grader.trace.config.StaticConfigurationFileRead;
import util.trace.Tracer;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.Arrays;

import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.PropertiesConfiguration;

public class AConfigurationManager extends ABasicConfigurationManager implements ConfigurationManager {

    public static final String CONFIG_DIR = "config";
    public static final String CONFIG_FILE = "config.properties";
    public static final String DYNAMIC_CONFIGURATION_FILE = "dynamicconfig.properties";
    public static final String COURSE_FILE = "course.properties";
    public static final String DYNAMIC_MODULES_FILE = "dynamicmodules.properties";
    public static final String DYNAMIC_CONFIG_PROPERTY = "grader.dynamicConfiguration";
//    public static final String STATIC_CONFIGURATION_FILE_NAME = "./config/config.properties";
    public static final String STATIC_CONFIGURATION_FILE_NAME = "./" + CONFIG_DIR + "/" + CONFIG_FILE;
    public static final String DYNAMIC_CONFIGURATION_FILE_NAME = "./" + CONFIG_DIR + "/" + DYNAMIC_CONFIGURATION_FILE;

    public static final String COURSE_CONFIGURATION_FILE_NAME = "./" + CONFIG_DIR + "/" + COURSE_FILE;
    public static final String DYNAMIC_MODULE_CONFIGURATION_FILE_NAME = "./" + CONFIG_DIR + "/" + DYNAMIC_MODULES_FILE;


    private static PropertiesConfiguration staticConfiguration = new PropertiesConfiguration();
    static File userPropsFile;
    PropertiesConfiguration dynamicConfiguration;
    PropertiesConfiguration moduleConfiguration, dynamicModuleConfiguration;

    public AConfigurationManager() {
//		init();

    }


    /**
     * These methods should be in StaticConfigurationUtils
     */
    public PropertiesConfiguration getDynamicConfiguration() {
        return dynamicConfiguration;
    }
    

    public void setDynamicConfiguration(
            PropertiesConfiguration dynamicConfiguration) {
        this.dynamicConfiguration = dynamicConfiguration;
    }

    public PropertiesConfiguration getStaticConfiguration() {
        return staticConfiguration;
    }

    public void setStaticConfiguration(PropertiesConfiguration staticConfiguration) {
        this.staticConfiguration = staticConfiguration;
    }
    @Override
    public PropertiesConfiguration getCourseConfiguration() {
        return moduleConfiguration;
    }
    @Override
    public void setCourseConfiguration(PropertiesConfiguration newVal) {
        this.moduleConfiguration = newVal;
    }
    
    @Override
    public PropertiesConfiguration getDynamicModuleConfiguration() {
        return dynamicModuleConfiguration;
    }
    @Override
    public void setDynamicModuleConfiguration(PropertiesConfiguration newVal) {
        this.dynamicModuleConfiguration = newVal;
    }


    public void init(String args[]) {
        try {
//			 PropertiesConfiguration configuration = new PropertiesConfiguration("./config/config.properties");
//			 PropertiesConfiguration configuration = new PropertiesConfiguration(STATIC_CONFIGURATION_FILE_NAME);
            PropertiesConfiguration configuration = createStaticConfiguration(args);
            if (configuration != null) {
            StaticConfigurationFileRead.newCase(STATIC_CONFIGURATION_FILE_NAME, this);
            setStaticConfiguration(configuration);
            }
//            String dynamicConfigurationName = configuration.getString(DYNAMIC_CONFIG_PROPERTY, DYNAMIC_CONFIGURATION_FILE_NAME);
            // allowing for no configuration
            String dynamicConfigurationName = ExecutionSpecificationSelector.getExecutionSpecification().getDynamicExecutionFileName();

            File dynamicConfigurationFile = new File(dynamicConfigurationName);
            if (!dynamicConfigurationFile.exists()) {
            	File parent = dynamicConfigurationFile.getParentFile();
            	if (!parent.exists()) {
            		parent.mkdirs();
            	}
                dynamicConfigurationFile.createNewFile();
                DynamicConfigurationFileCreated.newCase(dynamicConfigurationName, this);
//	         	convertToDynamicConfiguration();
            }
//            dynamicConfiguration = new PropertiesConfiguration(dynamicConfigurationName);
            setDynamicConfiguration(createDynamicConfiguration(args, dynamicConfigurationName));

            DynamicConfigurationFileRead.newCase(dynamicConfigurationName, this);
            
            setCourseConfiguration(createCourseConfiguration(args));
            
            
           File dynamicModuleFile = new File(DYNAMIC_MODULE_CONFIGURATION_FILE_NAME);
           if (!dynamicModuleFile.exists()) {
           	File parent = dynamicModuleFile.getParentFile();
           	if (!parent.exists()) {
           		parent.mkdirs();
           	}
           	dynamicModuleFile.createNewFile();
//	         	convertToDynamicConfiguration();
           }
            
            setDynamicModuleConfiguration(new PropertiesConfiguration(dynamicModuleFile.getAbsolutePath()));  
//            LanguageDependencyManager.setCOBj(
//            		StaticConfigurationUtils.getCourseOrStaticString(StaticConfigurationUtils.C_OBJ, null));
            /*
             * Why are these values being pushed eagerly rather than pulled when needed lazily
             */
            String cObj = ExecutionSpecificationSelector.getExecutionSpecification().getCObjSuffix();

            LanguageDependencyManager.setCOBj(
            		cObj);

//            ExecutorSelector.getExecutor().setExecutorDirectory(
//            		StaticConfigurationUtils.getCourseOrStaticString(StaticConfigurationUtils.EXECUTOR, null));
            // really do not understand what an executor is.
            ExecutorSelector.getExecutor().setExecutorDirectory(
            		
            		ExecutionSpecificationSelector.getExecutionSpecification().getExecutorDirectory()
            		);

//	         GraderSettings.get().convertToDynamicConfiguration();
        } catch (ConfigurationException e) {
            StaticConfigurationFileNotRead.newCase(STATIC_CONFIGURATION_FILE_NAME, this);
            System.err.println("Error loading config file.");
            System.err.println(e.getMessage());
            e.printStackTrace();

        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    
    PropertiesConfiguration createCourseConfiguration(String[] args) {
       
                try {
                	File aFile = new File(COURSE_CONFIGURATION_FILE_NAME);
                	if (!aFile.exists()) {
                		Tracer.warning (COURSE_CONFIGURATION_FILE_NAME + " does not exist, using defaults");
                		return null;
                	}
					return new PropertiesConfiguration(COURSE_CONFIGURATION_FILE_NAME);
				} catch (ConfigurationException e) {
					e.printStackTrace();
					return null;
				}
                
                // Andrew might need to add stuff like in the method below
        
    }
    
    PropertiesConfiguration createStaticConfiguration(String[] args) {
        userPropsFile = null;
        try {
        //  this seems wrong, one should use the satic file and overrwrite those args
        	// Best is to use course configuration and use overwrite or set property to overrwrite it
        	// will not change until I have tried out andrew's server
            if (args.length == 0) { 
            	File aConfigFile = new File(STATIC_CONFIGURATION_FILE_NAME);
            	if (!aConfigFile.exists()) {
            		Tracer.warning(STATIC_CONFIGURATION_FILE_NAME + " not found, using defaults" );
            		return null;
            	}
                return new PropertiesConfiguration(STATIC_CONFIGURATION_FILE_NAME);
            }
//		           UserPropertyWriter userProperties = new UserPropertyWriter(Paths.get("config", "config.properties").toString());
            UserPropertyWriter userProperties = new UserPropertyWriter(Paths.get(CONFIG_DIR, CONFIG_FILE).toString());
// this seems to be Andrew's code duplicating the properties in a thread specific file
            
            userProperties.setUserProperties(args);
            userPropsFile = Paths.get(CONFIG_DIR, "user-config.properties").toFile();
            
            if (userPropsFile.exists()) {
                userPropsFile.delete();
            }
            
            try {
                userPropsFile.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }

            userProperties.writeUserProperties(userPropsFile);
            // Load the default config file
            PropertiesConfiguration configuration = new PropertiesConfiguration(userPropsFile);
            
            return configuration;
//			PropertiesConfiguration configuration = new PropertiesConfiguration(STATIC_CONFIGURATION_FILE_NAME);
        } catch (ConfigurationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return null;
        } finally {
            //System.out.println("run done");
            //if (userPropsFile != null) {
            //    userPropsFile.delete();
            //}
        }
    }
    
    PropertiesConfiguration createDynamicConfiguration(String[] args, String dynamicConfigName) {
        userPropsFile = null;
        try {
            if (args.length == 0) {
                return new PropertiesConfiguration(dynamicConfigName);
            }
//		           UserPropertyWriter userProperties = new UserPropertyWriter(Paths.get("config", "config.properties").toString());
            UserPropertyWriter userProperties = new UserPropertyWriter(dynamicConfigName);
// this seems to be Andrew's code duplicating the properties in a thread specific file
            System.out.println ("Writing user properties:" + Arrays.toString(args));
            userProperties.setUserProperties(args);
            userPropsFile = Paths.get(dynamicConfigName).toFile();
            
            try {
                userPropsFile.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }

            userProperties.writeUserProperties(userPropsFile);
            // Load the default config file
            PropertiesConfiguration configuration = new PropertiesConfiguration(userPropsFile);
            
            return configuration;
//			PropertiesConfiguration configuration = new PropertiesConfiguration(STATIC_CONFIGURATION_FILE_NAME);
        } catch (ConfigurationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return null;
        } finally {
            //System.out.println("run done");
            //if (userPropsFile != null) {
            //    userPropsFile.delete();
            //}
        }
    }

}
]]></snapshot>
  </Command>
  <DocumentChange __id="8243" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="888" docActiveCodeLength="9091" docExpressionCount="552" docLength="11646" endLine="197" length="10" offset="8936" startLine="197" timestamp="163264778">
    <text><![CDATA[CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8244" _type="Insert" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="891" docActiveCodeLength="9128" docExpressionCount="555" docLength="11683" length="37" offset="8936" timestamp="163264788">
    <text><![CDATA[ABasicConfigurationManager.CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8245" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="890" docActiveCodeLength="9118" docExpressionCount="554" docLength="11673" endLine="193" length="10" offset="8704" startLine="193" timestamp="163264789">
    <text><![CDATA[CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8246" _type="Insert" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="893" docActiveCodeLength="9155" docExpressionCount="557" docLength="11710" length="37" offset="8704" timestamp="163264791">
    <text><![CDATA[ABasicConfigurationManager.CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8247" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="893" docActiveCodeLength="9145" docExpressionCount="557" docLength="11700" endLine="34" length="10" offset="1842" startLine="34" timestamp="163264792">
    <text><![CDATA[CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8248" _type="Insert" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="895" docActiveCodeLength="9182" docExpressionCount="559" docLength="11737" length="37" offset="1842" timestamp="163264793">
    <text><![CDATA[ABasicConfigurationManager.CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8249" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="895" docActiveCodeLength="9172" docExpressionCount="559" docLength="11727" endLine="33" length="10" offset="1730" startLine="33" timestamp="163264794">
    <text><![CDATA[CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8250" _type="Insert" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="897" docActiveCodeLength="9209" docExpressionCount="561" docLength="11764" length="37" offset="1730" timestamp="163264795">
    <text><![CDATA[ABasicConfigurationManager.CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8251" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="897" docActiveCodeLength="9199" docExpressionCount="561" docLength="11754" endLine="31" length="10" offset="1609" startLine="31" timestamp="163264796">
    <text><![CDATA[CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8252" _type="Insert" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="899" docActiveCodeLength="9236" docExpressionCount="563" docLength="11791" length="37" offset="1609" timestamp="163264797">
    <text><![CDATA[ABasicConfigurationManager.CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8253" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="899" docActiveCodeLength="9226" docExpressionCount="563" docLength="11781" endLine="30" length="10" offset="1504" startLine="30" timestamp="163264798">
    <text><![CDATA[CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8254" _type="Insert" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="901" docActiveCodeLength="9263" docExpressionCount="565" docLength="11818" length="37" offset="1504" timestamp="163264800">
    <text><![CDATA[ABasicConfigurationManager.CONFIG_DIR]]></text>
  </DocumentChange>
  <DocumentChange __id="8255" _type="Delete" date="Sun Aug 25 09:15:41 EDT 2019" docASTNodeCount="892" docActiveCodeLength="9208" docExpressionCount="562" docLength="11763" endLine="24" length="55" offset="889" repeat="2" startLine="23" timestamp="163264801" timestamp2="163264802">
    <text><![CDATA[public static final String CONFIG_DIR = "config";
    ]]></text>
  </DocumentChange>
  <Command __id="8222" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:13:03 EDT 2019" forward="true" matchWord="false" offset="812" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="163107059" wrapSearch="true">
    <searchString><![CDATA[getCoutrseCon]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8223" _type="ShellCommand" date="Sun Aug 25 09:13:07 EDT 2019" timestamp="163111005" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8224" _type="MoveCaretCommand" caretOffset="404" date="Sun Aug 25 09:13:08 EDT 2019" docOffset="1110" timestamp="163111092" />
  <Command __id="8225" _type="ShellCommand" date="Sun Aug 25 09:13:10 EDT 2019" timestamp="163113921" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8226" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:13:14 EDT 2019" forward="true" matchWord="false" offset="1110" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="163117841" wrapSearch="true">
    <searchString><![CDATA[getCourseConf]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8227" _type="ShellCommand" date="Sun Aug 25 09:13:20 EDT 2019" timestamp="163123509" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8228" _type="MoveCaretCommand" caretOffset="2225" date="Sun Aug 25 09:13:20 EDT 2019" docOffset="2931" timestamp="163123634" />
  <Command __id="8229" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sun Aug 25 09:13:26 EDT 2019" timestamp="163130044" />
  <Command __id="8230" _type="MoveCaretCommand" caretOffset="2285" date="Sun Aug 25 09:13:36 EDT 2019" docOffset="2991" timestamp="163139352" />
  <Command __id="8231" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sun Aug 25 09:13:37 EDT 2019" timestamp="163140626" />
  <Command __id="8232" _type="MoveCaretCommand" caretOffset="4390" date="Sun Aug 25 09:13:43 EDT 2019" docOffset="5096" timestamp="163146840" />
  <Command __id="8233" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:13:52 EDT 2019" timestamp="163155494" />
  <Command __id="8234" _type="MoveCaretCommand" caretOffset="6503" date="Sun Aug 25 09:14:12 EDT 2019" docOffset="7209" timestamp="163175826" />
  <Command __id="8235" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:14:13 EDT 2019" timestamp="163176220" />
  <Command __id="8236" _type="MoveCaretCommand" caretOffset="1024" date="Sun Aug 25 09:14:19 EDT 2019" docOffset="1730" timestamp="163182294" />
  <Command __id="8237" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:14:19 EDT 2019" timestamp="163182917" />
  <Command __id="8238" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sun Aug 25 09:14:22 EDT 2019" repeat="3" timestamp="163185334" timestamp2="163186648" />
  <Command __id="8241" _type="MoveCaretCommand" caretOffset="210" date="Sun Aug 25 09:15:14 EDT 2019" docOffset="916" timestamp="163237899" />
  <Command __id="8242" _type="ShellCommand" date="Sun Aug 25 09:15:16 EDT 2019" timestamp="163239607" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8257" _type="ShellCommand" date="Sun Aug 25 09:15:41 EDT 2019" timestamp="163265043" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8258" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.move.element" date="Sun Aug 25 09:15:41 EDT 2019" timestamp="163265066" />
  <Command __id="8259" _type="MoveCaretCommand" caretOffset="983" date="Sun Aug 25 09:16:08 EDT 2019" docOffset="1689" timestamp="163291404" />
  <Command __id="8260" _type="ShellCommand" date="Sun Aug 25 09:16:20 EDT 2019" timestamp="163303487" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8262" _type="PredictionCommand" date="Sun Aug 25 09:16:23 EDT 2019" prediction_type="MakingProgress" timestamp="163306719" />
  <Command __id="8270" _type="ShellCommand" date="Sun Aug 25 09:16:23 EDT 2019" timestamp="163306939" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8271" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.move.element" date="Sun Aug 25 09:16:23 EDT 2019" timestamp="163306965" />
  <Command __id="8272" _type="MoveCaretCommand" caretOffset="366" date="Sun Aug 25 09:16:27 EDT 2019" docOffset="1072" timestamp="163310672" />
  <Command __id="8273" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.search.references.in.workspace" date="Sun Aug 25 09:16:45 EDT 2019" timestamp="163328181" />
  <Command __id="8274" _type="ShellCommand" date="Sun Aug 25 09:16:53 EDT 2019" timestamp="163336097" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8277" _type="ShellCommand" date="Sun Aug 25 09:16:55 EDT 2019" timestamp="163338875" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8278" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.move.element" date="Sun Aug 25 09:16:55 EDT 2019" timestamp="163338899" />
  <Command __id="8281" _type="InsertStringCommand" date="Sun Aug 25 09:17:17 EDT 2019" repeat="4" timestamp="163360646" timestamp2="163361195">
    <data><![CDATA[init]]></data>
  </Command>
  <Command __id="8289" _type="UndoCommand" date="Sun Aug 25 09:17:19 EDT 2019" timestamp="163362136" />
  <Command __id="8290" _type="MoveCaretCommand" caretOffset="1035" date="Sun Aug 25 09:17:20 EDT 2019" docOffset="1741" timestamp="163363402" />
  <Command __id="8292" _type="ShellCommand" date="Sun Aug 25 09:17:23 EDT 2019" timestamp="163366120" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8293" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:17:25 EDT 2019" forward="true" matchWord="false" offset="1741" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="163369071" wrapSearch="true">
    <searchString><![CDATA[init]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8294" _type="ShellCommand" date="Sun Aug 25 09:17:31 EDT 2019" timestamp="163374180" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8295" _type="MoveCaretCommand" caretOffset="4222" date="Sun Aug 25 09:17:37 EDT 2019" docOffset="4928" timestamp="163380767" />
  <Command __id="8296" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:17:39 EDT 2019" timestamp="163382169" />
  <Command __id="8297" _type="EclipseCommand" commandID="org.eclipse.ui.navigate.backwardHistory" date="Sun Aug 25 09:17:41 EDT 2019" timestamp="163384766" />
  <Command __id="8298" _type="MoveCaretCommand" caretOffset="4245" date="Sun Aug 25 09:17:45 EDT 2019" docOffset="4951" timestamp="163388295" />
  <Command __id="8299" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:17:46 EDT 2019" timestamp="163389101" />
  <Command __id="8300" _type="MoveCaretCommand" caretOffset="6243" date="Sun Aug 25 09:17:58 EDT 2019" docOffset="6949" timestamp="163401764" />
  <Command __id="8301" _type="ShellCommand" date="Sun Aug 25 09:18:00 EDT 2019" timestamp="163403412" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8302" _type="ShellCommand" date="Sun Aug 25 09:18:02 EDT 2019" timestamp="163405452" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8303" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.move.element" date="Sun Aug 25 09:18:02 EDT 2019" timestamp="163405477" />
  <Command __id="8304" _type="ShellCommand" date="Sun Aug 25 09:18:06 EDT 2019" timestamp="163409790" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8305" _type="ShellCommand" date="Sun Aug 25 09:18:12 EDT 2019" timestamp="163415448" type="ECLIPSE_GAINED_FOCUS" />
  <DocumentChange __id="8261" _type="Delete" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="891" docActiveCodeLength="9178" docExpressionCount="561" docLength="11733" endLine="167" length="30" offset="7533" startLine="167" timestamp="163306714">
    <text><![CDATA[COURSE_CONFIGURATION_FILE_NAME]]></text>
  </DocumentChange>
  <DocumentChange __id="8263" _type="Insert" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="894" docActiveCodeLength="9235" docExpressionCount="564" docLength="11790" length="57" offset="7533" timestamp="163306730">
    <text><![CDATA[ABasicConfigurationManager.COURSE_CONFIGURATION_FILE_NAME]]></text>
  </DocumentChange>
  <DocumentChange __id="8264" _type="Delete" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="893" docActiveCodeLength="9205" docExpressionCount="563" docLength="11760" endLine="164" length="30" offset="7371" startLine="164" timestamp="163306731">
    <text><![CDATA[COURSE_CONFIGURATION_FILE_NAME]]></text>
  </DocumentChange>
  <DocumentChange __id="8265" _type="Insert" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="896" docActiveCodeLength="9262" docExpressionCount="566" docLength="11817" length="57" offset="7371" timestamp="163306732">
    <text><![CDATA[ABasicConfigurationManager.COURSE_CONFIGURATION_FILE_NAME]]></text>
  </DocumentChange>
  <DocumentChange __id="8266" _type="Delete" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="895" docActiveCodeLength="9232" docExpressionCount="565" docLength="11787" endLine="162" length="30" offset="7262" startLine="162" timestamp="163306733">
    <text><![CDATA[COURSE_CONFIGURATION_FILE_NAME]]></text>
  </DocumentChange>
  <DocumentChange __id="8267" _type="Insert" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="898" docActiveCodeLength="9289" docExpressionCount="568" docLength="11844" length="57" offset="7262" timestamp="163306734">
    <text><![CDATA[ABasicConfigurationManager.COURSE_CONFIGURATION_FILE_NAME]]></text>
  </DocumentChange>
  <DocumentChange __id="8268" _type="Delete" date="Sun Aug 25 09:16:23 EDT 2019" docASTNodeCount="883" docActiveCodeLength="9158" docExpressionCount="559" docLength="11713" endLine="33" length="131" offset="1662" repeat="2" startLine="32" timestamp="163306735" timestamp2="163306736">
    <text><![CDATA[public static final String COURSE_CONFIGURATION_FILE_NAME = "./" + ABasicConfigurationManager.CONFIG_DIR + "/" + COURSE_FILE;
    ]]></text>
  </DocumentChange>
  <DocumentChange __id="8275" _type="Delete" date="Sun Aug 25 09:16:55 EDT 2019" docASTNodeCount="874" docActiveCodeLength="9091" docExpressionCount="556" docLength="11646" endLine="26" length="67" offset="1045" repeat="2" startLine="25" timestamp="163338666" timestamp2="163338675">
    <text><![CDATA[public static final String COURSE_FILE = "course.properties";
    ]]></text>
  </DocumentChange>
  <DocumentChange __id="8280" _type="Insert" date="Sun Aug 25 09:17:17 EDT 2019" docASTNodeCount="873" docActiveCodeLength="9095" docExpressionCount="556" docLength="11650" length="4" offset="1045" repeat="4" timestamp="163360636" timestamp2="163361184">
    <text><![CDATA[init]]></text>
  </DocumentChange>
  <DocumentChange __id="8288" _type="Delete" date="Sun Aug 25 09:17:19 EDT 2019" docASTNodeCount="874" docActiveCodeLength="9091" docExpressionCount="556" docLength="11646" endLine="25" length="4" offset="1045" startLine="25" timestamp="163362114">
    <text><![CDATA[init]]></text>
  </DocumentChange>
  <DocumentChange __id="8309" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="867" docActiveCodeLength="9021" docExpressionCount="552" docLength="11648" length="2" offset="6921" timestamp="163432513">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8310" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="867" docActiveCodeLength="9014" docExpressionCount="552" docLength="11650" length="2" offset="6995" timestamp="163432515">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8311" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="854" docActiveCodeLength="8993" docExpressionCount="543" docLength="11652" length="2" offset="7006" timestamp="163432517">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8312" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="843" docActiveCodeLength="8895" docExpressionCount="536" docLength="11654" length="2" offset="7031" timestamp="163432519">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8313" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="830" docActiveCodeLength="8856" docExpressionCount="527" docLength="11656" length="2" offset="7133" timestamp="163432523">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8314" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="830" docActiveCodeLength="8727" docExpressionCount="527" docLength="11658" length="2" offset="7176" timestamp="163432524">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8315" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="830" docActiveCodeLength="8697" docExpressionCount="527" docLength="11660" length="2" offset="7309" timestamp="163432526">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8316" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="830" docActiveCodeLength="8679" docExpressionCount="527" docLength="11662" length="2" offset="7343" timestamp="163432528">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8317" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="830" docActiveCodeLength="8580" docExpressionCount="527" docLength="11664" length="2" offset="7365" timestamp="163432530">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8318" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="817" docActiveCodeLength="8540" docExpressionCount="521" docLength="11666" length="2" offset="7468" timestamp="163432532">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8319" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="817" docActiveCodeLength="8515" docExpressionCount="521" docLength="11668" length="2" offset="7512" timestamp="163432533">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8320" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="817" docActiveCodeLength="8498" docExpressionCount="521" docLength="11670" length="2" offset="7541" timestamp="163432535">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8321" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="817" docActiveCodeLength="8493" docExpressionCount="521" docLength="11672" length="2" offset="7562" timestamp="163432537">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <DocumentChange __id="8322" _type="Insert" date="Sun Aug 25 09:18:29 EDT 2019" docASTNodeCount="817" docActiveCodeLength="8477" docExpressionCount="521" docLength="11674" length="2" offset="7571" timestamp="163432538">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="8358" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Aug 25 09:19:59 EDT 2019" repeat="22" timestamp="163522402" timestamp2="163526813" />
  <Command __id="8401" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Aug 25 09:20:06 EDT 2019" timestamp="163529401" />
  <Command __id="8402" _type="MoveCaretCommand" caretOffset="852" date="Sun Aug 25 09:20:13 EDT 2019" docOffset="852" timestamp="163536541" />
  <Command __id="8403" _type="SelectTextCommand" caretOffset="854" date="Sun Aug 25 09:20:13 EDT 2019" end="854" start="849" timestamp="163536723" />
  <Command __id="8404" _type="SelectTextCommand" caretOffset="886" date="Sun Aug 25 09:20:13 EDT 2019" end="886" start="834" timestamp="163536931" />
  <Command __id="8406" _type="CutCommand" date="Sun Aug 25 09:20:14 EDT 2019" timestamp="163537782" />
  <Command __id="8407" _type="MoveCaretCommand" caretOffset="727" date="Sun Aug 25 09:20:16 EDT 2019" docOffset="727" timestamp="163539391" />
  <Command __id="8409" _type="InsertStringCommand" date="Sun Aug 25 09:20:16 EDT 2019" timestamp="163539755" timestamp2="163539755">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="8411" _type="PasteCommand" date="Sun Aug 25 09:20:17 EDT 2019" timestamp="163540426" />
  <Command __id="8412" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Aug 25 09:20:18 EDT 2019" timestamp="163541836" />
  <Command __id="8414" _type="ShellCommand" date="Sun Aug 25 09:20:27 EDT 2019" timestamp="163550928" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8415" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:20:31 EDT 2019" forward="true" matchWord="false" offset="781" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="163554152" wrapSearch="true">
    <searchString><![CDATA[init]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8416" _type="ShellCommand" date="Sun Aug 25 09:20:35 EDT 2019" timestamp="163558084" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8418" _type="SelectTextCommand" caretOffset="6982" date="Sun Aug 25 09:20:35 EDT 2019" end="6982" start="6221" timestamp="163558454" />
  <Command __id="8419" _type="MoveCaretCommand" caretOffset="6298" date="Sun Aug 25 09:20:36 EDT 2019" docOffset="7004" timestamp="163559234" />
  <Command __id="8421" _type="MoveCaretCommand" caretOffset="781" date="Sun Aug 25 09:20:45 EDT 2019" docOffset="781" timestamp="163568841" />
  <Command __id="8422" _type="MoveCaretCommand" caretOffset="1776" date="Sun Aug 25 09:20:52 EDT 2019" docOffset="1776" timestamp="163575926" />
  <Command __id="8424" _type="InsertStringCommand" date="Sun Aug 25 09:20:53 EDT 2019" repeat="10" timestamp="163576439" timestamp2="163577819">
    <data><![CDATA[protected ]]></data>
  </Command>
  <Command __id="8443" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Aug 25 09:20:55 EDT 2019" timestamp="163578579" />
  <Command __id="8445" _type="SelectTextCommand" caretOffset="4270" date="Sun Aug 25 09:21:03 EDT 2019" end="4270" start="4245" timestamp="163586981" />
  <Command __id="8446" _type="MoveCaretCommand" caretOffset="1215" date="Sun Aug 25 09:21:14 EDT 2019" docOffset="1921" timestamp="163597854" />
  <Command __id="8449" _type="InsertStringCommand" date="Sun Aug 25 09:21:16 EDT 2019" repeat="2" timestamp="163599281" timestamp2="163599531">
    <data><![CDATA[in]]></data>
  </Command>
  <Command __id="8453" _type="UndoCommand" date="Sun Aug 25 09:21:17 EDT 2019" timestamp="163600774" />
  <Command __id="8454" _type="MoveCaretCommand" caretOffset="1355" date="Sun Aug 25 09:21:18 EDT 2019" docOffset="2061" timestamp="163602059" />
  <Command __id="8564" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Aug 25 09:23:28 EDT 2019" repeat="2" timestamp="163731079" timestamp2="163731238" />
  <Command __id="8567" _type="InsertStringCommand" date="Sun Aug 25 09:23:28 EDT 2019" repeat="3" timestamp="163731995" timestamp2="163733027">
    <data><![CDATA[	 {]]></data>
  </Command>
  <Command __id="8573" _type="InsertStringCommand" date="Sun Aug 25 09:23:30 EDT 2019" timestamp="163733295" timestamp2="163733295">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="8575" _type="PasteCommand" date="Sun Aug 25 09:23:32 EDT 2019" timestamp="163735721" />
  <Command __id="8576" _type="MoveCaretCommand" caretOffset="954" date="Sun Aug 25 09:23:36 EDT 2019" docOffset="954" timestamp="163739997" />
  <Command __id="8577" _type="MoveCaretCommand" caretOffset="953" date="Sun Aug 25 09:23:38 EDT 2019" docOffset="953" timestamp="163741498" />
  <Command __id="8578" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.open.editor" date="Sun Aug 25 09:23:39 EDT 2019" timestamp="163742315" />
  <Command __id="8579" _type="MoveCaretCommand" caretOffset="1953" date="Sun Aug 25 09:23:44 EDT 2019" docOffset="1953" timestamp="163747714" />
  <Command __id="8581" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Aug 25 09:23:45 EDT 2019" repeat="13" timestamp="163748162" timestamp2="163750151" />
  <Command __id="8606" _type="MoveCaretCommand" caretOffset="981" date="Sun Aug 25 09:23:53 EDT 2019" docOffset="981" timestamp="163756736" />
  <Command __id="8607" _type="SelectTextCommand" caretOffset="983" date="Sun Aug 25 09:23:53 EDT 2019" end="983" start="979" timestamp="163756925" />
  <Command __id="8609" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" date="Sun Aug 25 09:23:54 EDT 2019" timestamp="163757602" />
  <Command __id="8610" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Aug 25 09:23:56 EDT 2019" timestamp="163759417" />
  <Command __id="8612" _type="SelectTextCommand" caretOffset="4278" date="Sun Aug 25 09:24:18 EDT 2019" end="4278" start="4222" timestamp="163781979" />
  <Command __id="8613" _type="MoveCaretCommand" caretOffset="4208" date="Sun Aug 25 09:24:20 EDT 2019" docOffset="4914" timestamp="163783257" />
  <Command __id="8614" _type="MoveCaretCommand" caretOffset="4221" date="Sun Aug 25 09:24:21 EDT 2019" docOffset="4927" timestamp="163784516" />
  <Command __id="8616" _type="EclipseCommand" commandID="org.eclipse.jdt.ui.edit.text.java.toggle.comment" date="Sun Aug 25 09:24:22 EDT 2019" timestamp="163785238" />
  <Command __id="8617" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" date="Sun Aug 25 09:24:23 EDT 2019" timestamp="163786302" />
  <Command __id="8619" _type="ShellCommand" date="Sun Aug 25 09:24:31 EDT 2019" timestamp="163794727" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8620" _type="FindCommand" caseSensitive="true" date="Sun Aug 25 09:24:36 EDT 2019" forward="true" matchWord="false" offset="4929" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="163799854" wrapSearch="true">
    <searchString><![CDATA[setCourseC]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="8621" _type="ShellCommand" date="Sun Aug 25 09:24:41 EDT 2019" timestamp="163804899" type="ECLIPSE_GAINED_FOCUS" />
  <Command __id="8622" _type="MoveCaretCommand" caretOffset="2037" date="Sun Aug 25 09:24:41 EDT 2019" docOffset="2743" timestamp="163805038" />
  <Command __id="8623" _type="ShellCommand" date="Sun Aug 25 09:24:43 EDT 2019" timestamp="163806386" type="ECLIPSE_LOST_FOCUS" />
  <Command __id="8624" _type="ShellCommand" date="Sun Aug 25 09:24:45 EDT 2019" timestamp="163808550" type="ECLIPSE_GAINED_FOCUS" />
</Events>
